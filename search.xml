<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用kubeadm安装k8s</title>
      <link href="/2019/08/26/install-k8s/"/>
      <url>/2019/08/26/install-k8s/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="主机配置和角色分配"><a href="#主机配置和角色分配" class="headerlink" title="主机配置和角色分配"></a>主机配置和角色分配</h3><table><thead><tr><th>ip</th><th>host</th><th>角色</th><th>配置</th></tr></thead><tbody><tr><td>192.168.136.130</td><td>master.huany.com</td><td>master</td><td>CentOS 7.6</td></tr><tr><td>192.168.136.131</td><td>node1.huany.com</td><td>node1</td><td>CentOS 7.6</td></tr><tr><td>192.168.136.132</td><td>node2.huany.com</td><td>node2</td><td>CentOS 7.6</td></tr></tbody></table><h2 id="预先设置"><a href="#预先设置" class="headerlink" title="预先设置"></a>预先设置</h2><h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><ul><li>临时关闭，运行：<code>swapoff -a</code>，下次启动还有</li><li>到/etc/fstab中永久删除或关闭swap分区，使用 # 注释掉即可。</li></ul><h3 id="关闭和清理ufw"><a href="#关闭和清理ufw" class="headerlink" title="关闭和清理ufw"></a>关闭和清理ufw</h3><p>下面的命令将清除现有的所有防火墙规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -F</span><br></pre></td></tr></table></figure></p><h3 id="设置cgroups"><a href="#设置cgroups" class="headerlink" title="设置cgroups"></a>设置cgroups</h3><p>确保kubelet使用的cgroup driver与 Docker的一致。要么使用下面的方法更新 Docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>要么，设置kubernetes的cgroup driver，如：kubelet 的 –cgroup-driver 标志设置为与 Docker 一样(e.g. cgroupfs)。</p><h2 id="安装master节点"><a href="#安装master节点" class="headerlink" title="安装master节点"></a>安装master节点</h2><h3 id="修改内核配置"><a href="#修改内核配置" class="headerlink" title="修改内核配置"></a>修改内核配置</h3><ul><li><p>编辑 /etc/sysctl.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class="line">vm.swappiness = 0</span><br><span class="line">net.ipv4.neigh.default.gc_stale_time = 120</span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.arp_announce = 2</span><br><span class="line">net.ipv4.conf.lo.arp_announce = 2</span><br><span class="line">net.ipv4.conf.all.arp_announce = 2</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65023</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 400000</span><br><span class="line">net.ipv4.tcp_max_orphans = 60000</span><br><span class="line">net.ipv4.tcp_synack_retries = 3</span><br><span class="line">net.core.somaxconn = 10000</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">vm.swappiness = 0</span><br></pre></td></tr></table></figure></li><li><p>然后执行<code>sysctl -p</code>使修改生效</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -p</span><br></pre></td></tr></table></figure><h3 id="安装docker环境"><a href="#安装docker环境" class="headerlink" title="安装docker环境"></a>安装docker环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. SET UP THE REPOSITORY</span><br><span class="line"></span><br><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">2. INSTALL DOCKER ENGINE - COMMUNITY</span><br><span class="line"></span><br><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br><span class="line"></span><br><span class="line">安装18.06.0.ce-3版本</span><br><span class="line">sudo yum install docker-ce-18.06.0.ce-3.e17 docker-ce-cli-18.06.0.ce-3.el7 containerd.io</span><br><span class="line"></span><br><span class="line">3. RUN DOCKER</span><br><span class="line"></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="安装配置kubeadm"><a href="#安装配置kubeadm" class="headerlink" title="安装配置kubeadm"></a>安装配置kubeadm</h3><ul><li>配置阿里云的kubernetes镜像仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ yum makecache fast</span><br></pre></td></tr></table></figure><ul><li>安装kubeadm cni 等工具</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubernetes-cni kubelet kubeadm kubectl --skip-broken</span><br><span class="line">systemctl start kubelet.service</span><br><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure><p><strong>默认情况下这里的kubeadm kubectl kubelet默认安装的都是最新版本</strong></p><ul><li>配置CNI网络配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/cni/net.d/ -p</span><br><span class="line">$ cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;isGateway&quot;: true,</span><br><span class="line">    &quot;ipMasq&quot;: true,</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">            &#123;&quot;dst&quot;: &quot;0.0.0.0/0&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;loopback&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>配置kubeadm的配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: MasterConfiguration</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">#kubernetesVersion: &quot;stable&quot;</span><br><span class="line">kubernetesVersion: &quot;v1.15.3&quot;</span><br><span class="line">apiServerCertSANs: []</span><br><span class="line">#imageRepository: crproxy.trafficmanager.net:6000/google_containers</span><br><span class="line">#imageRepository: mirrorgooglecontainers</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">#imageRepository: &quot;&quot;</span><br><span class="line">controllerManagerExtraArgs:</span><br><span class="line">  horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;</span><br><span class="line">  horizontal-pod-autoscaler-sync-period: &quot;10s&quot;</span><br><span class="line">  node-monitor-grace-period: &quot;10s&quot;</span><br><span class="line">  feature-gates: &quot;AllAlpha=true&quot;</span><br><span class="line">  enable-dynamic-provisioning: &quot;true&quot;</span><br><span class="line">apiServerExtraArgs:</span><br><span class="line">  runtime-config: &quot;api/all=true&quot;</span><br><span class="line">  feature-gates: &quot;AllAlpha=true&quot;</span><br><span class="line">  #feature-gates: &quot;CoreDNS=true&quot;</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: &quot;10.244.0.0/16&quot;</span><br></pre></td></tr></table></figure><ul><li>拉取镜像</li></ul><p>脚本如下，如果需要其它的容器镜像可以照此增加即可，可以将版本号修改为自己需要的。</p><ul><li>注意：kubernetes每个版本依赖的版本不同，下面适用1.15.3。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==================================================&quot;</span><br><span class="line">echo &quot;Pulling Docker Images from registry.aliyuncs.com...&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-apiserver:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-apiserver:v1.15.3 k8s.gcr.io/kube-apiserver:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-controller-manager:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-controller-manager:v1.15.3 k8s.gcr.io/kube-controller-manager:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-scheduler:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.15.3 </span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-scheduler:v1.15.3 k8s.gcr.io/kube-scheduler:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-proxy:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3 k8s.gcr.io/kube-proxy:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;k8s-dns-kube-dns:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/coredns:1.3.1</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;etcd:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/etcd:3.3.10</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/etcd:3.3.10 k8s.gcr.io/etcd:3.3.10</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;pause:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br><span class="line"></span><br><span class="line">echo finished.</span><br><span class="line">echo &quot;you are so lucy&quot;</span><br></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --config kubeadm.yml --pod-network-cidr 10.244.0.0/16 -ignore-preflight-errors all</span><br></pre></td></tr></table></figure><p>执行成功后可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.136.130:6443 --token 32ozhx.8xneb9rzjukjc3au \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:00c3d4e272d3736c0edcfcdda38f255c9fb75118a7d640a3e98542829f4bb3ec</span><br></pre></td></tr></table></figure><ul><li>切换到普通用户执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><ul><li>查看节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME               STATUS   ROLES    AGE    VERSION</span><br><span class="line">master.huany.com   NotReady    master   2d3h   v1.15.3</span><br></pre></td></tr></table></figure><p>如果重启或者kubeadm reset 将清理掉cni配置，需要重新配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/cni/net.d/ -p</span><br><span class="line">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;isGateway&quot;: true,</span><br><span class="line">    &quot;ipMasq&quot;: true,</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">            &#123;&quot;dst&quot;: &quot;0.0.0.0/0&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;loopback&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>查看节点情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME               STATUS   ROLES    AGE    VERSION</span><br><span class="line">master.huany.com   Ready    master   2d3h   v1.15.3</span><br></pre></td></tr></table></figure><h2 id="在node节点上安装"><a href="#在node节点上安装" class="headerlink" title="在node节点上安装"></a>在node节点上安装</h2><p>同上，修改Linux内核，安装docker，安装kubeadm </p><ul><li><p>加入到集群中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.136.130:6443 --token 32ozhx.8xneb9rzjukjc3au \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:00c3d4e272d3736c0edcfcdda38f255c9fb75118a7d640a3e98542829f4bb3ec</span><br></pre></td></tr></table></figure></li><li><p>配置cni网络</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/cni/net.d/ -p</span><br><span class="line">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;isGateway&quot;: true,</span><br><span class="line">    &quot;ipMasq&quot;: true,</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">            &#123;&quot;dst&quot;: &quot;0.0.0.0/0&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;loopback&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="在master上查看节点情况："><a href="#在master上查看节点情况：" class="headerlink" title="在master上查看节点情况："></a>在master上查看节点情况：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[meichaofan@master keights]$ kubectl get nodes</span><br><span class="line">NAME               STATUS   ROLES    AGE    VERSION</span><br><span class="line">master.huany.com   Ready    master   2d3h   v1.15.3</span><br><span class="line">node1.huany.com    Ready    &lt;none&gt;   2d3h   v1.15.3</span><br><span class="line">node2.huany.com    Ready    &lt;none&gt;   2d3h   v1.15.3</span><br></pre></td></tr></table></figure><ul><li>在master附属flannel网络</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li>查看运行的服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[meichaofan@master keights]$ kubectl get pods -n kube-system</span><br><span class="line">NAME                                       READY   STATUS             RESTARTS   AGE</span><br><span class="line">coredns-5c98db65d4-mc25l                   1/1     Running            17         7h18m</span><br><span class="line">coredns-5c98db65d4-p7mtp                   1/1     Running            16         7h19m</span><br><span class="line">etcd-master.huany.com                      1/1     Running            2          2d3h</span><br><span class="line">kube-apiserver-master.huany.com            1/1     Running            2          2d3h</span><br><span class="line">kube-controller-manager-master.huany.com   0/1     CrashLoopBackOff   22         2d3h</span><br><span class="line">kube-flannel-ds-8l7jc                      1/1     Running            0          2d3h</span><br><span class="line">kube-flannel-ds-l952q                      1/1     Running            2          2d3h</span><br><span class="line">kube-flannel-ds-qmfgk                      1/1     Running            0          2d3h</span><br><span class="line">kube-proxy-b2r8g                           1/1     Running            3          2d3h</span><br><span class="line">kube-proxy-ccdr4                           1/1     Running            0          2d3h</span><br><span class="line">kube-proxy-klp8f                           1/1     Running            0          2d3h</span><br><span class="line">kube-scheduler-master.huany.com            1/1     Running            17         2d3</span><br></pre></td></tr></table></figure><h3 id="在node上拉取pause、kubeproxy容器，并转换tag"><a href="#在node上拉取pause、kubeproxy容器，并转换tag" class="headerlink" title="在node上拉取pause、kubeproxy容器，并转换tag"></a>在node上拉取pause、kubeproxy容器，并转换tag</h3><ul><li>node1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pause</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br><span class="line"></span><br><span class="line"># kube-proxy</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3 k8s.gcr.io/kube-proxy:v1.15.3</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下json解析神器 - jq</title>
      <link href="/2019/08/02/linux-json-format/"/>
      <url>/2019/08/02/linux-json-format/</url>
      
        <content type="html"><![CDATA[<h3 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">jq - commandline JSON processor [version 1.6]</span><br><span class="line"></span><br><span class="line">Usage:  jq [options] &lt;jq filter&gt; [file...]</span><br><span class="line">    jq [options] --args &lt;jq filter&gt; [strings...]</span><br><span class="line">    jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]</span><br><span class="line"></span><br><span class="line">jq is a tool for processing JSON inputs, applying the given filter to</span><br><span class="line">its JSON text inputs and producing the filter&apos;s results as JSON on</span><br><span class="line">standard output.</span><br><span class="line"></span><br><span class="line">The simplest filter is ., which copies jq&apos;s input to its output</span><br><span class="line">unmodified (except for formatting, but note that IEEE754 is used</span><br><span class="line">for number representation internally, with all that that implies).</span><br><span class="line"></span><br><span class="line">For more advanced filters see the jq(1) manpage (&quot;man jq&quot;)</span><br><span class="line">and/or https://stedolan.github.io/jq</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">    $ echo &apos;&#123;&quot;foo&quot;: 0&#125;&apos; | jq .</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;foo&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">For a listing of options, use jq --help.</span><br></pre></td></tr></table></figure><h3 id="jf"><a href="#jf" class="headerlink" title="jf"></a>jf</h3><p>改写成 shell 脚本执行模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">argsCount=$#</span><br><span class="line">if [ $argsCount -ne 1 ];then</span><br><span class="line">    echo &quot;Usage : jf json_str&quot;</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">jsonStr=$1</span><br><span class="line"></span><br><span class="line">echo $&#123;jsonStr&#125; | /usr/local/bin/jq .</span><br></pre></td></tr></table></figure></p><p>执行方法是：<code>jf &#39;{&quot;name&quot;:&quot;meichaofan&quot;}&#39;</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设定printf在终端输出字体的颜色</title>
      <link href="/2019/08/01/printf-console-color/"/>
      <url>/2019/08/01/printf-console-color/</url>
      
        <content type="html"><![CDATA[<p>终端字符的颜色是用转义序列进行控制，是文本模式下的系统显示功能，和具体的语言无关。转义序列是以 ESC 开头,可以用 \033 完成相同的工作（ESC 的 ASCII 码用十进制表示就是 27， = 用八进制表示的 33）。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\033[显示方式；前景色；背景色m</span><br></pre></td></tr></table></figure><p>1) 显示方式：0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、5（闪烁）、25（非闪烁）、7（反显）、27（非反显）</p><p>2) 前景色：30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋红）、36（青色）、37（白色）</p><p>3) 背景色：40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋红）、46（青色）、47（白色）</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1）默认颜色：\033[0m，也是关闭所有属性<br>　<br>2）绿色：\033[1;32;40m<br>　<br>3）红色：\033[1;31;40m</p><p>4）printf( “\033[1;31;40m 输出红色字符 \033[0m” )</p>]]></content>
      
      
      
        <tags>
            
            <tag> printf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clion建立多级工作目录</title>
      <link href="/2019/07/31/clion-create-multi-project/"/>
      <url>/2019/07/31/clion-create-multi-project/</url>
      
        <content type="html"><![CDATA[<p>之前对Clion不熟悉，每次写项目都在主目录下，导致一个主目录只能写一个main函数，下面学习如何在CLion建立多级工程目录</p><hr><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>在主工作目录下，有一个CMakeList.txt文件，内容如下：</p><p><img src="http://image.huany.top/hexo/c/clion-main-cmakelist.png" alt></p><p>其中，<code>ADD_SUBDIRECTORY(function-point)</code>，这个是代表包含子目录的意思。</p><p>对于子目录<code>function-point</code>,也必须有一个CMakeList.txt文件，指定子目录中的可执行文件。</p><p><img src="http://image.huany.top/hexo/c/clion-sub-makelist.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer - 3.1 - 数组中重复的数字</title>
      <link href="/2019/07/26/sword-finger-offer-3-1/"/>
      <url>/2019/07/26/sword-finger-offer-3-1/</url>
      
        <content type="html"><![CDATA[<p>在一个长度为n的数组里的所有数字都是0~n-1的范围内。数组中某些数字都是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3.</p><hr><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们注意到数组中的数字都在0~n-1的范围内。如果这个数组中没有重复的数字，那么当数字排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">n个数， 0~n-1之间，找出有重复的数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum1</span><span class="params">(numbers []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(numbers)</span><br><span class="line">    sort.Ints(numbers)</span><br><span class="line">    <span class="keyword">for</span> i &lt; length<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">//fmt.Printf("i: %d\n", i)</span></span><br><span class="line">        <span class="keyword">if</span> numbers[i] == numbers[i+<span class="number">1</span>] &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, numbers[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; length<span class="number">-1</span> &amp;&amp; numbers[i] == numbers[i+<span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.借助map(hashtable)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum2</span><span class="params">(numbers []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">    tmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(numbers); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> count, ok := tmp[numbers[i]]; ok &#123;</span><br><span class="line">            tmp[numbers[i]] = count + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[numbers[i]] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">1</span> &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//巧妙3：数组内自排序，时间复杂度0(n) , 空间复杂度是 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum3</span><span class="params">(numbers []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(numbers)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">        <span class="keyword">for</span> i != numbers[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == numbers[numbers[i]] &amp;&amp; i != numbers[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i]</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[i], numbers[numbers[i]] = numbers[numbers[i]], numbers[i]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ret1 := getDuplicateNum1(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ret1)</span><br><span class="line"></span><br><span class="line">    numbers = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ret2 := getDuplicateNum2(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ret2)</span><br><span class="line"></span><br><span class="line">    numbers = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ret3 := getDuplicateNum3(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ret3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go sync.Once</title>
      <link href="/2019/07/26/go-sync-Once/"/>
      <url>/2019/07/26/go-sync-Once/</url>
      
        <content type="html"><![CDATA[<p><code>sync.Once</code> 可以实现单例模式，确保<code>sync.Once.Do(f func())</code>只会被执行一次，可以初始化某个实例单例。</p><p>sync.Once表示只执行一次的函数。要做到这一点，就需要以下两点要求：</p><ul><li>计数器，统计函数执行的次数</li><li>线程安全，保障在多G情况下，函数仍然只执行一次，比如锁。即对计时器的修改是线性安全的。</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>下面是sync.Once源码，源码不长，但值得分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package sync</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync/atomic&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Once is an object that will perform exactly one action.</span><br><span class="line">type Once struct &#123;</span><br><span class="line">    m    Mutex</span><br><span class="line">    done uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (o *Once) Do(f func()) &#123;</span><br><span class="line">    if atomic.LoadUint32(&amp;o.done) == 1 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Slow-path.</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    defer o.m.Unlock()</span><br><span class="line">    if o.done == 0 &#123;</span><br><span class="line">        defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Once结构体证明了之前的猜想，果然有两个变量。</strong></p><p>Do方法相对简单，但是也是也可以学习的地方。</p><ul><li>1.原子操作判断o.done是否为1，若为1，表示f已经执行过，直接返回</li><li>2.加锁，保证互斥访问</li><li>3.若o.done为0，表示f未执行，执行f函数，对o.done原子赋值。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c 函数指针</title>
      <link href="/2019/07/26/c-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
      <url>/2019/07/26/c-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先，先不要把指向函数的指针认为太难了，它和普通的指针区别不是很大，只是定义形式上有所区别。</p><p>比如，对于一个指向整形的普通指针，定义形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br></pre></td></tr></table></figure><p>在定义中，指针变量的名称是p，符号<code>*</code>说明了p是一个指针，int说明这个指针指向的是整形变量。</p><p>那么，如果我们定义一个指向函数的指针，假设变量名称为p，比如它指向这样的一个函数，这个函数需要两个整数参数，其返回值也是整形参数，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)(int int);</span><br></pre></td></tr></table></figure><p>对于这个定义分解一下，其中，p是变量的名称，符号<code>*</code>说明了p是一个指针，由于这个指针指向的是一个函数，所以在定义中必须体现函数的输入输出参数信息，那么最前面的int指的就是函数的返回值为int类型，后面的(int,int)则定义了该函数需要两个整形的输入参数。另外，必须将<code>*</code>与<code>p</code>用括号写成<code>(*p)</code>的形式，否则，由于括号的优先级大于<code>*</code>的优先级，去掉括号的话就成为另外一种意思了。</p><p>这样对比着理解，指向函数的指针，似乎与普通指针区别也不是太大。</p><h3 id="指向函数指针例子"><a href="#指向函数指针例子" class="headerlink" title="指向函数指针例子"></a>指向函数指针例子</h3><p>下面通过一个例子演示指向函数的指针的使用方法。</p><p>该例子的功能是，对于一个输入的一维数组，定义三个函数findMax、findMin和getAvg，分别实现查找该数组的最大值、最小值及计算该数组的平均值，这三个函数的输入输出参数完全相同。定义一个fun函数，在该函数的参数中，需要一个指针变量作参数，这个指针能够指向上面的三个函数。在主程序中，调用fun函数，根据传入不同的p值实现对输入的一维数组作不同的处理功能。</p><p>下面先看下几部分的实现代码吧。</p><h4 id="findMax、findMin和getAvg代码实现"><a href="#findMax、findMin和getAvg代码实现" class="headerlink" title="findMax、findMin和getAvg代码实现"></a>findMax、findMin和getAvg代码实现</h4><p>这三个函数对一维数组x，分别作求最大值、最小值及平均值的处理，并将其结果返回。C语言代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">double findMax(double *x, int n) &#123;</span><br><span class="line">    double max = x[0];</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (max &lt; x[i]) max = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double findMin(double *x, int n) &#123;</span><br><span class="line">    double min = x[0];</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (min &gt; x[i]) min = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getAvg(double *x, int n) &#123;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个函数比较简单，函数原型完全一样，输入参数为一个指向double的指针x及x的元素个数n，输出参数也就是返回值是一个double型的数值。</p><h4 id="fun函数的代码实现"><a href="#fun函数的代码实现" class="headerlink" title="fun函数的代码实现"></a>fun函数的代码实现</h4><p>该函数输入参数为3个，前两个为指向double的指针x及x的元素个数n，第三个为一个指向函数的指针类型，这个指针能够指向上面的三个函数。C语言代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double fun(double *x, int n, double (*p)(double *, int)) &#123;</span><br><span class="line">    return p(x, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，在主程序中可以调用该函数，只要输入不同的p值，就可以对输入的一维数组作不同的处理运算。</p><h4 id="主程序测试代码"><a href="#主程序测试代码" class="headerlink" title="主程序测试代码"></a>主程序测试代码</h4><p>主程序测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void mian(void)</span><br><span class="line">&#123;</span><br><span class="line">    double x[5] = &#123;1.1, 3.4, 4.5, 1.3, 5.6&#125;;</span><br><span class="line">    fun(x, 5, findMax);</span><br><span class="line">    fun(x, 5, findMin);</span><br><span class="line">    fun(x, 5, getAvg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笨方法学C例子"><a href="#笨方法学C例子" class="headerlink" title="笨方法学C例子"></a>笨方法学C例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void die(const char *message) &#123;</span><br><span class="line">    if (errno) &#123;</span><br><span class="line">        perror(message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Error : %s\n&quot;, message);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef int (*compare_cb)(int a, int b);</span><br><span class="line"></span><br><span class="line">int *bubble_sort(int *numbers, int count, compare_cb cmp) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    int *target = malloc(count * sizeof(int));</span><br><span class="line"></span><br><span class="line">    if (!target) die(&quot;Memory error.&quot;);</span><br><span class="line"></span><br><span class="line">    memcpy(target, numbers, count * sizeof(int));</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        for (j = 0; j &lt; count - 1; ++j) &#123;</span><br><span class="line">            if (cmp(target[j], target[j + 1]) &gt; 0) &#123;</span><br><span class="line">                temp = target[j + 1];</span><br><span class="line">                target[j + 1] = target[j];</span><br><span class="line">                target[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sorted_order(int a, int b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int reverse_order(int a, int b) &#123;</span><br><span class="line">    return b - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int strange_order(int a, int b) &#123;</span><br><span class="line">    if (a == 0 || b == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_sorting(int *numbers, int count, compare_cb cmp) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int *sorted = bubble_sort(numbers, count, cmp);</span><br><span class="line">    if (!sorted) die(&quot;Failed to sort as request.&quot;);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, sorted[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    free(sorted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc &lt; 2) die(&quot;Usage: ext 4 3 1 5 6&quot;);</span><br><span class="line">    int count = argc - 1;</span><br><span class="line">    int i = 0;</span><br><span class="line">    char **inputs = argv + 1;</span><br><span class="line"></span><br><span class="line">    int *numbers = malloc(count * sizeof(int));</span><br><span class="line">    if (!numbers) die(&quot;Memory error.&quot;);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        numbers[i] = atoi(inputs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test_sorting(numbers, count, sorted_order);</span><br><span class="line">    test_sorting(numbers, count, reverse_order);</span><br><span class="line">    test_sorting(numbers, count, strange_order);</span><br><span class="line"></span><br><span class="line">    free(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go waitgroup</title>
      <link href="/2019/07/22/go-waitgroup/"/>
      <url>/2019/07/22/go-waitgroup/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>WaitGroup是Go应用开发过程中经常使用的并发控制技术。</p><p>WaitGroup，可理解为Wait-Groutine-Group，即等待一组goroutine结束。比如某个goroutine需要等待其他几个goroutine全部完成，那么使用WaitGroup可以轻松实现。</p><p>下面程序展示了一个goroutine等待另外两个goroutine结束的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(2) //设置计数器，数值即为goroutine的个数</span><br><span class="line">    go func() &#123;</span><br><span class="line">        //Do some work</span><br><span class="line">        time.Sleep(1*time.Second)</span><br><span class="line"></span><br><span class="line">        fmt.Println(&quot;Goroutine 1 finished!&quot;)</span><br><span class="line">        wg.Done() //goroutine执行结束后将计数器减1</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        //Do some work</span><br><span class="line">        time.Sleep(2*time.Second)</span><br><span class="line"></span><br><span class="line">        fmt.Println(&quot;Goroutine 2 finished!&quot;)</span><br><span class="line">        wg.Done() //goroutine执行结束后将计数器减1</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait() //主goroutine阻塞等待计数器变为0</span><br><span class="line">    fmt.Printf(&quot;All Goroutine finished!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说，上面程序中wg内部维护了一个计数器：</p><ul><li>1.启动goroutine前将计数器通过Add(2)将计数器设置为待启动的goroutine个数。</li><li>2.启动goroutine后，使用Wait()方法阻塞自己，等待计数器变为0。 </li><li>3.每个goroutine执行结束通过Done()方法将计数器减1。</li><li>4.计数器变为0后，阻塞的goroutine被唤醒。</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是Unix系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。</p><p>可简单理解为信号量为一个数值：</p><ul><li>当信号量&gt;0时，表示资源可用，获取信号量时系统自动将信号量减1；</li><li>当信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒；</li></ul><p>WaitGroup视线中也使用了信号量</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>源码包中<code>src/sync/waitgroup.go:WaitGroup</code>定义了其数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type WaitGroup struct &#123;</span><br><span class="line">    state1 [3]uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state1是个长度为3的数组，其中包含了state和一个信号量，而state实际上是两个计数器：</p><ul><li>counter：当前还未执行结束的goroutine计数器</li><li>waiter count：等待goroutine-group结束的goroutine数量，即有多少个等候者</li><li>semaphore：信号量</li></ul><p>考虑到字节是否对齐，三者出现的位置不同，为简单起见，依照字节已对齐情况下，三者在内存中的位置如下所示：</p><p><img src="http://image.huany.top/hexo/go/wg-01-layout.png" alt></p><p>WaitGroup对外提供了3个接口：</p><ul><li>Add(delta int): 将delta值加到counter中</li><li>Wait()： waiter递增1，并阻塞等待信号量semaphore</li><li>Done()： counter递减1，当counter=0时按照waiter数值释放相应次数信号量</li></ul><p>下面分别介绍这三个函数的实现细节。</p><h4 id="Add-delta-int"><a href="#Add-delta-int" class="headerlink" title="Add(delta int)"></a>Add(delta int)</h4><p>Add()做了两件事，一是把delta值累加到counter中，因为delta可以为负值，也就是说counter有可能变成0或负值，所以第二件事就是当counter值变为0时，跟据waiter数值释放等量的信号量，把等待的goroutine全部唤醒，如果counter变为负值，则panic.</p><p>Add()伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Add(delta int) &#123;</span><br><span class="line">    statep, semap := wg.state() //获取state和semaphore地址指针</span><br><span class="line"></span><br><span class="line">    state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32) //把delta左移32位累加到state，即累加到counter中</span><br><span class="line">    v := int32(state &gt;&gt; 32) //获取counter值</span><br><span class="line">    w := uint32(state)      //获取waiter值</span><br><span class="line"></span><br><span class="line">    if v &lt; 0 &#123;              //经过累加后counter值变为负值，panic</span><br><span class="line">        panic(&quot;sync: negative WaitGroup counter&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //经过累加后，此时，counter &gt;= 0</span><br><span class="line">    //如果counter为正，说明不需要释放信号量，直接退出</span><br><span class="line">    //如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出</span><br><span class="line">    if v &gt; 0 || w == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），</span><br><span class="line">    //先把counter置为0，再释放waiter个数的信号量</span><br><span class="line">    *statep = 0</span><br><span class="line">    for ; w != 0; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, false) //释放信号量，执行一次释放一个，唤醒一个等待者</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h4><p>Wait()方法也做了两件事，一是累加waiter, 二是阻塞等待信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Wait() &#123;</span><br><span class="line">    statep, semap := wg.state() //获取state和semaphore地址指针</span><br><span class="line">    for &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep) //获取state值</span><br><span class="line">        v := int32(state &gt;&gt; 32)            //获取counter值</span><br><span class="line">        w := uint32(state)                 //获取waiter值</span><br><span class="line">        if v == 0 &#123;                        //如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试</span><br><span class="line">        if atomic.CompareAndSwapUint64(statep, state, state+1) &#123;</span><br><span class="line">            runtime_Semacquire(semap) //累加成功后，等待信号量唤醒自己</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了CAS算法保证有多个goroutine同时执行Wait()时也能正确累加waiter。</p><h4 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h4><p>Done()只做一件事，即把counter减1，我们知道Add()可以接受负值，所以Done实际上只是调用了Add(-1)。</p><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Done() &#123;</span><br><span class="line">    wg.Add(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done()的执行逻辑就转到了Add()，实际上也正是最后一个完成的goroutine把等待者唤醒的。</p><h3 id="编程Tips"><a href="#编程Tips" class="headerlink" title="编程Tips"></a>编程Tips</h3><ul><li>Add() 操作必须早于Wait，否则会panic</li><li>Add()设置的值必须与实际等待的goroutine个数一致，否则会panic</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言 - 字符数组和字符串</title>
      <link href="/2019/07/20/c-char-array/"/>
      <url>/2019/07/20/c-char-array/</url>
      
        <content type="html"><![CDATA[<h4 id="字符数组定义"><a href="#字符数组定义" class="headerlink" title="字符数组定义"></a>字符数组定义</h4><p>用来存放字符的数组成为字符数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[20] = &#123;&apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;r&apos;, &apos;a&apos;,&apos;m&apos;&#125;; //给部分数组元素赋值</span><br><span class="line">char b[] = &#123;&apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;r&apos;, &apos;a&apos;,&apos;m&apos;&#125;; //对全体元素赋值可以省去长度</span><br></pre></td></tr></table></figure><p>字符数组实际上是一些列字符的集合，也就是字符串（string）。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。</p><h4 id="字符数组和字符串赋值"><a href="#字符数组和字符串赋值" class="headerlink" title="字符数组和字符串赋值"></a>字符数组和字符串赋值</h4><p>C语言规定，可以将字符串直接赋值给字符数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[30] = &#123;&quot;c.biancheng.net&quot;&#125;;</span><br><span class="line">char str[30] = &quot;c.biancheng.net&quot;; //这种形式更加简洁，实际开发中常用</span><br></pre></td></tr></table></figure><p>数组第0个元素为 ‘c’，第1个元素为 ‘.’，第2个元素为 ‘b’，后面的元素以此类推。也可以不指定数组长度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &#123;&quot;c.biancheng.net&quot;&#125;;</span><br><span class="line">char str[] = &quot;c.biancheng.net&quot;; //这种形式更加简洁，实际开发中常用</span><br></pre></td></tr></table></figure><p>在C语言中，字符串总是以<code>&#39;\0&#39;</code>作为串的结束符。上面的两个字符串，编译器已经在末尾自动添加了<code>&#39;\0&#39;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\0&apos;是ASCII码表中的第0个字符，用NUL表示，称为空字符。该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，它在C语言中仅作为字符串的结束标志。</span><br></pre></td></tr></table></figure><p><code>puts</code>和<code>printf</code>函数在输出字符串时会逐个扫描字符，直到遇见<code>\0</code>才结束输出。请看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    char str1[30] = &quot;http://c.biancheng.net&quot;;</span><br><span class="line">    char str2[] = &quot;C Language&quot;;</span><br><span class="line">    char str3[30] = &quot;You are a good\0 boy!&quot;;</span><br><span class="line">    printf(&quot;str1: %s\n&quot;, str1);</span><br><span class="line">    printf(&quot;str2: %s\n&quot;, str2);</span><br><span class="line">    printf(&quot;str3: %s\n&quot;, str3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1: http://c.biancheng.net</span><br><span class="line">str2: C Language</span><br><span class="line">str3: You are a good</span><br></pre></td></tr></table></figure><p>str1 和 str2 很好理解，编译器会在字符串最后自动添加 ‘\0’，并且数组足够大，所以会输出整个字符串。对于 str3，由于字符串中间存在 ‘\0’，printf() 扫描到这里就认为字符串结束了，所以不会输出后面的内容。</p><h4 id="字符数组和字符串区别"><a href="#字符数组和字符串区别" class="headerlink" title="字符数组和字符串区别"></a>字符数组和字符串区别</h4><p>需要注意的是，用字符串给字符数组赋值时由于要添加结束符 ‘\0’，数组的长度要比字符串的长度（字符串长度不包括 ‘\0’）大1。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &quot;C program&quot;;</span><br></pre></td></tr></table></figure><p>该数组在内存中实际存放情况为：</p><p><img src="http://image.huany.top/hexo/c/sfdsgfsge.png" alt></p><p><strong>字符串长度为 9，数组长度为 10。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php array</title>
      <link href="/2019/07/13/php-array/"/>
      <url>/2019/07/13/php-array/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>PHP数组的低层实现为散列表（HashTable,也称作：哈希表）。除了我们熟悉的PHP用户空间的Array类型之外，内核中也随处用到了散列表，比如函数，类，常量，已include文件的索引表，全局符号表等都用HashTable存储。</p><p>散列表是根据关键码值(Key value)而直接进行访问的数据结构，它的key - value之间存在一个映射函数，可以根据key通过映射函数直接索引到对应的value值，它不以关键字的比较为基本操作，<strong>采用直接寻址技术</strong>（就是说，它是直接通过key映射到内存地址上去的），从而加快查找速度，在理想情况下，无须任何比较就可以找到待查关键字，查找的期望时间为O(1)。</p><h3 id="1-数组结构"><a href="#1-数组结构" class="headerlink" title="1.数组结构"></a>1.数组结构</h3><p>存放记录的数组称作散列表，这个数组用来存储value。而value具体在数组中的存储位置，由映射函数根据key计算确定，映射函数可以采用取模的方式，key可以通过一些譬如“times 33”的算法得到一个整形值，然后与数组总大小取模得到在散列表中的存储位置。这是一个普通散列表的实现，PHP散列表的实现整体也是这个思路。<br>下面是PHP中HashTable的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bucket：散列表中存储的元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">    zval              val; <span class="comment">//存储的具体value，这里嵌入了一个zval，而不是一个指针</span></span><br><span class="line">    zend_ulong        h;   <span class="comment">//key根据times 33计算得到的哈希值，或者是数值索引编号</span></span><br><span class="line">    zend_string      *key; <span class="comment">//存储元素的key</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashTable结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                    zend_uchar    flags,</span><br><span class="line">                    zend_uchar    nApplyCount,</span><br><span class="line">                    zend_uchar    nIteratorsCount,</span><br><span class="line">                    zend_uchar    reserve)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableMask; <span class="comment">//哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize)</span></span><br><span class="line">    Bucket           *arData;     <span class="comment">//存储元素数组，指向第一个Bucket</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumUsed;   <span class="comment">//已用Bucket数</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumOfElements; <span class="comment">//哈希表有效元素数</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableSize;     <span class="comment">//哈希表总大小，为2的n次方</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement; <span class="comment">//下一个可用的数值索引,如:arr[] = 1;arr["a"] = 2;arr[] = 3;  则nNextFreeElement = 2;</span></span><br><span class="line">    <span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HashTable有两个非常相近的值：nNumUsed、nNumOfElements，nNumOfElements表示哈希表已有的元素数，nNumUsed表示已用的桶数？<strong>这两个值有什么不一样吗？</strong><br>实际上，它们有不同的含义，当将一个元素从哈希表删除时，并不会将对应的Bucket移除，而是将Bucket存储的zval修改为IS_UNDEF ， 只有扩容时发现nNumOfElements与nNumUsed相差达到一定数量（这个数量是 ht-&gt;nNumUsed - ht-&gt;nNumOfElements &gt; (ht-&gt;nNumOfElements &gt;&gt; 5)）时才会将已删除的元素全部移除，重新构建哈希表。所以nNumUsed &gt;= nNumOfElements</p><p>HashTable中另外一个非常重要的值arData，这个值指向存储元素数组的第一个Bucket,插入元素时按照顺序 <strong>依次插</strong>入 数组。 PHP数组的有序性正是通过arData保证的，这是第一个与普通散列表实现不同的地方。</p><p>既然arData并不是按key映射的散列表，那么映射函数是如何将key与arData中的value建立映射关系的呢？</p><p>实际上这个散列表也在arData中，比较特别的是散列表在ht-&gt;arData内存之前，分配内存时这个散列表与Bucket数组一起分配，arData向后移动到了Bucket数组的起始位置，并不是申请内存的起始位置，这样散列表可以由arData指针向前移动访问到，即arData[-1]、arData[-2]、arData[-3]……散列表的结构是uint32_t，它保存的是value在Bucket数组中的位置。</p><p>所以，整体来看HashTable主要依赖arData实现元素的存储、索引。插入一个元素时先将元素按先后顺序插入Bucket数组，位置是idx，再根据key的哈希值映射到散列表中的某个位置nIndex，将idx存入这个位置；查找时先在散列表中映射到nIndex，得到value在Bucket数组的位置idx，再从Bucket数组中取出元素。（&hearts;）</p><p>比如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$arr[<span class="string">"a"</span>] = <span class="number">1</span>;</span><br><span class="line">$arr[<span class="string">"b"</span>] = <span class="number">2</span>;</span><br><span class="line">$arr[<span class="string">"c"</span>] = <span class="number">3</span>;</span><br><span class="line">$arr[<span class="string">"d"</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>($arr[<span class="string">"c"</span>]);</span><br></pre></td></tr></table></figure></p><p>对应的HashTable如下图所示。<br><img src="http://image.huany.top/hexo/php/php-array-hashtable.png" alt></p><h3 id="2-映射函数"><a href="#2-映射函数" class="headerlink" title="2.映射函数"></a>2.映射函数</h3><p>映射函数是散列表的关键部分，它将key与value建立映射关系，一般映射函数可以将key的hash值与Bucket数组取模得到，即 key-&gt;h % ht-&gt;nTableSize,但是PHP并不是这么做的：</p><blockquote><p>nIndex = key-&gt;h | ht-&gt;nTableMask;</p></blockquote><p>显然位运算比取模运算更快。<br>nTableMask为nTableSize的负数，即: nTableMask = -nTableSize。因为nTableSize等于2^n，所以ntableMask二进制右侧全部为0，也就保证了nIndex落在数组索引的范围之内(|nIndex|&lt;=nTableSize).</p><pre><code>11111111 11111111 11111111 11111000   -811111111 11111111 11111111 11110000   -1611111111 11111111 11111111 11100000   -3211111111 11111111 11111111 11000000   -6411111111 11111111 11111111 10000000   -128</code></pre><h3 id="3-哈希碰撞"><a href="#3-哈希碰撞" class="headerlink" title="3.哈希碰撞"></a>3.哈希碰撞</h3><p>哈希碰撞是指不同的key可能计算得到相同的哈希值(数值索引的哈希值直接就是数值本身)，但是这些值又需要插入同一个散列表。一般解决方法是将Bucket串成链表，查找时遍历链表比较key。</p><p>PHP的实现也是如此，只是将链表的指针指向转化为了数值指向，即：指向冲突元素的指针并没有直接存在Bucket中，而是保存到了value的zval中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>     var_flags;</span><br><span class="line">        <span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain（哈希冲突链） */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当出现冲突时将原value的位置保存到新value的zval.u2.next中，然后将新插入的value的位置更新到散列表，也就是后面冲突的value始终插入header。所以查找过程类似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zend_ulong h = zend_string_hash_val(key);</span><br><span class="line"><span class="keyword">uint32_t</span> idx = ht-&gt;arHash[h &amp; ht-&gt;nTableMask];</span><br><span class="line"><span class="keyword">while</span> (idx != INVALID_IDX) &#123;</span><br><span class="line">    Bucket *b = &amp;ht-&gt;arData[idx];</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;h == h &amp;&amp; zend_string_equals(b-&gt;key, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    idx = Z_NEXT(b-&gt;val); <span class="comment">//移到下一个冲突的value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><h3 id="4-插入、查找、删除"><a href="#4-插入、查找、删除" class="headerlink" title="4.插入、查找、删除"></a>4.插入、查找、删除</h3><p>这几个基本操作比较简单，不再赘述，定位到元素所在Bucket位置后的操作类似单链表的插入、删除、查找。</p><h3 id="5-扩容"><a href="#5-扩容" class="headerlink" title="5.扩容"></a>5.扩容</h3><p>散列表可存储的value数是固定的，当空间不够用时就要进行扩容了。</p><p>PHP散列表的大小为2^n，插入时如果容量不够则首先检查已删除元素所占比例，如果达到阈值(ht-&gt;nNumUsed - ht-&gt;nNumOfElements &gt; (ht-&gt;nNumOfElements &gt;&gt; 5)，则将已删除元素移除，重建索引，如果未到阈值则进行扩容操作，扩大为当前大小的2倍，将当前Bucket数组复制到新的空间，然后重建索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zend_hash.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> ZEND_FASTCALL <span class="title">zend_hash_do_resize</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; <span class="number">5</span>)) &#123;</span><br><span class="line">        <span class="comment">//只有到一定阈值才进行rehash操作</span></span><br><span class="line">        zend_hash_rehash(ht); <span class="comment">//重建索引数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123;</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">void</span> *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class="line">        <span class="comment">//扩大为2倍，加法要比乘法快，小的优化点无处不在...</span></span><br><span class="line">        <span class="keyword">uint32_t</span> nSize = ht-&gt;nTableSize + ht-&gt;nTableSize;</span><br><span class="line">        Bucket *old_buckets = ht-&gt;arData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新分配arData空间，大小为:(sizeof(Bucket) + sizeof(uint32_t)) * nSize</span></span><br><span class="line">        new_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ...);</span><br><span class="line">        ht-&gt;nTableSize = nSize;</span><br><span class="line">        ht-&gt;nTableMask = -ht-&gt;nTableSize;</span><br><span class="line">        <span class="comment">//将arData指针偏移到Bucket数组起始位置</span></span><br><span class="line">        HT_SET_DATA_ADDR(ht, new_data);</span><br><span class="line">        <span class="comment">//将旧的Bucket数组拷到新空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(ht-&gt;arData, old_buckets, <span class="keyword">sizeof</span>(Bucket) * ht-&gt;nNumUsed);</span><br><span class="line">        <span class="comment">//释放旧空间</span></span><br><span class="line">        pefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重建索引数组：散列表</span></span><br><span class="line">        zend_hash_rehash(ht);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_SET_DATA_ADDR(ht, ptr) do &#123; \</span></span><br><span class="line">        (ht)-&gt;arData = (Bucket*)(((<span class="keyword">char</span>*)(ptr)) + HT_HASH_SIZE((ht)-&gt;nTableMask)); \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="6-重建散列表"><a href="#6-重建散列表" class="headerlink" title="6.重建散列表"></a>6.重建散列表</h3><p>当删除元素达到一定数量或扩容后都需要重建散列表，因为value在Bucket位置移动了或哈希数组nTableSize变化了导致key与value的映射关系改变，重建过程实际就是遍历Bucket数组中的value，然后重新计算映射值更新到散列表，除了更新散列表之外，这里还有一个重要的处理：移除已删除的value，开始的时候我们说过，删除value时只是将value的type设置为IS_UNDEF，并没有实际从Bucket数组中删除，如果这些value一直存在那么将浪费很多空间，所以这里会把它们移除，操作的方式也比较简单：将后面未删除的value依次前移，具体过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zend_hash.c</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_rehash</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bucket *p;</span><br><span class="line">    <span class="keyword">uint32_t</span> nIndex, i;</span><br><span class="line">    ...</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    p = ht-&gt;arData;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;nNumUsed == ht-&gt;nNumOfElements) &#123; <span class="comment">//没有已删除的直接遍历Bucket数组重新插入索引数组即可</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            nIndex = p-&gt;h | ht-&gt;nTableMask;</span><br><span class="line">            Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">            HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (++i &lt; ht-&gt;nNumUsed);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (UNEXPECTED(Z_TYPE(p-&gt;val) == IS_UNDEF)) &#123;</span><br><span class="line">                <span class="comment">//有已删除元素则将后面的value依次前移，压实Bucket数组</span></span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">while</span> (++i &lt; ht-&gt;nNumUsed) &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                    <span class="keyword">if</span> (EXPECTED(Z_TYPE_INFO(p-&gt;val) != IS_UNDEF)) &#123;</span><br><span class="line">                        ZVAL_COPY_VALUE(&amp;q-&gt;val, &amp;p-&gt;val);</span><br><span class="line">                        q-&gt;h = p-&gt;h;</span><br><span class="line">                        nIndex = q-&gt;h | ht-&gt;nTableMask;</span><br><span class="line">                        q-&gt;key = p-&gt;key;</span><br><span class="line">                        Z_NEXT(q-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">                        HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j);</span><br><span class="line">                        <span class="keyword">if</span> (UNEXPECTED(ht-&gt;nInternalPointer == i)) &#123;</span><br><span class="line">                            ht-&gt;nInternalPointer = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                ht-&gt;nNumUsed = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            nIndex = p-&gt;h | ht-&gt;nTableMask;</span><br><span class="line">            Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">            HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i &lt; ht-&gt;nNumUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php7新特性</title>
      <link href="/2019/07/10/php7-new-feature/"/>
      <url>/2019/07/10/php7-new-feature/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP7新特性"><a href="#PHP7新特性" class="headerlink" title="PHP7新特性"></a>PHP7新特性</h3><h4 id="太空船操作符-lt-gt"><a href="#太空船操作符-lt-gt" class="headerlink" title="太空船操作符 &lt;=&gt;"></a>太空船操作符 &lt;=&gt;</h4><ul><li>太空船操作符用于比较两个表达式</li></ul><p>例如，当$a小于、等于或大于$b时，它分别返回-1、0或1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1&lt;=&gt;1; //0</span><br><span class="line">echo 1&lt;=&gt;2; //-1</span><br><span class="line">echo 2&lt;=&gt;1; //1</span><br></pre></td></tr></table></figure><h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><ul><li>declare(strict_types=1); // strict_types=1表示开启严格模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare(strict_types=1); //必须在脚本开始出声明</span><br><span class="line">function add(int ...$arg): int</span><br><span class="line">&#123;</span><br><span class="line">    return array_sum($arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="null合并操作符"><a href="#null合并操作符" class="headerlink" title="null合并操作符"></a>null合并操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$page = isset($_GET(&apos;page&apos;)) ? $_GET[&apos;page&apos;]:0；</span><br><span class="line">改成</span><br><span class="line">$page = $_GET(&apos;page&apos;) ?? 0;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，这里是<code>isset($val)</code></p><h4 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h4><ul><li>不可以修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;ANIMAL&apos;, [&apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;]);</span><br></pre></td></tr></table></figure><h4 id="NameSpace批量导入"><a href="#NameSpace批量导入" class="headerlink" title="NameSpace批量导入"></a>NameSpace批量导入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Space\&#123;ClassA,ClassB,ClassC as C&#125;;</span><br></pre></td></tr></table></figure><h4 id="try…catch-捕获-error"><a href="#try…catch-捕获-error" class="headerlink" title="try…catch 捕获 error"></a>try…catch 捕获 error</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    undefinedfunc();</span><br><span class="line">&#125; catch (Error $e) &#123;</span><br><span class="line">    var_dump($e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也可以</span><br><span class="line">set_exception_handler(</span><br><span class="line">    function ($e) &#123;</span><br><span class="line">        var_dump($e);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">undefinedfunc();</span><br></pre></td></tr></table></figure><p>PHP7返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Error#1 (8) &#123;</span><br><span class="line">  protected $message =&gt;</span><br><span class="line">  string(42) &quot;Call to undefined function undefinedfunc()&quot;</span><br><span class="line">  private $string =&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  protected $code =&gt;</span><br><span class="line">  int(0)</span><br><span class="line">  protected $file =&gt;</span><br><span class="line">  string(41) &quot;/home/meichaofan/PHP7/capter02/inedx2.php&quot;</span><br><span class="line">  protected $line =&gt;</span><br><span class="line">  int(4)</span><br><span class="line">  private $trace =&gt;</span><br><span class="line">  array(0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  private $previous =&gt;</span><br><span class="line">  NULL</span><br><span class="line">  public $xdebug_message =&gt;</span><br><span class="line">  string(199) &quot;</span><br><span class="line">Error: Call to undefined function undefinedfunc() in /home/meichaofan/PHP7/capter02/inedx2.php on line 4</span><br><span class="line"></span><br><span class="line">Call Stack:</span><br><span class="line">    0.0001     387432   1. &#123;main&#125;() /home/meichaofan/PHP7/capter02/inedx2.php:0</span><br><span class="line">&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Closure-call"><a href="#Closure-call" class="headerlink" title="Closure::call"></a>Closure::call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    private $num = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$f = function () &#123;</span><br><span class="line">    return $this-&gt;num + 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">echo $f-&gt;call(new Test());</span><br></pre></td></tr></table></figure><h4 id="intdiv-函数"><a href="#intdiv-函数" class="headerlink" title="intdiv 函数"></a>intdiv 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo intdiv(10,3); //整除 == 3</span><br></pre></td></tr></table></figure><h4 id="list-的方括号写法"><a href="#list-的方括号写法" class="headerlink" title="list 的方括号写法"></a>list 的方括号写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">之前</span><br><span class="line">$arr = [1,2,3];</span><br><span class="line">list($a,$b,$c) = $arr;</span><br><span class="line">现在可以这么写</span><br><span class="line">$arr = [1,2,3];</span><br><span class="line">[$a,$b,$c] = $arr;</span><br></pre></td></tr></table></figure><h4 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树(AST)"></a>抽象语法树(AST)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($a)[&apos;b&apos;] = 1;</span><br><span class="line">PHP5 会报错</span><br><span class="line">PHP7 因为AST，不会报错</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go mutex</title>
      <link href="/2019/07/07/go-mutex/"/>
      <url>/2019/07/07/go-mutex/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。</p><p>Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几种状态。另外，我们也想探究一下Mutex重复解锁引起panic的原因。</p><h3 id="2-Mutex数据结构"><a href="#2-Mutex数据结构" class="headerlink" title="2.Mutex数据结构"></a>2.Mutex数据结构</h3><h4 id="2-1-Mutex结构体"><a href="#2-1-Mutex结构体" class="headerlink" title="2.1 Mutex结构体"></a>2.1 Mutex结构体</h4><p>源码包<code>src/sync/mutex.go:Mutex</code>定义了互斥锁的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Mutex struct&#123;</span><br><span class="line">    state int32</span><br><span class="line">    sema  uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Mutex.state 表示互斥锁的状态，比如是否被锁定等。</li><li>Mutex.sema 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。</li></ul><p>我们看到Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。</p><p>下图展示Mutex的内存布局：</p><p><img src="http://image.huany.top/hexo/go/mutex-01-structure.png" alt></p><ul><li>Locked：表示该Mutex是否已被锁定，0：没有锁定 1：已经锁定</li><li>Woken：表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中</li><li>Starving：表示该Mutex是否处于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程阻塞超过了1ms。</li><li>Waiter：表示阻塞等待锁的协程个数，协程解锁根据次值来判断是否需要释放信号量。</li></ul><p>协程之间抢锁实际上是抢给Locked赋值的权利，能给Locked域置1，就说明抢锁成功。抢不到的话就阻塞等待Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。</p><p>Woken和Starving主要用于控制协程间的抢锁过程。</p><h4 id="2-2-Mutex方法"><a href="#2-2-Mutex方法" class="headerlink" title="2.2 Mutex方法"></a>2.2 Mutex方法</h4><p>Mutex对外提供两个方法。</p><ul><li>Lock()：加锁方法</li><li>UnLock()：解锁方法</li></ul><p>下面我们分析一下锁和解锁的过程，加锁分成功和失败两种情况，成功的话直接获取锁，失败后当前协程被阻塞，同样，解锁时跟据是否有阻塞协程也有两种处理。</p><h3 id="3-加解锁过程"><a href="#3-加解锁过程" class="headerlink" title="3.加解锁过程"></a>3.加解锁过程</h3><h4 id="3-1-简单加锁"><a href="#3-1-简单加锁" class="headerlink" title="3.1 简单加锁"></a>3.1 简单加锁</h4><p>假设当前只有一个协程在加锁，没有其它协程干扰，那么过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-02-lock_without_block.png" alt></p><p>加锁过程会去判断Locked标志位是否为0，如果是0则把Locked位置1，代表加锁成功。从上图可见，加锁成功后，只有Locked位置1，其他状态位没有变化。</p><h4 id="3-2-加锁被阻塞"><a href="#3-2-加锁被阻塞" class="headerlink" title="3.2 加锁被阻塞"></a>3.2 加锁被阻塞</h4><p>假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-03-lock_with_block.png" alt></p><p>从上图可看到，当协程B对一个已被占用的锁再次加锁时，Waiter计数器增加了1，此时协程B将被阻塞，直到Locked值变为0后才会被唤醒。</p><h4 id="3-3-简单解锁"><a href="#3-3-简单解锁" class="headerlink" title="3.3 简单解锁"></a>3.3 简单解锁</h4><p>假定解锁时，没有其它协程阻塞，此时解锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-04-unlock_without_waiter.png" alt></p><p>由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把Locked位置为0即可，不需要释放信号量。</p><h4 id="3-4-解锁并唤醒协程"><a href="#3-4-解锁并唤醒协程" class="headerlink" title="3.4 解锁并唤醒协程"></a>3.4 解锁并唤醒协程</h4><p>假定解锁时，有1个或多个协程阻塞，此时解锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-05-unlock_with_waiter.png" alt></p><p>协程A解锁过程分为两个步骤，一个把Locked位置0，而是查看Waiter&gt;0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程B把Locked位置1，于是协程B获得锁。</p><h3 id="4-自旋过程"><a href="#4-自旋过程" class="headerlink" title="4. 自旋过程"></a>4. 自旋过程</h3><p>加锁时，如果当前Locked位为1，说明该锁当前由其它协程所持有，尝试加锁的协议并不是马上转入阻塞，而是会持续探测Locked位是否变为0，这个过程即为自旋过程。</p><p>自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次被阻塞。</p><p>自旋的好处是，当加锁失败时不必立即转入阻塞。有一定机会获取到锁，这样可以避免协程的切换。</p><h4 id="4-1-什么是自旋"><a href="#4-1-什么是自旋" class="headerlink" title="4.1 什么是自旋"></a>4.1 什么是自旋</h4><p>自旋对应于CPU的”PAUSE”指令，CPU对该指令什么都不做，相当于CPU空转，对程序而言相当于sleep了一小段时间，时间非常短，当前实现是30个时钟周期。</p><p>自旋过程中会持续探测Locked是否变为0，连续两次探测间隔就是执行这些PAUSE指令，它不同于sleep，不需要将协程转为睡眠状态。</p><h4 id="4-1-自旋条件"><a href="#4-1-自旋条件" class="headerlink" title="4.1 自旋条件"></a>4.1 自旋条件</h4><p>加锁时程序会自动判断是否可以自旋，无限制的自旋将会给CPU带来巨大压力，所以判断是否可以自旋就很重要了。</p><p>自旋必须满足以下所有条件</p><ul><li>自旋次数要足够小，通常为4，即自旋最多4次</li><li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁</li><li>协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋</li><li>协程调度机制中的可运行队列必须为空，否则会延迟协程调度</li></ul><p>可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。</p><h4 id="4-2-自旋的优势"><a href="#4-2-自旋的优势" class="headerlink" title="4.2 自旋的优势"></a>4.2 自旋的优势</h4><p>自旋的优势是更充分的利用CPU，尽量避免协程切换。因为当前申请加锁的协程拥有CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。</p><h4 id="4-3-自旋的问题"><a href="#4-3-自旋的问题" class="headerlink" title="4.3 自旋的问题"></a>4.3 自旋的问题</h4><p>如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态。</p><p>为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。</p><h3 id="5-Mutex-模式"><a href="#5-Mutex-模式" class="headerlink" title="5.Ｍutex 模式"></a>5.Ｍutex 模式</h3><p>前面分析加锁和解锁过程中只关注了Waiter和Locked位的变化，现在我们看一下Starving位的作用。</p><p>每个Mutex都有两个模式，称为Normal和Starving。下面分别说明这两个模式。</p><h4 id="4-1-normal模式"><a href="#4-1-normal模式" class="headerlink" title="4.1 normal模式"></a>4.1 normal模式</h4><p>默认情况下，Mutex的模式为normal。</p><p>该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。</p><h4 id="4-2-starvation模式"><a href="#4-2-starvation模式" class="headerlink" title="4.2 starvation模式"></a>4.2 starvation模式</h4><p>自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞。</p><p>处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1。</p><h3 id="5-Woken状态"><a href="#5-Woken状态" class="headerlink" title="5. Woken状态"></a>5. Woken状态</h3><p>Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。</p><h3 id="6-为什么重复解锁要panic"><a href="#6-为什么重复解锁要panic" class="headerlink" title="6.为什么重复解锁要panic"></a>6.为什么重复解锁要panic</h3><p>可能你会想，为什么Go不能实现得更健壮些，多次执行Unlock()也不要panic？</p><p>仔细想想Unlock的逻辑就可以理解，这实际上很难做到。Unlock过程分为将Locked置为0，然后判断Waiter值，如果值&gt;0，则释放信号量。</p><p>如果多次Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。</p><h3 id="7-编程Tips"><a href="#7-编程Tips" class="headerlink" title="7. 编程Tips"></a>7. 编程Tips</h3><h4 id="7-1-使用defer避免死锁"><a href="#7-1-使用defer避免死锁" class="headerlink" title="7.1 使用defer避免死锁"></a>7.1 使用defer避免死锁</h4><p>加锁后立即使用defer对其解锁，可以有效的避免死锁。</p><h5 id="7-2-加锁和解锁应该成对出现"><a href="#7-2-加锁和解锁应该成对出现" class="headerlink" title="7.2 加锁和解锁应该成对出现"></a>7.2 加锁和解锁应该成对出现</h5><p>加锁和解锁最好出现在同一个层次的代码块中，比如一个函数。</p><p>重复解锁会引起panic，应该避免这种操作的可能性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go range</title>
      <link href="/2019/07/06/go-range/"/>
      <url>/2019/07/06/go-range/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map和channel等，实际使用频率非常高。</p><p>探索range的实现机制是很有意思的事情，这可能会改变你使用range的习惯。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一：切片遍历"><a href="#2-1-题目一：切片遍历" class="headerlink" title="2.1 题目一：切片遍历"></a>2.1 题目一：切片遍历</h4><p>下面函数通过遍历切片，打印切片的下标和元素值，请问性能上有没有可优化的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func RangeSlice(slice []int)&#123;</span><br><span class="line">    for index,value := range slice &#123;</span><br><span class="line">        _,_ := index,value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>函数中使用<code>for-range</code>对切片进行遍历，获取切片的下标和元素值，这里忽略函数的实际意义。</p><p>参考答案：</p><p>遍历过程中，每次迭代会对index和value进行赋值，如果数据量大或者value类型为string时，对value的赋值操作可能是多余的，可以在for-range中忽略value值，使用slice[index]引用value值。</p><h4 id="2-2-题目二：Map遍历"><a href="#2-2-题目二：Map遍历" class="headerlink" title="2.2 题目二：Map遍历"></a>2.2 题目二：Map遍历</h4><p>下面函数通过遍历Map，打印Map的key和value，请问性能上有没有可以优化的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func RangeMap(myMap map[int]string) &#123;</span><br><span class="line">    for key, _ := range myMap &#123;</span><br><span class="line">        _, _ = key, myMap[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>函数中使用for-range对map进行遍历，获取map的key值，并根据key值获取value值，这里忽略函数的实际意义。</p><p>参考答案：</p><p>函数中for-range语句中值获取key值，然后根据key值获取value值，虽然看似减少了一次赋值，但通过key值查找value值的性能可能高于赋值消耗。能否优化取决于map所存储数据结构特征、结合实际情况进行判断。</p><h4 id="2-3-题目三：动态遍历"><a href="#2-3-题目三：动态遍历" class="headerlink" title="2.3 题目三：动态遍历"></a>2.3 题目三：动态遍历</h4><p>请问如下程序是否能正常结束？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    v := []int&#123;1, 2, 3&#125;</span><br><span class="line">    for i:= range v &#123;</span><br><span class="line">        v = append(v, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>main()函数中定义一个切片v，通过range遍历v，遍历过程中不断向v中添加新的元素。</p><p>参考答案：</p><p>能够正常结束。循环内改变切片的长度，不影响循环次数，循环次效在循环开始前就已经确定了。</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><p>对于for-range语句的实现，可以从编译器源码中找到答案。</p><p>编译器源码 <code>gofrontend/go/statements.cc/For_range_statement::do_lower()</code> 方法中有如下注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Arrange to do a loop appropriate for the type.  We will produce</span><br><span class="line">//   for INIT ; COND ; POST &#123;</span><br><span class="line">//           ITER_INIT</span><br><span class="line">//           INDEX = INDEX_TEMP</span><br><span class="line">//           VALUE = VALUE_TEMP // If there is a value</span><br><span class="line">//           original statements</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>可见range实际上是一个C风格的循环结构。range支持数组、数组指针、切片、map和channel类型，对于不同类型有些细节上的差异。</p><h4 id="3-1-range-for-slice"><a href="#3-1-range-for-slice" class="headerlink" title="3.1 range for slice"></a>3.1 range for slice</h4><p>下面的注释解释了遍历slice的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   for_temp := range</span><br><span class="line">//   len_temp := len(for_temp)</span><br><span class="line">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">//           value_temp = for_temp[index_temp]</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>遍历slice前会先获以slice的长度len_temp作为循环次数，循环体中，每次循环会先获取元素值，如果for-range中接收index和value的话，则会对index和value进行一次赋值。</p><p>由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是没办法遍历到的。</p><p>另外，数组与数组指针的遍历过程与slice基本一致，不再赘述。</p><h4 id="3-2-range-for-map"><a href="#3-2-range-for-map" class="headerlink" title="3.2 range for map"></a>3.2 range for map</h4><p>下面的注释解释了遍历map的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   var hiter map_iteration_struct</span><br><span class="line">//   for mapiterinit(type, range, &amp;hiter); hiter.key != nil; mapiternext(&amp;hiter) &#123;</span><br><span class="line">//           index_temp = *hiter.key</span><br><span class="line">//           value_temp = *hiter.val</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>遍历map时没有指定循环次数，循环体与遍历slice类似。由于map底层实现与slice不同，map底层使用hash表实现，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。</p><h4 id="3-3-range-for-channel"><a href="#3-3-range-for-channel" class="headerlink" title="3.3 range for channel"></a>3.3 range for channel</h4><p>遍历channel是最特殊的，这是由channel的实现机制决定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   for &#123;</span><br><span class="line">//           index_temp, ok_temp = &lt;-range</span><br><span class="line">//           if !ok_temp &#123;</span><br><span class="line">//                   break</span><br><span class="line">//           &#125;</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>channel遍历是依次从channel中读取数据,读取前是不知道里面有多少个元素的。如果channel中没有元素，则会阻塞等待，如果channel已被关闭，则会解除阻塞并退出循环。</p><p><strong>注</strong></p><ul><li>上述注释中index_temp实际上描述是有误的，应该为value_temp，因为index对于channel是没有意义的。</li><li>使用for-range遍历channel时只能获取一个返回值。</li></ul><h3 id="4-编程Tips"><a href="#4-编程Tips" class="headerlink" title="4.编程Tips"></a>4.编程Tips</h3><ul><li>遍历过程中可以视情况放弃接收index或value，可以在一定程度上提升性能</li><li>遍历channel时，避免channel没有数据，可能会阻塞</li><li>尽量避免遍历过程中修改原数据</li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>for-range的实现实际上是C风格的for循环</li><li>使用index、value接收range返回值会发生一次数据拷贝。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go select</title>
      <link href="/2019/07/06/go-select/"/>
      <url>/2019/07/06/go-select/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready（即是否可读或可写），使用起来非常方便。</p><p>本章试图根据源码总结其实现原理，从而发现一些使用误区或解释一些不太常见的现象。</p><h3 id="2-热身环节"><a href="#2-热身环节" class="headerlink" title="2. 热身环节"></a>2. 热身环节</h3><h4 id="2-1-题目1"><a href="#2-1-题目1" class="headerlink" title="2.1 题目1"></a>2.1 题目1</h4><p>下面的程序输出是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        chan1 &lt;- 1</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        chan2 &lt;- 1</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，分别向两个channel中写入一个数据就进入睡眠。select语句两个case分别检测chan1和chan2是否可读，如果都不可读则执行default语句。</p><p>参考答案：</p><p>select中各个case执行顺序是随机的，如果某个case中的channel已经ready，则执行相应的语句并退出select流程，如果所有case中的channel都未ready，则执行default中语句然后退出select流程。另外，由于启动的协程和select语句并不能保证执行顺序，所以也有可能select执行时协程还未向channel中写入数据，所以select直接执行default语句并退出，所以，以下三种输出都有可能：</p><p>可能的输出一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chan1 ready.</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><p>可能的输出二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chan2 ready</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><p>可能的输出三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><h4 id="2-2-题目2"><a href="#2-2-题目2" class="headerlink" title="2.2 题目2"></a>2.2 题目2</h4><p>下面的程序执行到select时会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    writeFlag := false</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if writeFlag &#123;</span><br><span class="line">                chan1 &lt;- 1</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if writeFlag &#123;</span><br><span class="line">                chan2 &lt;- 1</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程会判断一个bool类型的变量，writeFlag来决定是否要向channel中写入数据，由于writeFlag永远是false，所以实际上协程什么也没做。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</p><p>参考答案：</p><p>select会按照随机的顺序检测各case语句中cahnnel是否ready，如果某个case中的channel已经ready则执行相应的case语句然后退出select流程，如果所有的channel都未ready且没有default的话，则会阻塞等待各个channel。所以上述程序会一直阻塞。</p><h4 id="2-3-题目3"><a href="#2-3-题目3" class="headerlink" title="2.3 题目3"></a>2.3 题目3</h4><p>下面程序有什么问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        close(chan1)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        close(chan2)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程分别关闭两个channel。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</p><p>参考答案：</p><p>select会按照随机的顺序检测各case语句中channel是否ready，考虑到已关闭的channel也是可读的，所以上述程序中select不会阻塞，具体执行哪个case语句具是随机的。</p><h4 id="2-4-题目4"><a href="#2-4-题目4" class="headerlink" title="2.4 题目4"></a>2.4 题目4</h4><p>下面程序会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中只有一个空的select语句。</p><p>参考答案：</p><p>对于空的select语句，程序会阻塞，准确的说是当前协程会被阻塞，同时Golang自带死锁检测机制，当发现当前协程再也没有机会被唤醒时，则会panic。所以上述程序会panic。</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3.实现原理"></a>3.实现原理</h3><p>Golang实现了select时，定义了一个数据结构表示每个case语句（含default，default实际上是一种特殊的case），select执行过程类比成一个函数，函数输入case数组，输出选中的case，然后程序流转到选中的case块。</p><h4 id="3-1-case数据结构"><a href="#3-1-case数据结构" class="headerlink" title="3.1 case数据结构"></a>3.1 case数据结构</h4><p>源码包<code>src/runtime/select.go:scase</code>定义了表示case语句的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type scase struct &#123;</span><br><span class="line">    c       *hchan      // chan</span><br><span class="line">    kind    uint16</span><br><span class="line">    elem    unsafe.Pointer  // data element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scase.c 为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。scase.kind表示该case的类型，分为读channel、写channel和default，三种类型分别由常量定义：</p><ul><li>caseRecv：case语句中尝试读取scase.c中的数据；</li><li>caseSend：case语句中尝试向scase.c中写入数据</li><li>caseDefault：default语句</li></ul><p>scase.elem 表示缓冲区地址，根据scase.kind的不同，有不同用途：</p><ul><li>scase.kind == caseRecv：scase.elem表示读出channel的数据存放地址；</li><li>scase.kind == caseSend：scase.elem表示将要写入channel的数据存放地址；</li></ul><h4 id="3-2-select实现逻辑"><a href="#3-2-select实现逻辑" class="headerlink" title="3.2 select实现逻辑"></a>3.2 select实现逻辑</h4><p>源码包<code>src/runtime/select.go:selectgo()</code>定义了select选择case的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase,order0 *uint16,ncases int)(int,bool)</span><br></pre></td></tr></table></figure><p>函数参数：</p><ul><li>cas为scase数组的首地址，selectgo()就是从这些scase中找出一个返回。</li><li>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder<ul><li>pollorder：每次selectgo执行都会把scase序列打乱，以达到随机检测case的目的。</li><li>lockorder：所有case语句中channel序列，以达到去重防止对channel加锁时重复加锁的目的</li></ul></li><li>ncase表示scase数据的长度</li></ul><p>函数返回值：</p><ul><li>1.int：选中case的编号，这个case编号和代码一致</li><li>2.bool：是否成功从channel中读取了数据，如果选中的case是从channel中读数据，则该返回值表示是否读取成功。</li></ul><p>selectgo实现的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase,order *uint16,ncase int) (int,bool)&#123;</span><br><span class="line">    //1.锁定scase语句中所有的channel</span><br><span class="line">    //2.按照随机顺序检测scase中的channel是否ready</span><br><span class="line">    //  2.1 如果case可读，则读取channel中数据，解锁所有的channel,然后返回(case index,true)</span><br><span class="line">    //  2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index,false)</span><br><span class="line">    //  2.3 所有case都未ready,则解锁所有的channel，然后返回(default index,false)</span><br><span class="line">    //3.所有case都未ready，且没有default语句</span><br><span class="line">    //  3.1将当前协程加入到所有channel的等待队列</span><br><span class="line">    //  3.2当前协程转入阻塞，等待被唤醒</span><br><span class="line">    //4.唤醒后返回channel对应case index</span><br><span class="line">    //  4.1 如果是读操作，解锁所有的channel，然后返回(case index,true)</span><br><span class="line">    //  4.2 如果是写操作，解锁所有的channel，然后返回(case index,false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别说明：</p><p>对于读channel的case来说，如<code>case elem,ok := &lt;- chan1：</code>，如果channel有可能被其它协程关闭的情况下，一定要检测是否读取成功，因为close的channel也有可能返回，此时ok==false。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>select语句中除default外，每个case操作一个channel，要么读要么写</li><li>select语句中除default外，各case执行顺序是随机的</li><li>select语句中如果没有default语句，则会阻塞等待任一case</li><li>select语句中读操作要判断是否成功读取，关闭的channel也可以读取。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go defer</title>
      <link href="/2019/07/06/go-defer/"/>
      <url>/2019/07/06/go-defer/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前，再把延迟函数取出并执行。</p><p>为了方便描述，我们把创建defer的函数称为主函数，defer语句后面的函数称为延迟函数。</p><p>延迟函数可能有输入参数，这些参数可能来源于定义defer的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为，这些场景下，如果不了解defer的规则很容易出错。</p><p>其实官方说明的defer的三个原则很清楚，本节试图汇总defer的使用场景并做简单说明。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><p>下面函数输出结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncParameter() &#123;</span><br><span class="line">    var aInt = 1</span><br><span class="line"></span><br><span class="line">    defer fmt.Println(aInt)</span><br><span class="line"></span><br><span class="line">    aInt = 2</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目说明：</p><p>函数deferFuncParameter()定义一个整型变量并初始化为1，然后使用defer语句打印出变量值，最后修改变量值为2.</p><p>参考答案：</p><p>输出1。延迟函数fmt.Println(aInt)的参数在defer语句出现时就已经确定了，所以无论后面如何修改aInt变量都不会影响延迟函数。</p><h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><p>下面程序输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printArray(array *[3]int) &#123;</span><br><span class="line">    for i := range array &#123;</span><br><span class="line">        fmt.Println(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func deferFuncParameter() &#123;</span><br><span class="line">    var aArray = [3]int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">    defer printArray(&amp;aArray)</span><br><span class="line"></span><br><span class="line">    aArray[0] = 10</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    deferFuncParameter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>函数deferFuncParameter()定义一个数组，通过defer延迟函数printArray()的调用，最后修改数组第一个元素。printArray()函数接受数组的指针并把数组全部打印出来。</p><p>参考答案：</p><p>输出10、2、3三个值。延迟函数printArray()的参数在defer语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在return语句之前，所以对数组的最终修改值会被打印出来。</p><h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>下面函数输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncReturn() (result int) &#123;</span><br><span class="line">    i := 1</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       result++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>函数拥有一个具名返回值result，函数内部声明一个变量i，defer指定一个延迟函数，最后返回变量i。延迟函数中递增result。</p><p>参考答案：</p><p>函数输出2。函数的return语句并不是原子的，实际执行分为设置返回值–&gt;ret，defer语句实际执行在返回前，即拥有defer的函数返回过程是：设置返回值–&gt;执行defer–&gt;ret。所以return语句先把result设置为i的值，即1，defer语句中又把result递增1，所以最终返回2。</p><h3 id="3-defer规则"><a href="#3-defer规则" class="headerlink" title="3. defer规则"></a>3. defer规则</h3><p>Golang官方博客里总结了defer的行为规则，只有三条，我们围绕这三条进行说明。</p><h4 id="3-1-规则一：延迟函数的参数在defer语句出现时就已经确定下来了"><a href="#3-1-规则一：延迟函数的参数在defer语句出现时就已经确定下来了" class="headerlink" title="3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了"></a>3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了</h4><p>官方给出了一个例子，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a()&#123;</span><br><span class="line">    i := 0 </span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer语句中的fmt.Println()参数i值在defer出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响fmt.Println()函数的执行，仍然打印”0”。</p><p>注意：对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，defer后面的语句对变量的修改可能会影响延迟函数。</p><h4 id="3-2-规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行"><a href="#3-2-规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行" class="headerlink" title="3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行"></a>3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行</h4><p>这个规则很好理解，定义defer类似于入栈操作，执行defer类似于出栈操作。</p><p>设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再跟据A资源申请B资源，跟据B资源申请C资源，即申请顺序是:A–&gt;B–&gt;C，释放时往往又要反向进行。这就是把deffer设计成LIFO(Last In First Out)的原因。</p><p>每申请到一个用完需要释放的资源时，立即定义一个defer来释放资源是个很好的习惯。</p><h4 id="3-3-规则三：延迟函数可能操作主函数的具名返回值"><a href="#3-3-规则三：延迟函数可能操作主函数的具名返回值" class="headerlink" title="3.3 规则三：延迟函数可能操作主函数的具名返回值"></a>3.3 规则三：延迟函数可能操作主函数的具名返回值</h4><p>定义defer的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer所作用的函数，即延迟函数可能会影响到返回值。</p><p>若要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回的就足够了。</p><h6 id="3-1-函数返回过程"><a href="#3-1-函数返回过程" class="headerlink" title="3.1 函数返回过程"></a>3.1 函数返回过程</h6><p>有一个事实必须要了解，关键字<code>return</code>不是一个原子操作，实际上<code>return</code>只代理汇编指令<code>ret</code>，即将跳转程序执行。比如语句<code>return i</code>，实际上分两步进行，即将<code>i</code>存入栈中作为返回值，然后执行跳转，而defer的执行时机正是<strong>跳转前</strong>，所示说defer执行时还是有机会操作返回值的。</p><p>举个实际的例子进行说明这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncReturn() (result int) &#123;</span><br><span class="line">    i := 1</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       result++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的return语句可以拆分成下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = i</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>而延迟函数的执行正是在return之前，即加入defer后执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = i</span><br><span class="line">result ++ </span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>所以上面函数实际返回i++值。</p><p>关于主函数有不同的返回方式，但返回机制就如上机介绍所说，只要把return语句拆开都可以很好的理解，下面分别举例说明</p><h5 id="3-1-1-主函数拥有匿名返回值，返回字面值"><a href="#3-1-1-主函数拥有匿名返回值，返回字面值" class="headerlink" title="3.1.1 主函数拥有匿名返回值，返回字面值"></a>3.1.1 主函数拥有匿名返回值，返回字面值</h5><p>一个主函数拥有一个匿名的返回值，返回时使用字面值，比如返回”1”、”2”、”Hello”这样的值，这种情况下defer语句是无法操作返回值的。</p><p>一个返回字面值的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() int &#123;</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的return语句，直接把1写入栈中作为返回值，延迟函数无法操作该返回值，所以就无法影响返回值。</p><h5 id="3-3-2-主函数拥有匿名返回值，返回变量"><a href="#3-3-2-主函数拥有匿名返回值，返回变量" class="headerlink" title="3.3.2 主函数拥有匿名返回值，返回变量"></a>3.3.2 主函数拥有匿名返回值，返回变量</h5><p>一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下defer语句可以引用到返回值，但不会改变返回值。</p><p>一个返回本地变量的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() int &#123;</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，返回一个局部变量，同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量为”anony”，上面的返回语句可以拆分成以下过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anony = i</span><br><span class="line">i++</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>由于i是整型，会将值拷贝给anony，所以defer语句中修改i值，对函数返回值不造成影响。</p><h5 id="3-3-3-主函数拥有具名返回值"><a href="#3-3-3-主函数拥有具名返回值" class="headerlink" title="3.3.3 主函数拥有具名返回值"></a>3.3.3 主函数拥有具名返回值</h5><p>主函声明语句中带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。如果defer语句操作该返回值，可能会改变返回结果。</p><p>一个影响函返回值的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func foo() (ret int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        ret++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数拆解出来，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = 0</span><br><span class="line">ret++</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>函数真正返回前，在defer中对返回值做了+1操作，所以函数最终返回1。</p><h3 id="4-defer实现原理"><a href="#4-defer实现原理" class="headerlink" title="4. defer实现原理"></a>4. defer实现原理</h3><p>本节我们尝试了解一些defer的实现机制。</p><h4 id="4-1-defer数据结构"><a href="#4-1-defer数据结构" class="headerlink" title="4.1 defer数据结构"></a>4.1 defer数据结构</h4><p>源码包<code>src/src/runtime/runtime2.go:_defer</code>定义了defer的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type _defer struct &#123;</span><br><span class="line">    sp      uintptr   //函数栈指针</span><br><span class="line">    pc      uintptr   //程序计数器</span><br><span class="line">    fn      *funcval  //函数地址</span><br><span class="line">    link    *_defer   //指向自身结构的指针，用于链接多个defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道defer后面一定要接一个函数的，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等等。</p><p>与函数不同的一点是它含有一个指针，可用于指向另一个defer，每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer插入到单链表表头，每次执行defer时就从单链表表头取出一个defer执行。</p><p>下图展示多个defer被链接的过程：</p><p><img src="http://image.huany.top/hexo/go/defer.jpg" alt></p><p>从上图可以看到，新声明的defer总是添加到链表头部。函数返回前执行defer则是从链表首部依次取出执行。</p><p>一个goroutine可能连续调用多个函数，defer添加过程跟上述流程一致，进入函数时添加defer，离开函数时取出defer，所有即便调用多个函数，也总能保证defer是按照LIFO方式执行 的。</p><h4 id="4-2-defer的创建和执行"><a href="#4-2-defer的创建和执行" class="headerlink" title="4.2 defer的创建和执行"></a>4.2 defer的创建和执行</h4><p>源码包<code>src/runtine/panic.go</code>定义了两个方法分别用于创建defer和执行defer。</p><ul><li>deferproc()：在声明defer处调用，其将defer函数存入goroutine的链表中；</li><li>deferreturn()：在return指令，准确的将是在ret指令前调用，其将defer从goroutine链表中取出并执行。</li></ul><p>可以简单的这么理解，在编译阶段，声明defer出插入了deferproc()，在函数return前插入了deferreturn()。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>defer定义的延迟函数参数在defer语句出来时就已经确定下来了</li><li>defer定义顺序与执行顺序相反</li><li>return不是原子操作，执行过程是：保存返回值（若有） –&gt; 执行defer –&gt; 执行return跳转</li><li>申请资源后立即使用defer关闭资源是好习惯</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go iota</title>
      <link href="/2019/07/06/go-iota/"/>
      <url>/2019/07/06/go-iota/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>我们知道iota常用于const表达式中，我们还知道其值是从零开始的，const声明块中每增加一行iota值自增1。</p><p>使用iota可以简化常量定义，但其规则必须要牢牢掌握，否则在我们阅读别人源码时可能会造成误解或障碍。本节我们尝试全面的总结其使用场景，另外花一小部分时间看一下其实现原理，从原理上把握可以更深刻的记忆这些规则。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><p>下面常量定义源于GO源码，下面每个常量的值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Priority int</span><br><span class="line">const (</span><br><span class="line">    LOG_EMERG Priority = iota</span><br><span class="line">    LOG_ALERT</span><br><span class="line">    LOG_CRIT</span><br><span class="line">    LOG_ERR</span><br><span class="line">    LOG_WARNING</span><br><span class="line">    LOG_NOTICE</span><br><span class="line">    LOG_INFO</span><br><span class="line">    LOG_DEBUG</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>上面代码源于日志模块，定义了一组代表日志级别的常量，常量类型为Priority，实际为int类型。</p><p>参考答案：</p><p>iota初始值为0，也即LOG_EMERG值为0，下面每个常量递增1。</p><h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><p>下面代码取自Go源码，请问每个常量值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    mutexLocked = 1 &lt;&lt; iota // mutex is locked</span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexStarving</span><br><span class="line">    mutexWaiterShift = iota</span><br><span class="line">    starvationThresholdNs = 1e6</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>以上代码取自Go互斥锁Mutex的实现，用于指示各种状态位的地址偏移。</p><p>参考答案：</p><p>mutexLocked == 1；mutexWoken == 2；mutexStarving == 4；mutexWaiterShift == 3；starvationThresholdNs == 1000000。</p><h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>请问每个常量值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1</span><br><span class="line">    bit1, mask1</span><br><span class="line">    _, _</span><br><span class="line">    bit3, mask3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>以上代码取自Go官方文档。</p><p>参考答案：</p><p>bit0 == 1， mask0 == 0， bit1 == 2， mask1 == 1， bit3 == 8， mask3 == 7</p><h3 id="3-规则"><a href="#3-规则" class="headerlink" title="3.规则"></a>3.规则</h3><p>很多书上或博客描述的规则是这样的： </p><ol><li>iota在const关键字出现时被重置为0 </li><li>const声明块中每新增一行iota值自增1</li></ol><p>我曾经也这么理解，看过编译器代码后发现，其实规则只有一条：</p><ul><li><strong>iota代表了const声明块的行索引（下标从0开始）</strong></li></ul><p>这样理解更贴近编译器实现逻辑，也更准确。除此之外，const声明还有个特点，即第一个常量必须指定一个表达式，后续的常量如果没有表达式，则继承上面的表达式。</p><p>下面再来根据这个规则看下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1   //const声明第0行，即iota==0</span><br><span class="line">    bit1, mask1                            //const声明第1行，即iota==1, 表达式继承上面的语句</span><br><span class="line">    _, _                                   //const声明第2行，即iota==2</span><br><span class="line">    bit3, mask3                            //const声明第3行，即iota==3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>第0行的表达式展开即bit0, mask0 = 1 &lt;&lt; 0, 1&lt;&lt;0 - 1，所以bit0 == 1，mask0 == 0；</li><li>第1行没有指定表达式继承第一行，即bit1, mask1 = 1 &lt;&lt; 1, 1&lt;&lt;1 - 1，所以bit1 == 2，mask1 == 1；</li><li>第2行没有定义常量</li><li>第3行没有指定表达式继承第一行，即bit3, mask3 = 1 &lt;&lt; 3, 1&lt;&lt;3 - 1，所以bit0 == 8，mask0 == 7；</li></ul><h3 id="4-编译原理"><a href="#4-编译原理" class="headerlink" title="4.编译原理"></a>4.编译原理</h3><p>const块中每一行在GO中使用spec数据结构描述，spec声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// A ValueSpec node represents a constant or variable declaration</span><br><span class="line">// (ConstSpec or VarSpec production).</span><br><span class="line">//</span><br><span class="line">ValueSpec struct &#123;</span><br><span class="line">    Doc     *CommentGroup // associated documentation; or nil</span><br><span class="line">    Names   []*Ident      // value names (len(Names) &gt; 0)</span><br><span class="line">    Type    Expr          // value type; or nil</span><br><span class="line">    Values  []Expr        // initial values; or nil</span><br><span class="line">    Comment *CommentGroup // line comments; or nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只关注ValueSpec.Names， 这个切片中保存了一行中定义的常量，如果一行定义N个常量，那么ValueSpec.Names切片长度即为N。</p><p>const块实际上是spec类型的切片，用于表示const中的多行。</p><p>所以编译期间构造常量时的伪算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for iota, spec := range ValueSpecs &#123;</span><br><span class="line">    for i, name := range spec.Names &#123;</span><br><span class="line">        obj := NewConst(name, iota...) //此处将iota传入，用于构造常量</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go channel 低层源码剖析</title>
      <link href="/2019/07/06/go-channel/"/>
      <url>/2019/07/06/go-channel/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>channel是Golang在语言层面提供的goroutine间通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统方法来解决。</p><p>本章，从源码角度分析channel的实现机制，实际上这部分源码非常简单易读。</p><h3 id="chan数据结构"><a href="#chan数据结构" class="headerlink" title="chan数据结构"></a>chan数据结构</h3><p><code>src/runtine/chan.go:hchan</code>定义了channel的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">    qcount   uint           // 当前队列中剩余元素个数</span><br><span class="line">    dataqsiz uint           // 环形队列长度，即可以存放的元素个数</span><br><span class="line">    buf      unsafe.Pointer // 环形队列指针</span><br><span class="line">    elemsize uint16         // 每个元素的大小</span><br><span class="line">    closed   uint32         // 标识关闭状态</span><br><span class="line">    elemtype *_type // 元素类型</span><br><span class="line">    sendx    uint   // 队列下标，指示元素写入时存放到队列中的位置</span><br><span class="line">    recvx    uint   // 队列下标，指示元素从队列的该位置读出</span><br><span class="line">    recvq    waitq  // 等待读消息的goroutine队列</span><br><span class="line">    sendq    waitq  // 等待写消息的goroutine队列</span><br><span class="line">    lock mutex      // 互斥锁，chan不允许并发读写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。</p><h5 id="2-1-环形队列"><a href="#2-1-环形队列" class="headerlink" title="2.1 环形队列"></a>2.1 环形队列</h5><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。</p><p>下图展示了一个可缓存6个元素的channel示意图：</p><p><img src="http://image.huany.top/hexo/go/chan-01-circle_queue.png" alt></p><ul><li>datasiz 指示了队列长度为6，即可缓存6个元素；</li><li>buf指向队列的内存，队列中还剩余两个元素；</li><li>qcount表示队列中还有两个元素；</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><h4 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h4><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前的goroutine会被阻塞。</p><p>被阻塞的goroutine会被挂在channel的等待队列中；</p><ul><li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li><li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li></ul><p>下图展示了一个没有缓冲区的channel，有几个gouroutine阻塞等待读数据：</p><p><img src="http://image.huany.top/hexo/go/chan-02-wait_queue.png" alt></p><p><strong>注意</strong>，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p><h4 id="2-3-类型信息"><a href="#2-3-类型信息" class="headerlink" title="2.3 类型信息"></a>2.3 类型信息</h4><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p><ul><li>elemtype代表类型，用于数据传递过程中的赋值；</li><li>elemsize代表类型大小，用于在buf中定位元素位置。</li></ul><h4 id="2-4-锁"><a href="#2-4-锁" class="headerlink" title="2.4 锁"></a>2.4 锁</h4><p>一个channel同时仅允许被一个goroutine读写</p><h3 id="3-channel读写"><a href="#3-channel读写" class="headerlink" title="3.channel读写"></a>3.channel读写</h3><h4 id="3-1-创建channel"><a href="#3-1-创建channel" class="headerlink" title="3.1 创建channel"></a>3.1 创建channel</h4><p>创建channel的过程实际上是初始化hchan结构，其中类型信息和缓冲区长度由<code>make</code>语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p><p>创建channel的伪代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan&#123;</span><br><span class="line">    var c *hchan</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = malloc(元素类型*size)</span><br><span class="line">    c.elemsize = 元素类型大小</span><br><span class="line">    c.elemtype = 元素类型</span><br><span class="line">    c.dataqsiz size</span><br><span class="line">    </span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-向channel写数据"><a href="#3-2-向channel写数据" class="headerlink" title="3.2 向channel写数据"></a>3.2 向channel写数据</h4><p>向一个channel中写数据简单过程如下：</p><ul><li>1.如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后把该G唤醒，结束发送过程</li><li>2.如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程；</li><li>3.如果缓冲区没有空余位置，将待发数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒。.</li></ul><p>简单流程图如下：</p><p><img src="http://image.huany.top/hexo/go/chan-03-send_data.png" alt></p><h4 id="3-3-从channel读数据"><a href="#3-3-从channel读数据" class="headerlink" title="3.3 从channel读数据"></a>3.3 从channel读数据</h4><p>从一个channel读数据简单过程如下：</p><ul><li>1.如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li><li>2.如果等待发送队列sendq不为空，缓冲区已满，从缓冲区首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li><li>3.如果缓冲区有数据，则从缓冲区取出数据，结束读取过程；</li><li>4.将当前的goroutine加入recvq，进入睡眠，等待被写goroutine唤醒。</li></ul><p><img src="http://image.huany.top/hexo/go/chan-04-recieve_data.png" alt></p><h4 id="3-4-关闭channel"><a href="#3-4-关闭channel" class="headerlink" title="3.4 关闭channel"></a>3.4 关闭channel</h4><p>关闭channel时会把revq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但是这些G会panic。</p><p>除此之外，panic出现的常见场景还有：</p><ul><li>1.关闭值为nil的channel</li><li>2.关闭已经被关闭的channel</li><li>3.向已经关闭的channel写数据</li></ul><h3 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4.常见用法"></a>4.常见用法</h3><h4 id="4-1-单向channel"><a href="#4-1-单向channel" class="headerlink" title="4.1 单向channel"></a>4.1 单向channel</h4><p>顾名思义，单向channel指只能用于发送或接收数据，实际上也没有单向channel。</p><p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p><ul><li>func readChan(chanName &lt;-chan int)：通过形参限定函数内部只能从channel中读取数据</li><li>func writeChan(chanName chan&lt;- int)：通过形参限定函数内部只能往channel中写数据</li></ul><p>一个简单的示例程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func readChan(chanName &lt;-chan int) &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeChan(chanName chan&lt;- int) &#123;</span><br><span class="line">    chanName &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var mychan = make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来读。</p><h4 id="4-2-select"><a href="#4-2-select" class="headerlink" title="4.2 select"></a>4.2 select</h4><p>使用select可以监控多个channel，比如监控多个channel，当其中某一个channel有数据的话，就从中读出数据。</p><p>一个简单的示例程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func addNumberToChan(chanName chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        chanName &lt;- 1</span><br><span class="line">        time.Sleep(1 * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var chan1 = make(chan int, 10)</span><br><span class="line">    var chan2 = make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    go addNumberToChan(chan1)</span><br><span class="line">    go addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(&quot;Get element from chan1: %d\n&quot;, e)</span><br><span class="line">        case e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(&quot;Get element from chan2: %d\n&quot;, e)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Printf(&quot;No element in chan1 and chan2.\n&quot;)</span><br><span class="line">            time.Sleep(1 * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go run main.go</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element in chan1 and chan2.</span><br></pre></td></tr></table></figure><p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的。</p><p>通过这个示例想说的是：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p><h4 id="4-3-range"><a href="#4-3-range" class="headerlink" title="4.3 range"></a>4.3 range</h4><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func chanRange(chanName chan int) &#123;</span><br><span class="line">    for e := range chanName &#123;</span><br><span class="line">        fmt.Printf(&quot;Get element from chan: %d\n&quot;, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go map原理剖析</title>
      <link href="/2019/07/01/go-map/"/>
      <url>/2019/07/01/go-map/</url>
      
        <content type="html"><![CDATA[<h3 id="1-map数据结构"><a href="#1-map数据结构" class="headerlink" title="1. map数据结构"></a>1. map数据结构</h3><p>golang的map的使用了哈希表作为低层实现，一个哈希表里可以有多个哈希表节点，也即<strong>bucket</strong>，而每个bucket保存了map中的一个或一组键值对。</p><p>map的数据结构由<code>runtime/map.go:hmap</code>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">    count   int //当前保存的元素个数</span><br><span class="line">    ...</span><br><span class="line">    B       uint8   //指示bucket数组的大小</span><br><span class="line">    ...</span><br><span class="line">    buckets unsafe.Pointer  //bucket数组指针，数组的大小为2^B</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示一个拥有4个bucket的map:</p><p><img src="http://image.huany.top/hexo/go/map-01-struct.png" alt></p><p>本例中，<code>hmap.B=2</code>，而hmap.buckets的长度是2^B为4，元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p><p><code>bucket</code>很多时候会翻译成桶，所谓的<code>哈希桶</code>实际上就是bucket。</p><h3 id="2-bucket数据结构"><a href="#2-bucket数据结构" class="headerlink" title="2. bucket数据结构"></a>2. bucket数据结构</h3><p>bucket数据结构由<code>runtime/map.go:bmap定义</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [8]uint8 //存储哈希值的高8位</span><br><span class="line">    data    byte[1]  //key value数据:key/key/key/.../value/value/value...</span><br><span class="line">    overflow *bmap   //溢出bucket的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket可以存储8个键值对。</p><ul><li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li><li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li><li>overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li></ul><p><strong>注意</strong>：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p><p>下图展示bucket存放8个key-value对：</p><p><img src="http://image.huany.top/hexo/go/map-02-struct_sketch.png" alt></p><h3 id="3-哈希冲突"><a href="#3-哈希冲突" class="headerlink" title="3. 哈希冲突"></a>3. 哈希冲突</h3><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。 由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p><p>下图展示产生冲突后的map：</p><p><img src="http://image.huany.top/hexo/go/map-03-struct_sketch.png" alt></p><p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。</p><h3 id="4-负载因子"><a href="#4-负载因子" class="headerlink" title="4. 负载因子"></a>4. 负载因子</h3><p>负载因子是衡量一个哈希表冲突情况，公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 键数量 / bucket数量</span><br></pre></td></tr></table></figure><p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p><p>哈希表需要将负载因子控制在一个合适的大小，超过阈值需要进行refresh，也即键值对重新组织：</p><ul><li>哈希因子过小，说明空间利用率低</li><li>哈希因子过大，说明冲突严重，存取效率低</li></ul><p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p><h3 id="5-渐进式扩容"><a href="#5-渐进式扩容" class="headerlink" title="5. 渐进式扩容"></a>5. 渐进式扩容</h3><h4 id="5-1-扩容的前提条件"><a href="#5-1-扩容的前提条件" class="headerlink" title="5.1 扩容的前提条件"></a>5.1 扩容的前提条件</h4><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。 触发扩容的条件有二个： 1. 负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。 2. overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</p><h4 id="5-2-增量扩容"><a href="#5-2-增量扩容" class="headerlink" title="5.2 增量扩容"></a>5.2 增量扩容</h4><p>当负载因子过大时，就新建一个buckets，新的buckets长度是原来的2倍，然后旧buckets数据搬迁到新的buckets。 考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p><p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p><p><img src="http://image.huany.top/hexo/go/map-04-struct_sketch.png" alt></p><p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p><p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p><p><img src="http://image.huany.top/hexo/go/map-05-struct_sketch.png" alt></p><p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。 后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p><p>搬迁完成后的示意图如下：</p><p><img src="http://image.huany.top/hexo/go/map-06-struct_sketch.png" alt></p><p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。</p><h4 id="5-3-等量扩容"><a href="#5-3-等量扩容" class="headerlink" title="5.3 等量扩容"></a>5.3 等量扩容</h4><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。 在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p><p><img src="http://image.huany.top/hexo/go/map-07-struct_sketch.png" alt></p><p>上图可见，overflow的buckt中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p><h3 id="6-查找过程"><a href="#6-查找过程" class="headerlink" title="6. 查找过程"></a>6. 查找过程</h3><p>查找过程如下：</p><ol><li>跟据key值算出哈希值 </li><li>取哈希值低位与hmpa.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ol><p><strong>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</strong></p><h3 id="7-插入过程"><a href="#7-插入过程" class="headerlink" title="7. 插入过程"></a>7. 插入过程</h3><p>新员素插入过程如下： </p><ol><li>跟据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值 </li><li>如果没找到将key，将key插入</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go string低层原理</title>
      <link href="/2019/06/30/go-string/"/>
      <url>/2019/06/30/go-string/</url>
      
        <content type="html"><![CDATA[<h3 id="string标准概念"><a href="#string标准概念" class="headerlink" title="string标准概念"></a>string标准概念</h3><p>Go标准库<code>builtin</code>给出了所有内置类型的定义。源码位于<code>src/builtin/builtin.go</code>，其中关于string的描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="line">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="line">// not nil. Values of string type are immutable.</span><br><span class="line">type string string</span><br></pre></td></tr></table></figure><p>所以string是8比特字节的集合，通常但不一定是UTF-8编码的文本。</p><p>另外还提到了两点，非常重要：</p><ul><li>string可以为空（长度为0），但不会是nil；</li><li>string对象是不可修改的。</li></ul><h3 id="string-数据结构"><a href="#string-数据结构" class="headerlink" title="string 数据结构"></a>string 数据结构</h3><p>源码包<code>src/runtime/string.go:stringStruct</code>定义了string的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据结构很简单：</p><ul><li>stringStruct.str: 字符串首字母地址；</li><li>stringStruct.len：字符串的长度；</li></ul><p>string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换。这个后面再详细介绍。</p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>如下代码所示，可以声明一个string变量并赋予初值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str string</span><br><span class="line">str = &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>字符串构建过程中先根据字符串构建stringStruct，再转换成string。转换的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func gostringnocopy(str *byte) string &#123; // 跟据字符串地址构建string</span><br><span class="line">    ss := stringStruct&#123;str: unsafe.Pointer(str), len: findnull(str)&#125; // 先构造stringStruct</span><br><span class="line">    s := *(*string)(unsafe.Pointer(&amp;ss))                             // 再将stringStruct转换成string</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string在runtime包中就是stringStruct，对外呈现叫做string。</p><h4 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h4><p>byte切片可以很方便的转换成string，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetStringBySlice(s []byte) string &#123;</span><br><span class="line">    return string(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这种转换需要一次内存拷贝。</p><p>转换过程如下： </p><ol><li>跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；</li><li>构建string（string.str = p；string.len = len；） </li><li>拷贝数据(切片中数据拷贝到新申请的内存空间)</li></ol><p>转换示意图：<br><img src="http://image.huany.top/hexo/go/string-01-slice2string.png" alt></p><h4 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h4><p>string也可以很方便的转成byte切片，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetSliceByString(str string) []byte &#123;</span><br><span class="line">    return []byte(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string转换成byte切片，也需要一次内存拷贝，其过程如下：</p><ul><li>申请切片内存空间</li><li>将string拷贝到切片</li></ul><p>转换示意图：<br><img src="http://image.huany.top/hexo/go/string-02-string2slice.png" alt></p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>字符串可以很方便的拼接，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Str1&quot; + &quot;Str2&quot; + &quot;Str3&quot;</span><br></pre></td></tr></table></figure><p>即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。</p><p>一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。</p><p>字符串拼接伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func concatstrings(a []string) string &#123; // 字符串拼接</span><br><span class="line">    length := 0        // 拼接后总的字符串长度</span><br><span class="line"></span><br><span class="line">    for _, str := range a &#123;</span><br><span class="line">        length += length(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间</span><br><span class="line"></span><br><span class="line">    for _, str := range a &#123;</span><br><span class="line">        copy(b, str)    // string无法修改，只能通过切片修改</span><br><span class="line">        b = b[len(str):]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为string是无法直接修改的，所以这里使用rawstring()方法初始化一个指定大小的string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了string。</p><p>rawstring()源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func rawstring(size int) (s string, b []byte) &#123; // 生成一个新的string，返回的string和切片共享相同的空间</span><br><span class="line">    p := mallocgc(uintptr(size), nil, false)</span><br><span class="line"></span><br><span class="line">    stringStructOf(&amp;s).str = p</span><br><span class="line">    stringStructOf(&amp;s).len = size</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么字符串不允许修改？"><a href="#为什么字符串不允许修改？" class="headerlink" title="为什么字符串不允许修改？"></a>为什么字符串不允许修改？</h4><p>像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。</p><p>因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。</p><h4 id="byte转换成string一定会拷贝内存吗？"><a href="#byte转换成string一定会拷贝内存吗？" class="headerlink" title="[]byte转换成string一定会拷贝内存吗？"></a>[]byte转换成string一定会拷贝内存吗？</h4><p>byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。</p><p>比如，编译器会识别如下临时场景：</p><ul><li>使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；</li><li>字符串拼接，如”&lt;” + “string(b)” + “&gt;”；</li><li>字符串比较：string(b) == “foo”</li></ul><p>因为是临时把byte切片转换成string，也就避免了因byte切片内容改变而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。</p><h4 id="string和-byte如何取舍？"><a href="#string和-byte如何取舍？" class="headerlink" title="string和[]byte如何取舍？"></a>string和[]byte如何取舍？</h4><p>string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要跟据实际应用场景来选择。</p><p>string 擅长的场景：</p><ul><li>需要字符串比较的场景；</li><li>不需要nil字符串的场景；</li></ul><p>[]byte擅长的场景：</p><ul><li>修改字符串的场景，尤其是修改粒度为1个字节</li><li>函数返回值，需要用nil表示含义的场景；</li><li>需要切片操作的场景；</li></ul><p>虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go slice实现原理</title>
      <link href="/2019/06/30/go-slice/"/>
      <url>/2019/06/30/go-slice/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>Slice又称为动态数组，低层依托于数组实现。可以方便的进行扩容，传递等。实际使用过程中，比数组更灵活。</p><h3 id="2-Slice实现原理"><a href="#2-Slice实现原理" class="headerlink" title="2 Slice实现原理"></a>2 Slice实现原理</h3><p>Slice依托于数组实现，低层数组对用户屏蔽，在低层数组容量不足时可以实现自动重分配并生成新的Slice。</p><h3 id="2-1-Slice的数据结构"><a href="#2-1-Slice的数据结构" class="headerlink" title="2.1 Slice的数据结构"></a>2.1 Slice的数据结构</h3><p>源码包中<code>src/runtime/slice.go</code>定义了Slice的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type slice struct&#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">    cap int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构看，slice其实就是一个结构体，array指针指向低层数组，len表示切片长度，cap表示低层数组容量。</p><h3 id="2-2-使用make创建Slice"><a href="#2-2-使用make创建Slice" class="headerlink" title="2.2 使用make创建Slice"></a>2.2 使用make创建Slice</h3><p>使用<strong>make</strong>关键字创建Slice时，可以同时制定长度和容量，创建时低层会分配一个数组，数组的长度即容量。</p><p>例如，语句 <code>slice:=make([]int,5,10)</code>所创建的slice，结构如下图所示:</p><p><img src="http://image.huany.top/hexo/go/make_slice_01.png" alt></p><p>该Slice的长度为5，可以使用slice[0]~slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。</p><h3 id="2-3-使用数组创建Slice"><a href="#2-3-使用数组创建Slice" class="headerlink" title="2.3 使用数组创建Slice"></a>2.3 使用数组创建Slice</h3><p>使用数组来创建Slice时，Slice将于原数组共用一部分内存。例如，语句<code>slice:=array[5:7]</code>所创建的Slice，结构如下图所示:</p><p><img src="http://image.huany.top/hexo/go/make_slice_02.jpg" alt></p><p>切片从数组array[5]开始，到数组array[7]结束（不含array[7]）,即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5。</p><p>数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。</p><h3 id="2-4-Slice扩容"><a href="#2-4-Slice扩容" class="headerlink" title="2.4 Slice扩容"></a>2.4 Slice扩容</h3><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</p><p>例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如图所示：</p><p><img src="http://image.huany.top/hexo/go/make_slice_03.jpg" alt></p><p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。</p><p>扩容容量的选择遵循以下规则：</p><ul><li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li><li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li></ul><p>使用append()向Slice添加一个元素的实现步骤如下：</p><ol><li>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</li><li>原Slice容量不够，则将Slice先扩容，扩容后得到新Slice</li><li>将新元素追加进新Slice，Slice.len++，返回新的Slice。</li></ol><h3 id="2-5-Slice-Copy"><a href="#2-5-Slice-Copy" class="headerlink" title="2.5 Slice Copy"></a>2.5 Slice Copy</h3><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。也就是说，copy过程中不会发生扩容。</p><h3 id="2-6-特殊切片"><a href="#2-6-特殊切片" class="headerlink" title="2.6 特殊切片"></a>2.6 特殊切片</h3><p>跟据数组或切片生成新的切片一般使用<code>slice := array[start:end]</code>方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p><p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := make([]int, 5, 10)</span><br><span class="line">sliceB := sliceA[0:5]</span><br></pre></td></tr></table></figure><p>根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即<code>slice[start:end:cap]</code>, 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sliceA := make([]int, 5, 10)  //length = 5; capacity = 10</span><br><span class="line">sliceB := sliceA[0:5]         //length = 5; capacity = 10</span><br><span class="line">sliceC := sliceA[0:5:5]       //length = 5; capacity = 5</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><ul><li>每个切片都指向一个底层数组</li><li>每个切片都保存了当前切片的长度、底层数组可用容量</li><li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li><li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li><li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣</li><li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-date-time-conver</title>
      <link href="/2019/06/30/go-date-time-conver/"/>
      <url>/2019/06/30/go-date-time-conver/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    datetime := &quot;2015-01-01 00:00:00&quot;  //待转化为时间戳的字符串</span><br><span class="line"></span><br><span class="line">    //日期转化为时间戳</span><br><span class="line">    timeLayout := &quot;2006-01-02 15:04:05&quot;  //转化所需模板</span><br><span class="line">    loc, _ := time.LoadLocation(&quot;Local&quot;)    //获取时区</span><br><span class="line">    tmp, _ := time.ParseInLocation(timeLayout, datetime, loc)</span><br><span class="line">    timestamp := tmp.Unix()    //转化为时间戳 类型是int64</span><br><span class="line">    fmt.Println(timestamp)</span><br><span class="line">    </span><br><span class="line">    //时间戳转化为日期</span><br><span class="line">    datetime = time.Unix(timestamp, 0).Format(timeLayout)</span><br><span class="line">    fmt.Println(datetime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1420041600</span><br><span class="line">2015-01-01 00:00:00</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go strings包介绍</title>
      <link href="/2019/06/30/go-strings-package/"/>
      <url>/2019/06/30/go-strings-package/</url>
      
        <content type="html"><![CDATA[<p><strong>strings</strong>包提供了操作字符串的简单函数。</p><ol><li>func Compare(a,b string) int</li><li>func Contains(s, substr string) bool</li><li>func Count(s, sep string) int</li><li>func Fields(s string) []string</li><li>func FieldsFunc(s string, f func(rune) bool) []string</li><li>func HasPrefix(s, prefix string) bool</li><li>func HasSuffix(s, suffix string) bool</li><li>func Index(s, sep string) int</li><li>func LastIndex(s,sep string) int</li><li>func Join(a []string,sep string) string</li><li>func Repeat(s string,count int) string</li><li>func Replace(s,old,new string,n int) string</li><li>func Split(s,sep string) []string</li><li>func SplitN(s,sep string, n int) []string</li><li>func ToLower(s string) string</li><li>funcc ToUpper(s string) string</li><li>func Trim(s string,cutset string) string</li></ol><hr><h3 id="1-func-Compare"><a href="#1-func-Compare" class="headerlink" title="1. func Compare"></a>1. func Compare</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Compare(a, b string) int</span><br></pre></td></tr></table></figure><p>根据字典顺序，比较两个字符串的大小。字典顺序，就是说，将多个字符串的同一位置的字符按照26个字母的顺序进行比对。a最小，z最大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b.</span><br></pre></td></tr></table></figure><h3 id="2-func-Contains"><a href="#2-func-Contains" class="headerlink" title="2. func Contains"></a>2. func Contains</h3><p>判断，原字符串是否包含子串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;foo&quot;))</span><br><span class="line">fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;bar&quot;))</span><br><span class="line">fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;&quot;))</span><br><span class="line">fmt.Println(strings.Contains(&quot;&quot;, &quot;&quot;))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="3-func-Count"><a href="#3-func-Count" class="headerlink" title="3. func Count"></a>3. func Count</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Count(s, sep string) int</span><br></pre></td></tr></table></figure><p>Count计算s中非重叠sep实例的数量。如果sep是空字符串，则Count返回1 +len(s)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（strings.Count（“cheese”，“e”））</span><br><span class="line">fmt.Println（strings.Count（“five”，“”））//在每个符文之前和之后</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="4-func-Fields"><a href="#4-func-Fields" class="headerlink" title="4. func Fields"></a>4. func Fields</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Fields(s string) []string</span><br></pre></td></tr></table></figure><p>以空格为分隔符，分割字符串s，并返回字符切片</p><h3 id="5-func-FieldsFunc"><a href="#5-func-FieldsFunc" class="headerlink" title="5. func FieldsFunc"></a>5. func FieldsFunc</h3><p>按照空格，分割字符串，同时对分割后的单个字符串，做相应的逻辑判断，如果匿名函数为真，则不返回该子串。最后返回一个字符串切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//只返回字母</span><br><span class="line">func testFieldsFunc() &#123;</span><br><span class="line">        str := &quot;- MY NAME is meichaofan JACK 1534&quot;</span><br><span class="line">            r := strings.FieldsFunc(str, func(r rune) bool &#123;</span><br><span class="line">                        return !unicode.IsLetter(r)</span><br><span class="line">                            &#125;)</span><br><span class="line">                fmt.Printf(&quot;%v&quot;, r)</span><br><span class="line">&#125;</span><br><span class="line">//output </span><br><span class="line">// [MY NAME is meichaofan JACK]</span><br></pre></td></tr></table></figure></p><h3 id="6-func-HasPrefix"><a href="#6-func-HasPrefix" class="headerlink" title="6. func HasPrefix"></a>6. func HasPrefix</h3><p>判断字符串是否以某个前缀开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testHasPrefix()  &#123;</span><br><span class="line">        str := &quot;meichaofan&quot;</span><br><span class="line">            r := strings.HasPrefix(str,&quot;mei&quot;)</span><br><span class="line">                fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">//true</span><br></pre></td></tr></table></figure><h3 id="7-func-HasSuffix"><a href="#7-func-HasSuffix" class="headerlink" title="7. func HasSuffix"></a>7. func HasSuffix</h3><p>判断字符串是否以某个后缀结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testHasSuffix()  &#123;</span><br><span class="line">        str := &quot;/home/meichaofan&quot;</span><br><span class="line">            r := strings.HasPrefix(str,&quot;/&quot;)</span><br><span class="line">                fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">//false</span><br></pre></td></tr></table></figure><h3 id="8-func-Index"><a href="#8-func-Index" class="headerlink" title="8.func Index"></a>8.func Index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Index（s，sep string）int</span><br></pre></td></tr></table></figure><p>Index 返回s中第一个sep子串的位置，如果不存在sep，返回-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（strings.Index（“chicken”，“ken”））</span><br><span class="line">fmt.Println（strings.Index（“chicken”，“dmr”））</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="9-func-LastIndex"><a href="#9-func-LastIndex" class="headerlink" title="9.func LastIndex"></a>9.func LastIndex</h3><p>返回子串最后一次出现的位置</p><h3 id="10-func-Join"><a href="#10-func-Join" class="headerlink" title="10.func Join"></a>10.func Join</h3><p>字符串切片以<strong>sep</strong>合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := []string&#123;&quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;jack&quot;&#125;</span><br><span class="line">r:= strings.Join(str,&quot;-&quot;)</span><br><span class="line">fmt.Println(r)</span><br><span class="line">//output</span><br><span class="line">//my-name-is-jack</span><br></pre></td></tr></table></figure><h3 id="11-func-Repeat"><a href="#11-func-Repeat" class="headerlink" title="11. func Repeat"></a>11. func Repeat</h3><p>重复字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（“ba”+ strings.Repeat（“na”，2））</span><br><span class="line">//output</span><br><span class="line">//banana</span><br></pre></td></tr></table></figure><h3 id="12-func-Replace"><a href="#12-func-Replace" class="headerlink" title="12. func Replace"></a>12. func Replace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Replace(s, old, new string, n int) string</span><br></pre></td></tr></table></figure><p>字符串替换，将原串中<strong>old</strong>串，替换成<strong>new</strong>串。替换次数为<strong>n</strong>次。当n&lt;0，替换次数没有限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;k&quot;, &quot;ky&quot;, 2))</span><br><span class="line">fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;oink&quot;, &quot;moo&quot;, -1))</span><br><span class="line">//output </span><br><span class="line">//oinky oinky oink</span><br><span class="line">//moo moo moo</span><br></pre></td></tr></table></figure><h3 id="13-fun-Split"><a href="#13-fun-Split" class="headerlink" title="13.fun Split"></a>13.fun Split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Split(s, sep string) []string</span><br></pre></td></tr></table></figure><p>将字符串s按照分隔符<strong>sep</strong>分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span><br><span class="line">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</span><br><span class="line">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</span><br><span class="line">[&quot;&quot;]</span><br></pre></td></tr></table></figure><h3 id="14-func-SplitN"><a href="#14-func-SplitN" class="headerlink" title="14. func SplitN"></a>14. func SplitN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SplitN（s，sep string，n int）[] string</span><br></pre></td></tr></table></figure><p>n表示要返回的子字符串数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n&gt;0:最多n个子串，最后一个子字符串是未分割的余数</span><br><span class="line">n==0:结果是nil</span><br><span class="line">n&lt;0;所有子串 等效于 split</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf（“％q \ n”，strings.SplitN（“a，b，c”，“，”，2））</span><br><span class="line">z：= strings.SplitN（“a，b，c”，“，”，0 ）</span><br><span class="line">fmt.Printf（“％q（nil =％v）\ n”，z，z == nil）</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[“a”“b，c”] </span><br><span class="line">[]（nil = true）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 初始化顺序</title>
      <link href="/2019/06/30/go-initialization-sequence/"/>
      <url>/2019/06/30/go-initialization-sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>先执行import包的每个文件的<strong>常量</strong>和<strong>变量</strong>，然后是<strong>init</strong>函数，最后执行<strong>main</strong>函数，当<strong>main</strong>函数执行结束程序退出。</p><p><img src="http://image.huany.top/hexo/go/go-initialization-sequence.png" alt="go 初始化顺序"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>全方位解读PHP7低层源码</title>
      <link href="/2019/06/15/php7-source-code/"/>
      <url>/2019/06/15/php7-source-code/</url>
      
        <content type="html"><![CDATA[<p>本栏从源码的角度，解析PHP7。对掌握PHP有重大帮助，望坚持更新。</p><ul><li>PHP7的新特性</li><li>基础变量与内存管理</li><li>PHP运行的生命周期</li><li>PHP代码的编译与执行</li><li>基础语法实现的细节</li><li>PHP扩展编写</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy介绍</title>
      <link href="/2019/05/31/python-numpy/"/>
      <url>/2019/05/31/python-numpy/</url>
      
        <content type="html"><![CDATA[<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>在学习深度学习时，NumPy的数组类提供了很多关于操作数组和矩阵的便捷方法。</p><hr><h2 id="2019-5-30"><a href="#2019-5-30" class="headerlink" title="2019/5/30"></a>2019/5/30</h2><h3 id="1-1-导入NumPy"><a href="#1-1-导入NumPy" class="headerlink" title="1.1 导入NumPy"></a>1.1 导入NumPy</h3><p>NumPy并不存在于标准版<code>Python</code>中，因此，首先需要导入NumPy库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br></pre></td></tr></table></figure><h3 id="1-2-生成NumPy数组"><a href="#1-2-生成NumPy数组" class="headerlink" title="1.2 生成NumPy数组"></a>1.2 生成NumPy数组</h3><p>使用<code>np.array()</code>方法。<code>np.array()</code>接受Python的<strong>列表</strong>作为参数，生成NumPy数组（<code>num.ndarray</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=np.array([1.0,2.0,3.0])</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">[1. 2. 3.]</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &apos;numpy.ndarray&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-NumPy的算术运算"><a href="#1-3-NumPy的算术运算" class="headerlink" title="1.3 NumPy的算术运算"></a>1.3 NumPy的算术运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0])</span><br><span class="line">&gt;&gt;&gt; y = np.array([2.0, 4.0, 6.0])</span><br><span class="line">&gt;&gt;&gt; x + y # 对应元素的加法</span><br><span class="line">array([ 3., 6., 9.])</span><br><span class="line">&gt;&gt;&gt; x - y</span><br><span class="line">array([ -1., -2., -3.])</span><br><span class="line">&gt;&gt;&gt; x * y # element-wise product</span><br><span class="line">array([ 2., 8., 18.])</span><br><span class="line">&gt;&gt;&gt; x / y</span><br><span class="line">array([ 0.5, 0.5, 0.5])</span><br></pre></td></tr></table></figure><p>需要注意，数组x和数组y的元素个数相同，如果元素个数不同，程序会报错。</p><p>NumPy数组不仅可以进行<strong>对应</strong>元素的运算，也可以和单一的数值（标量）进行运算，这个功能叫<strong>广播</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0])</span><br><span class="line">&gt;&gt;&gt; x / 2.0</span><br><span class="line">array([ 0.5, 1. , 1.5])</span><br></pre></td></tr></table></figure><h3 id="NumPy的N维数组"><a href="#NumPy的N维数组" class="headerlink" title="NumPy的N维数组"></a>NumPy的N维数组</h3><p>NumPy可以生成多维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = np.array([[1, 2], [3, 4]])</span><br><span class="line">&gt;&gt;&gt; print(A)</span><br><span class="line">[[1 2]</span><br><span class="line">[3 4]]</span><br><span class="line">&gt;&gt;&gt; A.shape #查看数组形状</span><br><span class="line">(2, 2)</span><br><span class="line">&gt;&gt;&gt; A.dtype #查看数组元素的数据类型</span><br><span class="line">dtype(&apos;int64&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; B = np.array([[3, 0],[0, 6]])</span><br><span class="line">&gt;&gt;&gt; A + B   #两个二维数组相加</span><br><span class="line">array([[ 4, 2],</span><br><span class="line">[ 3, 10]])</span><br><span class="line">&gt;&gt;&gt; A * B    #两个二维数组相乘，对应位置的元素进行算术运算</span><br><span class="line">array([[ 3, 0],</span><br><span class="line">[ 0, 24]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#广播</span><br><span class="line">&gt;&gt;&gt;print(A)</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">&gt;&gt;&gt;A*10</span><br><span class="line">array([[ 10, 20],</span><br><span class="line">[ 30, 40]])</span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>元素的索引从0开始。对各个元素的访问如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = np.array([[51, 55], [14, 19], [0, 4]])</span><br><span class="line">&gt;&gt;&gt; print(X)</span><br><span class="line">[[51 55]</span><br><span class="line">[14 19]</span><br><span class="line">[ 0 4]]</span><br><span class="line">&gt;&gt;&gt; X[0] # 第0行</span><br><span class="line">array([51, 55])</span><br><span class="line">&gt;&gt;&gt; X[0][1] # (0,1)的元素</span><br><span class="line">55</span><br></pre></td></tr></table></figure><p>也可以用for语句访问各个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for row in X:</span><br><span class="line">... print(row)</span><br><span class="line">...</span><br><span class="line">[51 55]</span><br><span class="line">[14 19]</span><br><span class="line">[0 4]</span><br></pre></td></tr></table></figure><p>除了前面介绍的索引操作，NumPy还可以使用数组访问各个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = X.flatten() # 将X转换为一维数组</span><br><span class="line">&gt;&gt;&gt; print(X)</span><br><span class="line">[51 55 14 19 0 4]</span><br><span class="line">&gt;&gt;&gt; X[np.array([0, 2, 4])] # 获取索引为0、 2、 4的元素</span><br><span class="line">array([51, 14, 0])</span><br></pre></td></tr></table></figure><p> 运用这个标记法，可以获取满足一定条件的元素。例如，要从 X中抽出大于15的元素，可以写成如下形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X &gt; 15</span><br><span class="line">array([ True, True, False, True, False, False], dtype=bool)</span><br><span class="line">&gt;&gt;&gt; X[X&gt;15]</span><br><span class="line">array([51, 55, 19])</span><br></pre></td></tr></table></figure><p>对NumPy数组使用不等号运算符等（上例中是 X &gt; 15）,结果会得到一个布尔型的数组。上例中就是使用这个布尔型数组取出了数组的各个元素（取出 True对应的元素）。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-1-two-sum</title>
      <link href="/2019/05/29/leetcode-1-two-sum/"/>
      <url>/2019/05/29/leetcode-1-two-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="PHP版本"><a href="#PHP版本" class="headerlink" title="PHP版本"></a>PHP版本</h3><h3 id="JAVA版本"><a href="#JAVA版本" class="headerlink" title="JAVA版本"></a>JAVA版本</h3><h3 id="Go版本"><a href="#Go版本" class="headerlink" title="Go版本"></a>Go版本</h3><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好好过生活，知足最快乐</title>
      <link href="/2019/05/28/have-a-good-life/"/>
      <url>/2019/05/28/have-a-good-life/</url>
      
        <content type="html"><![CDATA[<p><em>还记得 你说家是唯一的城堡</em></p><p><em>随着稻香河流继续奔跑</em></p><p><em>微微笑 小时候的梦我知道</em></p><p><em>不要哭 让萤火虫带着你逃跑</em></p><p><em>乡间的歌谣 永远的依靠</em></p><p><em>回家吧 回到最初的美好</em></p><hr><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ul><li><a href="/2019/05/28/graduation-finally/">毕业在即，云胡不喜</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业在即，云乎不喜</title>
      <link href="/2019/05/28/graduation-finally/"/>
      <url>/2019/05/28/graduation-finally/</url>
      
        <content type="html"><![CDATA[<p>终于要换一种身份开启人生新一段旅程。</p><p> <img src="https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/d909af140ea14cb3f8ce3385d22b0d6.jpg" alt="没有电的实验室"></p><p><img src="https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/380a3be32413d25df630dfe3b83b976.jpg" alt="第一次看见北京早上5点钟的天空"></p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux如何给应用程序创建一个桌面启动图标</title>
      <link href="/2019/04/29/linux-create-a-desktop-app/"/>
      <url>/2019/04/29/linux-create-a-desktop-app/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述的是linux中如何给应用程序创建一个快速启动图标，话不多说，我们来看实际的操作步骤：</p><p>本文的实例是给celipse创建一个启动图标</p><hr><ol><li><p>我们需要通过下列命令，来创建一个启动的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/applications/eclipse.desktop</span><br></pre></td></tr></table></figure></li><li><p>将下列内容复制到启动脚本中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=Eclipse</span><br><span class="line">Comment=Eclipse IDE</span><br><span class="line">Exec=/usr/local/android/eclipse/eclipse      </span><br><span class="line">Icon=/usr/local/android/eclipse/icon.xpm</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>说明部分：<br>Exec ：这个是应用程序可执行文件的目录<br>Icon ：这个是图标的目录</p></blockquote><ol start="3"><li>然后在applications -&gt; programming 菜单中就可以找到你所创建的图标了，然后再右键创建一个桌面图标即可</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Desktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 系统修改默认运行级别</title>
      <link href="/2019/04/29/ubuntu-change-runlevel/"/>
      <url>/2019/04/29/ubuntu-change-runlevel/</url>
      
        <content type="html"><![CDATA[<h2 id="Deb系运行级别（Debian、Ubuntu）"><a href="#Deb系运行级别（Debian、Ubuntu）" class="headerlink" title="Deb系运行级别（Debian、Ubuntu）"></a>Deb系运行级别（Debian、Ubuntu）</h2><blockquote><p>0 – Halt，关机模式<br>1 – Single，单用户模式<br>2 - Full multi-user with display manager (GUI)<br>3 - Full multi-user with display manager (GUI)<br>4 - Full multi-user with display manager (GUI)<br>5 - Full multi-user with display manager (GUI)<br>6 – Reboot，重启<br>S - 单用户恢复模式</p></blockquote><p>2~5级是没有任何区别的，他们为多用户模式。</p><h2 id="Rpm系运行级别（Redhat、CentOS）"><a href="#Rpm系运行级别（Redhat、CentOS）" class="headerlink" title="Rpm系运行级别（Redhat、CentOS）"></a>Rpm系运行级别（Redhat、CentOS）</h2><blockquote><p>0 – Halt，关机模式<br>1 – Single，单用户模式<br>2 – 多用户模式，但不能使用NFS（相当于Windows下的网上邻居）<br>3 – 字符界面的多用户模式<br>4 – Undefined<br>5 – Full multi-user with display manager (GUI)<br>6 – Reboot，重启</p></blockquote><h2 id="查看当前运行级别"><a href="#查看当前运行级别" class="headerlink" title="查看当前运行级别"></a>查看当前运行级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu:~$ runlevel </span><br><span class="line">N 2</span><br></pre></td></tr></table></figure><h2 id="ubuntu系统下修改运行级别"><a href="#ubuntu系统下修改运行级别" class="headerlink" title="ubuntu系统下修改运行级别"></a>ubuntu系统下修改运行级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/default/grup</span><br><span class="line">将</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;</span><br><span class="line">改为</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;</span><br><span class="line">然后执行</span><br><span class="line">update-grub2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> runlevel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的进程调度</title>
      <link href="/2019/04/28/linux-process-sche/"/>
      <url>/2019/04/28/linux-process-sche/</url>
      
        <content type="html"><![CDATA[<p>转载至 <a href="https://blog.csdn.net/gatieme/article/details/51701149" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51701149</a></p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><hr><h3 id="1-1-进程调度"><a href="#1-1-进程调度" class="headerlink" title="1.1 进程调度"></a>1.1 进程调度</h3><p>内存中保存了对每个进程的唯一描述，并通过若干结构与其它进程连接起来。</p><p><strong>调度器</strong>面对的情形就是这样，其任务是在程序之间共享CPU时间，创造并行执行的错觉，该任务分为两个不同的部分，其中一个涉及<strong>调度策略</strong>，另外一个涉及<strong>上下文切换</strong>。</p><hr><h3 id="1-2-进程的分类"><a href="#1-2-进程的分类" class="headerlink" title="1.2 进程的分类"></a>1.2 进程的分类</h3><hr><p>Linux把进程区分为<strong>实时进程</strong>和<strong>非实时进程</strong>，其中非实时进程进一步划分为<strong>交互式进程</strong>和<strong>批处理进程</strong>。</p><table><thead><tr><th>类型</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td>实时进程（real-time process）</td><td style="text-align:center">这些进程需要很强的调度需要，这样的进程不会被低优先级进程阻塞，并且他们的响应时间要尽可能的短</td><td style="text-align:center">视频音频应用程程序，机器人控制程序以及物理传感器收集数据的程序</td></tr><tr><td>交互式进程（interactive process）</td><td style="text-align:center">此类进程经常与用户进行交互，因此需要花很多时间等待键盘和鼠标操作，当接受了用户输入后，进程必须很快被唤醒，否则用户感觉系统反应迟钝</td><td style="text-align:center">shell,文本编辑程序和图形应用程序</td></tr><tr><td>批处理进程（batch process）</td><td style="text-align:center">此类进程不必与用户交互，因此经常在后台运行，因为这样的进程不必很快响应，因此常受到调度程序的怠慢</td><td style="text-align:center">程序语言的编译程序，数据库搜索引擎以及科学计算</td></tr></tbody></table><p>在Linux中，调度算法可以明确的确认所有实时进程的身份，但是没办法区分交互式程序和批处理程序，在Linux2.6的调度程序实现了基于进程过去式行为的启发式算法，以确定进程应该被当做交互式进程还是批处理进程，当然与批处理进程相比，调度程序有偏爱交互式进程的倾向。</p><h3 id="1-3-不同进程采用不同的调度策略"><a href="#1-3-不同进程采用不同的调度策略" class="headerlink" title="1.3 不同进程采用不同的调度策略"></a>1.3 不同进程采用不同的调度策略</h3><hr><p>根据进程的不同分类Linux采用不同的调度策略。</p><p><strong>对于实时进程，采用FIFO或者Round Robin的调度策略</strong>。</p><p>对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器核心思想是<strong>“完全公平”</strong>。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。</p><p>注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和/或数据）的多个线程。因此进程调度也包含了线程调度的功能。</p><p>目前实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.</p><p>但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢，因此在linux调度器的发展历程中经过了多次重大变动, linux总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程.</p><h3 id="1-4-Linux调度器的演变"><a href="#1-4-Linux调度器的演变" class="headerlink" title="1.4 Linux调度器的演变"></a>1.4 Linux调度器的演变</h3><hr><p>一开始的调度器是复杂度为<em>O(n)</em>的调度算法（实际上每次遍历所有任务，所以复杂度为<em>O(n)</em>），这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从Linux2.5开始引入了赫赫有名<em>O(1)</em>的调度器。</p><p>然而，linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在<strong>O(1)</strong>调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是<strong>CFS调度器Completely Fair Scheduler</strong>. 这个也是在2.6内核中引入的，具体为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，<strong>O(1)</strong>调度器被抛弃了。</p><p>所以完全有理由相信，后续如果再会出现一个更优秀的调度器，CFS也不会幸免。因为linux只要最好的那个。</p><h2 id="2-O-n-的始调度算法"><a href="#2-O-n-的始调度算法" class="headerlink" title="2. O(n)的始调度算法"></a>2. <em>O(n)</em>的始调度算法</h2><hr><h3 id="2-1-Linux2-4之前的内核调度器"><a href="#2-1-Linux2-4之前的内核调度器" class="headerlink" title="2.1 Linux2.4之前的内核调度器"></a>2.1 Linux2.4之前的内核调度器</h3><hr><p>早期的Linux进程调度器使用了最低的设计，它显然不关注具有很多处理器的大型架构，更不用说是超线程了。</p><p>Linux调度器使用了<strong>环形队列</strong>用于可运行的任务管理, 使用循环调度策略.</p><p>此调度器添加和删除进程效率很高（具有保护结构的锁）。简而言之，该调度器并不复杂但是简单快捷.</p><p>Linux版本2.2引入了调度类的概念，允许针对实时任务、非抢占式任务、非实时任务的调度策略。调度器还包括对称多处理 (SMP) 支持。</p><h3 id="2-2-Linux2-4的调度器"><a href="#2-2-Linux2-4的调度器" class="headerlink" title="2.2 Linux2.4的调度器"></a>2.2 Linux2.4的调度器</h3><hr><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><hr><p>在Linux2.4.18中(linux-2.5)之前的内核, 当很多任务都处于活动状态时, 调度器有很明显的限制. 这是由于调度器是使用一个复杂度为<em>O(n)</em>的算法实现的.</p><p>调度器采用基于优先级的设计，这个调度器和Linus在1992年发布的调度器没有大的区别。该调度器的<code>pick next</code>算法非常简单：对runqueue中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程。(Runqueue是Linux 内核中保存所有就绪进程的队列)。 <code>pick next</code>用来指从所有候选进程中挑选下一个要被调度的进程的过程。</p><p>这种调度算法非常简单易懂: <strong>在每次进程切换时, 内核扫描可运行进程的链表, 计算优先级,然后选择“最佳”进程来运行。</strong></p><p>在这种调度器中, 调度任务所花费的时间是一个系统中任务个数的函数. 换而言之, 活动的任务越多, 调度任务所花费的时间越长. 在任务负载非常重时, 处理器会因调度消耗掉大量的时间, 用于任务本身的时间就非常少了。因此，这个算法缺乏可伸缩性</p><h4 id="2-2-2-详情"><a href="#2-2-2-详情" class="headerlink" title="2.2.2 详情"></a>2.2.2 详情</h4><hr><p>每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有RUNNING进程的时间片都被用完之后，才对所有进程重新分配时间片。这段时间被称为一个epoch。这种设计保证了每个进程都有机会得到执行。每个epoch中，每个进程允许执行到其时间切片用完。如果某个进程没有使用其所有的时间切片，那么剩余时间切片的一半将被添加到新时间切片使其在下个epoch中可以执行更长时间。调度器只是迭代进程，应用goodness函数（指标）决定下面执行哪个进程。当然，各种进程对调度的需求并不相同，Linux 2.4调度器主要依靠改变进程的优先级，来满足不同进程的调度需求。事实上，所有后来的调度器都主要依赖修改进程优先级来满足不同的调度需求。</p><p>实时进程：实时进程的优先级是静态设定的，而且始终大于普通进程的优先级。因此只有当runqueue中没有实时进程的情况下，普通进程才能够获得调度。</p><blockquote><p>实时进程采用两种调度策略，SCHED_FIFO 和 SCHED_RR。FIFO 采用先进先出的策略，对于所有相同优先级的进程，最先进入 runqueue 的进程总能优先获得调度；Round Robin采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流获得调度。</p></blockquote><p>普通进程：对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速的用户响应。普通进程的优先级主要由进程描述符中的<code>Counter</code>字段决定 (还要加上<code>nice</code>设定的静态优先级) 。进程被创建时子进程的counter值为父进程counter值的一半，这样保证了任何进程不能依靠不断地<code>fork()</code>子进程从而获得更多的执行机会。</p><p>Linux2.4调度器是如何提高交互式进程的优先级的呢？如前所述，当所有 RUNNING 进程的时间片被用完之后，调度器将重新计算所有进程的 counter 值，所有进程不仅包括 RUNNING 进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的 counter 本来就没有用完，在重新计算时，他们的 counter 值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因等待用户输入而处于睡眠状态，当它们重新被唤醒并进入 runqueue 时，就会优先于其它进程而获得 CPU。从用户角度来看，交互式进程的响应速度就提高了。</p><p>该调度器的主要缺点：</p><ul><li><p>可扩展性不好<br>调度器选择进程时需要遍历整个 runqueue 从中选出最佳人选，因此该算法的执行时间与进程数成正比。另外每次重新计算 counter 所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新 counter 操作的代价会非常高，导致系统整体的性能下降。</p></li><li><p>高负载系统上的调度性能比较低<br>2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间于该时间片的大小成正比。</p></li><li><p>交互式进程的优化并不完善<br>Linux2.4识别交互式进程的原理基于以下假设，即交互式进程比批处理进程更频繁地处于SUSPENDED状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行IO操作，比如一个数据库引擎在处理查询时会经常地进行磁盘IO，虽然它们并不需要快速地用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。</p></li><li><p>对实时进程的支持不够<br>Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</p></li></ul><p>为了解决这些问题，Ingo Molnar开发了新的<em>O(1)</em>调度器，在CFS和RSDL之前，这个调度器不仅被Linux2.6采用，还被backport到Linux2.4中，很多商业的发行版本都采用了这个调度器</p><h2 id="3-O-1-的调度算法"><a href="#3-O-1-的调度算法" class="headerlink" title="3. O(1)的调度算法"></a>3. <em>O(1)</em>的调度算法</h2><hr><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><hr><p>由于进程优先级的最大值为139，因此MAX_PRIO的最大值取140(具体的是，普通进程使用100到139的优先级，实时进程使用0到99的优先级).</p><p>因此，该调度算法为每个优先级都设置一个可运行队列, 即包含140个可运行状态的进程链表，每一条优先级链表上的进程都具有相同的优先级，而不同进程链表上的进程都拥有不同的优先级。</p><p>除此之外, 还包括一个优先级位图bitmap。该位图使用一个位(bit)来代表一个优先级，而140个优先级最少需要5个32位来表示， 因此只需要一个int[5]就可以表示位图，该位图中的所有位都被置0，当某个优先级的进程处于可运行状态时，该优先级所对应的位就被置1。</p><p>如果确定了优先级，那么选取下一个进程就简单了，只需在queue数组中对应的链表上选取一个进程即可。</p><p>最后，在早期的内核中，抢占是不可能的；这意味着如果有一个低优先级的任务在执行，高优先级的任务只能等待它完成。</p><h3 id="3-2-详情"><a href="#3-2-详情" class="headerlink" title="3.2 详情"></a>3.2 详情</h3><hr><p>从名字就可以看出O(1)调度器主要解决了以前版本中的扩展性问题。</p><p>O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。</p><p>此外Linux 2.6内核支持内核态抢占，因此更好地支持了实时进程。</p><p>相对于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。</p><p>Linux 2.6内核也支持三种调度策略。其中SCHED_FIFO和SCHED_RR用于实时进程，而SCHED_NORMAL用于普通进程。</p><p>O(1)调度器在两个方面修改了Linux 2.4调度器，<strong>一是进程优先级的计算方法；二是pick next算法。</strong></p><p>O(1)调度器跟踪运行队列中可运行的任务（实际上，每个优先级水平有两个运行队列，一个用于活动任务，一个用于过期任务）， 这意味着要确定接下来执行的任务，调度器只需按优先级将下一个任务从特定活动的运行队列中取出即可。</p><h3 id="3-2-1-普通进程的优先级计算"><a href="#3-2-1-普通进程的优先级计算" class="headerlink" title="3.2.1 普通进程的优先级计算"></a>3.2.1 普通进程的优先级计算</h3><hr><p>不同类型的进程应该有不同的优先级。每个进程与生俱来（即从父进程那里继承而来）都有一个优先级，我们将其称为静态优先级。普通进程的静态优先级范围从100到139，100为最高优先级，139 为最低优先级，0－99保留给实时进程。当进程用完了时间片后，系统就会为该进程分配新的时间片（即基本时间片），静态优先级本质上决定了时间片分配的大小。</p><p>静态优先级和基本时间片的关系如下：</p><blockquote><p>静态优先级&lt;120，基本时间片=max((140-静态优先级)<em>20,MIN_TIMESLICE)<br>静态优先级&gt;=120，基本时间片=max((140-静态优先级)</em>5,MIN_TIMESLICE)</p></blockquote><p>其中MIN_TIMESLICE为系统规定的最小时间片。从该计算公式可以看出，静态优先级越高（值越低），进程得到的时间片越长。其结果是，优先级高的进程会获得更长的时间片，而优先级低的进程得到的时间片则较短。进程除了拥有静态优先级外，还有动态优先级，其取值范围是100到139。当调度程序选择新进程运行时就会使用进程的动态优先级，动态优先级和静态优先级的关系可参考下面的公式：</p><blockquote><p>动态优先级=max(100，min(静态优先级-bonus+5)，139)</p></blockquote><p>从上面看出，动态优先级的生成是以静态优先级为基础，再加上相应的惩罚或奖励(bonus)。这个bonus并不是随机的产生，而是根据进程过去的平均睡眠时间做相应的惩罚或奖励。</p><p>所谓平均睡眠时间（sleep_avg，位于task_struct结构中）就是进程在睡眠状态所消耗的总时间数，这里的平均并不是直接对时间求平均数。平均睡眠时间随着进程的睡眠而增长，随着进程的运行而减少。因此，平均睡眠时间记录了进程睡眠和执行的时间，它是用来判断进程交互性强弱的关键数据。如果一个进程的平均睡眠时间很大，那么它很可能是一个交互性很强的进程。反之，如果一个进程的平均睡眠时间很小，那么它很可能一直在执行。另外，平均睡眠时间也记录着进程当前的交互状态，有很快的反应速度。比如一个进程在某一小段时间交互性很强，那么sleep_avg就有可能暴涨（当然它不能超过 MAX_SLEEP_AVG），但如果之后都一直处于执行状态，那么sleep_avg就又可能一直递减。理解了平均睡眠时间，那么bonus的含义也就显而易见了。交互性强的进程会得到调度程序的奖励（bonus为正），而那些一直霸占CPU的进程会得到相应的惩罚（bonus为负）。其实bonus相当于平均睡眠时间的缩影，此时只是将sleep_avg调整成bonus数值范围内的大小。可见平均睡眠时间可以用来衡量进程是否是一个交互式进程。如果满足下面的公式，进程就被认为是一个交互式进程：</p><blockquote><p>动态优先级≤3*静态优先级/4 + 28</p></blockquote><p>平均睡眠时间是进程处于等待睡眠状态下的时间，该值在进程进入睡眠状态时增加，而进入RUNNING状态后则减少。该值的更新时机分布在很多内核函数内：时钟中断scheduler_tick()；进程创建；进程从TASK_INTERRUPTIBLE状态唤醒；负载平衡等。</p><h3 id="3-2-2-实时进程的优先级计算"><a href="#3-2-2-实时进程的优先级计算" class="headerlink" title="3.2.2 实时进程的优先级计算"></a>3.2.2 实时进程的优先级计算</h3><hr><p>实时进程的优先级由sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用rt_priority域表示。</p><h3 id="3-2-3-pick-next算法"><a href="#3-2-3-pick-next算法" class="headerlink" title="3.2.3 pick next算法"></a>3.2.3 pick next算法</h3><hr><p>普通进程的调度选择算法基于进程的优先级，拥有最高优先级的进程被调度器选中。</p><p>Linux2.4中，时间片counter同时也表示了一个进程的优先级。Linux2.6中时间片用任务描述符中的time_slice域表示，而优先级用prio（普通进程）或者rt_priority（实时进程）表示。调度器为每一个CPU维护了两个进程队列数组：指向活动运行队列的active数组和指向过期运行队列的expire数组。数组中的元素着保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。它们是按照先进先出的顺序进行服务的。被调度执行的任务都会被添加到各自运行队列优先级列表的末尾。每个任务都有一个时间片，这取决于系统允许执行这个任务多长时间。运行队列的前100个优先级列表保留给实时任务使用，后40个用于用户任务，参见下图：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/Linux-runqueue.png?raw=true" width="50%" height="50%"></div><p>当需要选择当前最高优先级的进程时，2.6调度器不用遍历整个runqueue，而是直接从active数组中选择当前最高优先级队列中的第一个进程。假设当前所有进程中最高优先级为50（换句话说，系统中没有任何进程的优先级小于50）。则调度器直接读取 active[49]，得到优先级为50的进程队列指针。该队列头上的第一个进程就是被选中的进程。这种算法的复杂度为O(1)，从而解决了2.4调度器的扩展性问题。为了实现O(1)算法active数组维护了一个由5个32位的字（140个优先级）组成的bitmap，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。 sched_find_first_bit()函数查询该bitmap，返回当前被置位的最高优先级的数组下标。在上例中sched_find_first_bit函数将返回49。在IA处理器上可以通过bsfl等指令实现。可见查找一个任务来执行所需要的时间并不依赖于活动任务的个数，而是依赖于优先级的数量。这使得 2.6 版本的调度器成为一个复杂度为 O(1) 的过程，因为调度时间既是固定的，而且也不会受到活动任务个数的影响。</p><p>为了提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法：每次时钟tick中断时，进程的时间片(time_slice)被减一。当time_slice为0时，表示当前进程的时间片用完，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置其时间片并重新插入active数组。如果不是交互式进程则从active数组中移到expired数组，并根据上述公式重新计算时间片。这样实时进程和交互式进程就总能优先获得CPU。然而这些进程不能始终留在active数组中，否则进入expire数组的进程就会产生饥饿现象。当进程已经占用CPU时间超过一个固定值后，即使它是实时进程或者交互式进程也会被移到expire数组中。当active数组中的所有进程都被移到expire数组中后，调度器交换active数组和expire数组。因此新的active数组又恢复了初始情况，而expire数组为空，从而开始新的一轮调度。</p><p>Linux 2.6调度器改进了前任调度器的可扩展性问题，schedule()函数的时间复杂度为O(1)。这取决于两个改进：</p><ul><li>pick next算法借助于active数组，无需遍历runqueue；</li><li>消了定期更新所有进程counter的操作，动态优先级的修改分布在进程切换，时钟tick中断以及其它一些内核函数中进行。</li></ul><p>为了解决O(1)调度器面临的问题以及应对其他外部压力, 需要改变某些东西。这种改变来自Con Kolivas的内核补丁staircase scheduler（楼梯调度算法），以及改进的RSDL（Rotating Staircase Deadline Scheduler）。它为调度器设计提供了一个新的思路。Ingo Molnar在RSDL之后开发了CFS，并最终被2.6.23内核采用。接下来我们开始介绍这些新一代调度器。</p><h2 id="4-Linux-2-6的新一代调度器CFS"><a href="#4-Linux-2-6的新一代调度器CFS" class="headerlink" title="4. Linux 2.6的新一代调度器CFS"></a>4. Linux 2.6的新一代调度器CFS</h2><hr><h3 id="4-1-楼梯调度算法staircase-scheduler"><a href="#4-1-楼梯调度算法staircase-scheduler" class="headerlink" title="4.1 楼梯调度算法staircase scheduler"></a>4.1 楼梯调度算法staircase scheduler</h3><hr><p>楼梯算法(SD)在思路上和O(1)算法有很大不同，它抛弃了动态优先级的概念。而采用了一种完全公平的思路。前任算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。楼梯算法思路简单，但是实验证明它对应交互式进程的响应比其前任更好，而且极大地简化了代码。</p><p>和O(1)算法一样，楼梯算法也同样为每一个优先级维护一个进程列表，并将这些列表组织在active数组中。当选取下一个被调度进程时，SD算法也同样从active数组中直接读取。与O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到expire数组中。而是被加入active数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就象一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为1，当它到达最后一级台阶140后，再次用完时间片时将回到优先级为2的任务队列中，即第二级台阶。不过此时分配给该任务的time_slice将变成原来的2倍。比如原来该任务的时间片time_slice为10ms，则现在变成了20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为P，当它从第N级台阶开始下楼梯并到达底部后，将回到第N+1级台阶。并且赋予该任务N+1倍的时间片。</p><p>以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即FIFO或者Round Robin。</p><p>楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。</p><p>楼梯算法的优点：从实现角度看，SD基本上还是沿用了O(1)的整体框架，只是删除了O(1)调度器中动态修改优先级的复杂代码；还淘汰了expire数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。</p><h3 id="4-2-RSLD-Rotating-Staircase-Deadline-Scheduler"><a href="#4-2-RSLD-Rotating-Staircase-Deadline-Scheduler" class="headerlink" title="4.2 RSLD(Rotating Staircase Deadline Scheduler)"></a>4.2 RSLD(Rotating Staircase Deadline Scheduler)</h3><hr><p>RSDL也是由Con Kolivas开发的，它是对SD算法的改进。核心的思想还是”完全公平”。没有复杂的动态优先级调整策略。RSDL重新引入了expire数组。它为每一个优先级都分配了一个 “组时间配额”，记为Tg；同一优先级的每个进程都拥有同样的”优先级时间配额”，用Tp表示。当进程用完了自身的Tp时，就下降到下一优先级进程组中。这个过程和SD相同，在RSDL中这个过程叫做minor rotation（次轮询）。请注意Tp不等于进程的时间片，而是小于进程的时间片。下图表示了minor rotation。进程从priority1的队列中一步一步下到priority140之后回到priority2的队列中，这个过程如下图左边所示，然后从priority 2开始再次一步一步下楼，到底后再次反弹到priority3队列中，如下图所示。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/RSLD.png?raw=true" width="50%" height="50%"></div><p>在SD算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得CPU。因此低优先级进程的等待时间无法确定。RSDL中，当高优先级进程组用完了它们的Tg(即组时间配额)时，无论该组中是否还有进程Tp尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是RSDL中Deadline代表的含义。<br>进程用完了自己的时间片time_slice时（下图中T2），将放入expire数组指向的对应初始优先级队列中(priority 1)。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/3.png?raw=true" width="50%" height="50%"></div><p>当active数组为空，或者所有的进程都降低到最低优先级时就会触发主轮询major rotation。Major rotation交换active数组和expire数组，所有进程都恢复到初始状态，再一次从新开始minor rotation的过程。<br>RSDL对交互式进程的支持：和SD同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为minor rotation而降到了低优先级进程队列中。当它重新进入RUNNING状态时，就获得了相对较高的优先级，从而能被迅速响应。</p><h3 id="4-3-安全公平的调度器CFS"><a href="#4-3-安全公平的调度器CFS" class="headerlink" title="4.3 安全公平的调度器CFS"></a>4.3 安全公平的调度器CFS</h3><hr><p>CFS是最终被内核采纳的调度器。它从RSDL/SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS的算法和实现都相当简单，众多的测试表明其性能也非常优越。<br>按照作者Ingo Molnar的说法（参考Documentation/scheduler/sched-design-CFS.txt），</p><p>CFS百分之八十的工作可以用一句话概括：CFS在真实的硬件上模拟了完全理想的多任务处理器。在真空的硬件上，同一时刻我们只能运行单个进程，因此当一个进程占用CPU时，其它进程就必须等待，这就产生了不公平。但是在“完全理想的多任务处理器 “下，每个进程都能同时获得CPU的执行时间，即并行地每个进程占1/nr_running的时间。例如当系统中有两个进程时，CPU的计算时间被分成两份，每个进程获得50%。假设runqueue中有n个进程，当前进程运行了10ms。在“完全理想的多任务处理器”中，10ms应该平分给n个进程(不考虑各个进程的nice值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了10ms。所以CFS将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。</p><p>与之前的Linux调度器不同，CFS没有将任务维护在链表式的运行队列中，它抛弃了active/expire数组，而是对每个CPU维护一个以时间为顺序的红黑树。 </p><p>该树方法能够良好运行的原因在于：</p><ul><li>红黑树可以始终保持平衡，这意味着树上没有路径比任何其他路径长两倍以上。</li><li>由于红黑树是二叉树，查找操作的时间复杂度为O(log n)。但是除了最左侧查找以外，很难执行其他查找，并且最左侧的节点指针始终被缓存。</li><li>对于大多数操作（插入、删除、查找等），红黑树的执行时间为O(log n)，而以前的调度程序通过具有固定优先级的优先级数组使用 O(1)。O(log n) 行为具有可测量的延迟，但是对于较大的任务数无关紧要。Molnar在尝试这种树方法时，首先对这一点进行了测试。</li><li>红黑树可通过内部存储实现，即不需要使用外部分配即可对数据结构进行维护。</li></ul><p>要实现平衡，CFS使用”虚拟运行时”表示某个任务的时间量。任务的虚拟运行时越小，意味着任务被允许访问服务器的时间越短，其对处理器的需求越高。CFS还包含睡眠公平概念以便确保那些目前没有运行的任务（例如，等待 I/O）在其最终需要时获得相当份额的处理器。</p><h4 id="4-3-1-CFS如何实现pick-next"><a href="#4-3-1-CFS如何实现pick-next" class="headerlink" title="4.3.1 CFS如何实现pick next"></a>4.3.1 CFS如何实现pick next</h4><hr><p>下图是一个红黑树的例子</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/virtual_running_time.png?raw=true" width="50%" height="50%"></div><p>所有可运行的任务通过不断地插入操作最终都存储在以时间为顺序的红黑树中（由 sched_entity 对象表示），对处理器需求最多的任务（最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧。 为了公平，CFS调度器会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。这样，树左侧的进程就被给予时间运行了。</p><h4 id="4-3-2-tick中断"><a href="#4-3-2-tick中断" class="headerlink" title="4.3.2 tick中断"></a>4.3.2 tick中断</h4><hr><p>在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。从这里可以看到 CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有调度器都在tick中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。</p><h4 id="4-3-3-红黑树键值计算"><a href="#4-3-3-红黑树键值计算" class="headerlink" title="4.3.3 红黑树键值计算"></a>4.3.3 红黑树键值计算</h4><hr><p>理解CFS的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的CPU时间；二是当前进程的nice值；三是当前的cpu负载。进程已经占用的CPU时间对键值的影响最大，其实很大程度上我们在理解CFS时可以简单地认为键值就等于进程已占用的 CPU时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外CFS规定，nice值为1的进程比nice值为0的进程多获得10%的 CPU时间。在计算键值时也考虑到这个因素，因此nice值越大，键值也越大。</p><p>CFS为每个进程都维护两个重要变量：fair_clock和wait_runtime。这里我们将为每个进程维护的变量称为进程级变量，为每个CPU维护的称作CPU级变量，为每个runqueue维护的称为runqueue级变量。进程插入红黑树的键值即为fair_clock – wait_runtime。其中fair_clock从其字面含义上讲就是一个进程应获得的CPU时间，即等于进程已占用的CPU时间除以当前 runqueue中的进程总数；wait_runtime是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。对于交互式任务，wait_runtime长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。</p><p>红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是O(LogN)</p><h4 id="4-3-4-调度器管理器"><a href="#4-3-4-调度器管理器" class="headerlink" title="4.3.4 调度器管理器"></a>4.3.4 调度器管理器</h4><hr><p>为了支持实时进程，CFS提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23中，CFS实现了两个调度算法，CFS算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用CFS算法。CFS 调度模块（在 kernel/sched_fair.c 中实现）用于以下调度策略：SCHED_NORMAL、SCHED_BATCH 和 SCHED_IDLE。对于 SCHED_RR 和 SCHED_FIFO 策略，将使用实时调度模块（该模块在 kernel/sched_rt.c 中实现）。</p><h4 id="4-3-5-CFS组调度"><a href="#4-3-5-CFS组调度" class="headerlink" title="4.3.5 CFS组调度"></a>4.3.5 CFS组调度</h4><hr><p>CFS组调度（在 2.6.24 内核中引入）是另一种为调度带来公平性的方式，尤其是在处理产生很多其他任务的任务时。 假设一个产生了很多任务的服务器要并行化进入的连接（HTTP 服务器的典型架构）。不是所有任务都会被统一公平对待， CFS 引入了组来处理这种行为。产生任务的服务器进程在整个组中（在一个层次结构中）共享它们的虚拟运行时，而单个任务维持其自己独立的虚拟运行时。这样单个任务会收到与组大致相同的调度时间。您会发现 /proc 接口用于管理进程层次结构，让您对组的形成方式有完全的控制。使用此配置，您可以跨用户、跨进程或其变体分配公平性。</p><p>考虑一个两用户示例，用户 A 和用户 B 在一台机器上运行作业。用户 A 只有两个作业正在运行，而用户 B 正在运行 48 个作业。组调度使 CFS 能够对用户 A 和用户 B 进行公平调度，而不是对系统中运行的 50 个作业进行公平调度。每个用户各拥有 50% 的 CPU 使用。用户 B 使用自己 50% 的 CPU 分配运行他的 48 个作业，而不会占用属于用户 A 的另外 50% 的 CPU 分配。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>构建实现run命令的容器</title>
      <link href="/2019/04/24/write-docker-run/"/>
      <url>/2019/04/24/write-docker-run/</url>
      
        <content type="html"><![CDATA[<p>实现<code>run</code>命令</p><p>构建一个简单版本的<code>run</code>命令，类似于<code>docker run -it [command]</code>，为了了解<code>Docker</code>启动容器的原理，该简单版本的实现参考了<code>runC</code>的实现。</p><hr><p>1.目前的代码文件结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── container</span><br><span class="line">│   ├── container_process.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── main_command.go</span><br><span class="line">├── main.go</span><br><span class="line">├── README.md</span><br><span class="line">└── run.go</span><br></pre></td></tr></table></figure></p><p>2.首先，来看一下入口<code>main</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;github.com/Sirupsen/logrus&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const usage = `my docker is a simple container runtime implement`</span><br><span class="line"></span><br><span class="line">//mydocker run -it /bin/bash</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line">    app.Name = &quot;mydocker&quot;</span><br><span class="line">    app.Usage = usage</span><br><span class="line"></span><br><span class="line">    app.Commands = []cli.Command&#123;</span><br><span class="line">        initCommand,</span><br><span class="line">        runCommand,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置日志格式</span><br><span class="line">    app.Before = func(context *cli.Context) error &#123;</span><br><span class="line">        logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)</span><br><span class="line">        logrus.SetOutput(os.Stdout)</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if err := app.Run(os.Args); err != nil &#123;</span><br><span class="line">        logrus.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 github.com/urfave/cli 提供的命令行工具, 该工具的用法, <a href="/2019/04/22/introducing-urfave-cli/">点此</a>。定义mydocker的两个基本命令,<code>initCommand</code>和<code>runCommand</code>，在app.Before内初始化一下<code>logrus</code>的日志配置。下面看一下，具命令的定义。</p><p>3.<code>runCommand</code> &amp; <code>initCommand</code> 定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//这里定义`runCommand`的`Flags`，其作用类似于命令时使用 -- 来指定参数</span><br><span class="line"></span><br><span class="line">var runCommand = cli.Command&#123;</span><br><span class="line">    Name: &quot;run&quot;,</span><br><span class="line">    Usage: `Create a container with namespace and cgroups limit</span><br><span class="line">           mydocker run -it [command]`,</span><br><span class="line">    Flags: []cli.Flag&#123;</span><br><span class="line">        cli.BoolFlag&#123;</span><br><span class="line">            Name:  &quot;it&quot;,</span><br><span class="line">            Usage: &quot;enable tty&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">    这里是run命令执行的真正函数</span><br><span class="line">    1. 判断参数是否包含command</span><br><span class="line">    2. 获取用户指定的command</span><br><span class="line">    3. 调用 Run function 去准备启动容器</span><br><span class="line">     */</span><br><span class="line">    Action: func(context *cli.Context) error &#123;</span><br><span class="line">        if len(context.Args()) &lt; 1 &#123;</span><br><span class="line">            return fmt.Errorf(&quot;Missing container command&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        cmd := context.Args().Get(0)</span><br><span class="line">        tty := context.Bool(&quot;it&quot;)</span><br><span class="line">        Run(tty, cmd)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义initCommand的具体操作，此操作为内部方法，禁止外部调用</span><br><span class="line">var initCommand = cli.Command&#123;</span><br><span class="line">    Name:  &quot;init&quot;,</span><br><span class="line">    Usage: &quot;Init container process run user&apos;s process in container, Do not call it outside&quot;,</span><br><span class="line">    /**</span><br><span class="line">    1.获取传递过来的command参数</span><br><span class="line">    2.执行容器初始化操作</span><br><span class="line">     */</span><br><span class="line">    Action: func(context *cli.Context) error &#123;</span><br><span class="line">        logrus.Infof(&quot;init come on&quot;)</span><br><span class="line">        cmd := context.Args().Get(0)</span><br><span class="line">        logrus.Infof(&quot;command %s&quot;, cmd)</span><br><span class="line">        err := container.RunContainerInitProcess(cmd, nil)</span><br><span class="line">        return err</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.先来看一下<code>Run</code>和<code>NewParentProcess</code>做了哪些事情。<br>这里是父进程，也就是当前进程执行的内容。</p><ul><li>这里的<code>/proc/self/exe</code>的调用中，<code>/proc/self</code>指的是当前运行进程自己的环境，<code>exec</code>其实就是自己调用了自己，使用这种方式对创建出来的进程初始化。</li><li>后面的<code>args</code>是参数，其中<code>init</code>是传递给本进程的第一个参数，在本例中，其实就会去调用<code>initCommand</code>去初始化进程的一些环境和资源。<code>./mydocker init [command]</code> </li><li>下面的<code>clone</code>参数就是去fork出来一个新的进程，并且使用了<code>namespace</code>隔离新创建的进程和外部环境。</li><li>如果用户指定了 <code>-it</code> 参数，就需要把当前进程的输入输出导入到标准的输入输出上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// conatiner_process.go</span><br><span class="line">package container</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os/exec&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func NewParentProcess(tty bool, command string) *exec.Cmd &#123;</span><br><span class="line">    args := []string&#123;&quot;init&quot;, command&#125;</span><br><span class="line">    cmd := exec.Command(&quot;/proc/self/exe&quot;, args...)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWNET | syscall.CLONE_NEWIPC,</span><br><span class="line">    &#125;</span><br><span class="line">    if tty &#123;</span><br><span class="line">        cmd.Stdin = os.Stdout</span><br><span class="line">        cmd.Stdout = os.Stdout</span><br><span class="line">        cmd.Stderr = os.Stderr</span><br><span class="line">    &#125;</span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// run.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;mydocker/container&quot;</span><br><span class="line">    &quot;github.com/Sirupsen/logrus&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//启动init进程</span><br><span class="line">func Run(tty bool, command string) &#123;</span><br><span class="line">    parent := container.NewParentProcess(tty, command)</span><br><span class="line">    if err := parent.Run(); err != nil &#123;</span><br><span class="line">        logrus.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    parent.Wait()</span><br><span class="line">    os.Exit(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.那么<code>init</code>函数里面发生了什么呢？</p><p>这里的<code>init</code>函数是在容器内执行的，也就是说代码执行到这里，容器所在的进程其实已经创建出来了，这是本容器执行的第一个进程。</p><p>使用<code>mount</code>先去挂载<code>proc</code>文件系统，以便后面通过<code>ps</code>命令去查看当前容器内进程情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// init.go </span><br><span class="line">package container</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/Sirupsen/logrus&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func RunContainerInitProcess(command string, args []string) error &#123;</span><br><span class="line">    logrus.Infof(&quot;command %s&quot;, command)</span><br><span class="line">    defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV</span><br><span class="line">    syscall.Mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;)</span><br><span class="line">    argv := []string&#123;command&#125;</span><br><span class="line">    if err := syscall.Exec(command, argv, os.Environ()); err != nil &#123;</span><br><span class="line">        logrus.Errorf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>MountFlag</code>意思如下：</p><ul><li>MS_NOEXEC在本文件系统中不允许运行其它程序</li><li>MS_NOSUID在本文件系统中运行程序的时候，不允许<code>set-user-ID</code>或<code>set-group-ID</code></li><li>MS_NODEV这个参数自Linux2.4以来，所有mount的系统都会默认设定的</li></ul><p><strong>本函数最后的syscall.Exec，这个系统调用实现了完成初始化并将用户进程运行起来的操作。</strong>下面解释一下这句话的神奇之处。</p><p>首先，使用<code>Docker</code>创建起来一个容器后，会发现容器内的第一个进程，也就是PID为1的那个进程，是指定的前台进程。但是，根据前面所讲，容器启动后的第一个进程不是用户进程，而是<code>init</code>初始化的进程。这个时候通过<code>ps</code>命令就会发现，容器内的第一进程变成了自己的<code>init</code>，这个和预想的不一样。你可能回想，大不了把第一个<code>init</code>进程给<code>kill</code>掉。但是PID为1的进程是不能被<code>kill</code>掉的，如果该进程被<code>kill</code>掉，我们的容器也就退出了。那么有什么办法？这里execve系统调用就可以大显神威了。</p><p>syscall.Exec这个方法，其实最终调用了Kernel的int execve(const char <em>filename,const </em>const argv[],char *const envp[]);这个系统函数。它的作用是执行当前的filename对应的程序，会覆盖当前进程的镜像、数据和堆栈等信息，包括PID，这些都会将要运行的进程覆盖掉。也就是说，调用这个方法，将用户指定的进程运行起来，把最初的<code>init</code>进程给替换掉，这样当进入到容器内部的时候，就会发现容器内的第一个程序就是我们指定的进程了[command]。这其实也是目前Docker使用的容器引擎<code>runC</code>的实现方式之一。</p><p>6.流程图如图所示:</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/docker/runc.png?raw=true" width="50%" height="50%"></div><br><div align="center">图1：mydocker 启动流程</div><p>7.下面编译运行一下。</p><blockquote></blockquote><p>#使用 go build，在mydocker目录下进行编译</p><blockquote></blockquote><p>#使用 <code>./mydocker run -it /bin/sh</code> 命令，其中 <code>-it</code> 表示想要以交互的形式运行容器， <code>/bin/bash</code> 为指定容器的第一个进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/home/meichaofan/peek-a-boo/src/mydocker# ./mydocker run -it /bin/sh</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;init come on&quot;,&quot;time&quot;:&quot;2019-04-24T21:09:35-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/sh&quot;,&quot;time&quot;:&quot;2019-04-24T21:09:35-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/sh&quot;,&quot;time&quot;:&quot;2019-04-24T21:09:35-07:00&quot;&#125;</span><br><span class="line"># ps aux</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0   4508   756 pts/0    S    21:09   0:00 /bin/sh</span><br><span class="line">root          5  0.0  0.1  39104  3188 pts/0    R+   21:09   0:00 ps aux</span><br></pre></td></tr></table></figure></p><p>在容器运行 <code>ps -aux</code> 时，可以发现 <code>/bin/sh</code> 进程是容器内的第一个进程，PID=1。而 <code>ps -aux</code> 是PID为1的进程创建出来的。</p><blockquote></blockquote><p>这里的 <code>/bin/sh</code> 是一个会在前台一直运行的进程。如果指定一个运行就退出的进程会是什么效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/home/meichaofan/peek-a-boo/src/mydocker# ./mydocker run -it /bin/ls</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;init come on&quot;,&quot;time&quot;:&quot;2019-04-24T21:19:05-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/ls&quot;,&quot;time&quot;:&quot;2019-04-24T21:19:05-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/ls&quot;,&quot;time&quot;:&quot;2019-04-24T21:19:05-07:00&quot;&#125;</span><br><span class="line">container  main_command.go  main.go  mydocker  README.md  run.go</span><br></pre></td></tr></table></figure></p><p>由于没有<code>chroot</code>，所以目前的系统文件是继承宿主主机的系统文件，运行了一下 <code>ls</code> 命令，当容器启动起来以后，打印出了当前目录内容，然后便退出了，这个结果和Docker要求容器必须有一个一直在前台运行的进程的要求是一致的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> runC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux相关软件和命令</title>
      <link href="/2019/04/23/about-linux-software/"/>
      <url>/2019/04/23/about-linux-software/</url>
      
        <content type="html"><![CDATA[<p>这里主要介绍Linux相关软件安装和日常使用命令</p><hr><ul><li><a href="/2019/04/23/httpie-a-http-client/">HTTPie - 一款http客户端工具</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPie - 一款http客户端</title>
      <link href="/2019/04/23/httpie-a-http-client/"/>
      <url>/2019/04/23/httpie-a-http-client/</url>
      
        <content type="html"><![CDATA[<p>一款http客户端</p><hr><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>具表达力和直观语法</li><li>格式化的及彩色化的终端输出</li><li>内置JSON支持</li><li>表单和文件上传</li><li>HTTPS、代理和认证</li><li>任意请求数据</li><li>自定义头部</li><li>持久化会话</li><li>类似于wget的下载</li><li>支持Python2.7 和 3.x</li></ul><h3 id="在Linux下安装Httpie"><a href="#在Linux下安装Httpie" class="headerlink" title="在Linux下安装Httpie"></a>在Linux下安装Httpie</h3><ol><li><p>Debian/Ubuntu系统，使用<code>apt-get</code>或<code>apt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install httpie</span><br></pre></td></tr></table></figure></li><li><p>RHEL/CentOs系统，使用<code>yum</code>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install httpie</span><br></pre></td></tr></table></figure></li></ol><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li><p>如何使用HTTPie请求URL？<br>httpie的基本用法是将URL作为参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~$ http 2daygeek.com</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">CF-RAY: 4cbdc9a7b85322a0-LAX</span><br><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Apr 2019 06:30:15 GMT</span><br><span class="line">Expires: Tue, 23 Apr 2019 07:30:15 GMT</span><br><span class="line">Location: https://2daygeek.com/</span><br><span class="line">Server: cloudflare</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure></li><li><p>如何使用HTTPie下载文件<br>带 <code>--download</code> 参数，用来下载文件，类似于wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~$ http --download https://www.2daygeek.com/wp-content/uploads/2019/04/Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">CF-Cache-Status: HIT</span><br><span class="line">CF-RAY: 4cbdcfbafb53540e-LAX</span><br><span class="line">Cache-Control: public, max-age=7200</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 32066</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Date: Tue, 23 Apr 2019 06:34:23 GMT</span><br><span class="line">Expect-CT: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot;</span><br><span class="line">Expires: Tue, 23 Apr 2019 08:34:23 GMT</span><br><span class="line">Last-Modified: Mon, 08 Apr 2019 04:54:25 GMT</span><br><span class="line">Server: cloudflare</span><br><span class="line">Set-Cookie: __cfduid=dee8965dcfafc633c5463965e0c40522d1556001263; expires=Wed, 22-Apr-20 06:34:23 GMT; path=/; domain=.2daygeek.com; HttpOnly; Secure</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line"></span><br><span class="line">Downloading 31.31 kB to &quot;Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png&quot;</span><br><span class="line">Done. 31.31 kB in 0.55747s (56.17 kB/s)</span><br><span class="line">meichaofan@ubuntu1:~$ ls</span><br><span class="line">Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png  package  peek-a-boo</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>-o</code> 参数用不同的名称保存输出文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~$ http --download https://www.2daygeek.com/wp-content/uploads/2019/04/Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png -o Anbox-1.png</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">CF-Cache-Status: HIT</span><br><span class="line">CF-RAY: 4cbdd1493c0e5047-LAX</span><br><span class="line">Cache-Control: public, max-age=7200</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 32066</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Date: Tue, 23 Apr 2019 06:35:27 GMT</span><br><span class="line">Expect-CT: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot;</span><br><span class="line">Expires: Tue, 23 Apr 2019 08:35:27 GMT</span><br><span class="line">Last-Modified: Mon, 08 Apr 2019 04:54:25 GMT</span><br><span class="line">Server: cloudflare</span><br><span class="line">Set-Cookie: __cfduid=d4ac029dc64db0797db8e607d6a8568341556001327; expires=Wed, 22-Apr-20 06:35:27 GMT; path=/; domain=.2daygeek.com; HttpOnly; Secure</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line"></span><br><span class="line">Downloading 31.31 kB to &quot;Anbox-1.png&quot;</span><br><span class="line">Done. 31.31 kB in 0.28450s (110.07 kB/s)</span><br><span class="line">meichaofan@ubuntu1:~$ ls</span><br><span class="line">Anbox-1.png  package  peek-a-boo</span><br></pre></td></tr></table></figure></li><li><p>如何使用 HTTPie 恢复部分下载？<br>可以使用 <code>-c</code> 参数的HTTPie继续下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http --download --continue https://speed.hetzner.de/100MB.bin -o 100MB.bin</span><br></pre></td></tr></table></figure></li><li><p>如何使用 HTTPie 上传文件？<br>你可以通过使用带有小于号 <code>&lt;</code> 的 HTTPie 命令上传文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http https://transfer.sh &lt; Anbox-1.png</span><br></pre></td></tr></table></figure></li><li><p>如何使用带有重定向符号 <code>&gt;</code> 下载文件？<br>你可以使用带有重定向 <code>&gt;</code> 符号的 HTTPie 命令下载文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ http https://www.2daygeek.com/wp-content/uploads/2019/03/How-To-Install-And-Enable-Flatpak-Support-On-Linux-1.png &gt; Flatpak.png</span><br><span class="line">$ ls -ltrh Flatpak.png</span><br><span class="line">-rw-r--r-- 1 root root 47K Apr  9 01:44 Flatpak.png</span><br></pre></td></tr></table></figure></li><li><p>发送一个 HTTP GET 请求？<br>您可以在请求中发送 HTTP GET 方法。GET 方法会使用给定的 URI，从给定服务器检索信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http GET httpie.org</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">CF-RAY: 4c4a83a3f90dcbe6-SIN</span><br><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 09 Apr 2019 06:44:44 GMT</span><br><span class="line">Expires: Tue, 09 Apr 2019 07:44:44 GMT</span><br><span class="line">Location: https://httpie.org/</span><br><span class="line">Server: cloudflare</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure></li><li><p>提交表单<br>使用以下格式提交表单。POST 请求用于向服务器发送数据，例如客户信息、文件上传等。要使用 HTML 表单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http -f POST Ubuntu18.2daygeek.com hello=&apos;World&apos;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 3138</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 09 Apr 2019 06:48:12 GMT</span><br><span class="line">ETag: &quot;2aa6-5844bf1b047fc-gzip&quot;</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Last-Modified: Sun, 17 Mar 2019 15:29:55 GMT</span><br><span class="line">Server: Apache/2.4.29 (Ubuntu)</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure><p>运行下面的指令以查看正在发送的请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http -v Ubuntu18.2daygeek.com</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: ubuntu18.2daygeek.com</span><br><span class="line">User-Agent: HTTPie/0.9.8</span><br><span class="line">hello=World</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 3138</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 09 Apr 2019 06:48:30 GMT</span><br><span class="line">ETag: &quot;2aa6-5844bf1b047fc-gzip&quot;</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Last-Modified: Sun, 17 Mar 2019 15:29:55 GMT</span><br><span class="line">Server: Apache/2.4.29 (Ubuntu)</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍urfave/cli 一款构建命令行app的go包</title>
      <link href="/2019/04/22/introducing-urfave-cli/"/>
      <url>/2019/04/22/introducing-urfave-cli/</url>
      
        <content type="html"><![CDATA[<p>一个简单，快速构建基于命令行应用的工具包<br><a href="https://github.com/urfave/cli" target="_blank" rel="noopener">https://github.com/urfave/cli</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/urfave/cli</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.Cli的哲学之一是API应该有趣和充满惊喜，所以cli应用程序可以做到在<code>main()</code>函数里只有一行代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    err := cli.NewApp().Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.1.运行并输出一些默认信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   one - A new cli application</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   one [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.0.0</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">     help, h  Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --help, -h     show help</span><br><span class="line">   --version, -v  print the version</span><br></pre></td></tr></table></figure></p><p>2.设置执行动作，和输出一些帮助文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line">    app.Name = &quot;boom&quot;</span><br><span class="line">    app.Usage = &quot;make an explosive entrance&quot;</span><br><span class="line">    app.Action = func(c *cli.Context) error &#123;</span><br><span class="line">        fmt.Println(&quot;boom! I say!&quot;)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := app.Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.1.编译并运行 go build . &amp;&amp; ./main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/two$ go run main.go</span><br><span class="line">boom! I say!</span><br></pre></td></tr></table></figure></p><p>2.2.运行 ./main -h , 可以看到，显示有相关文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/two$ ./main -h</span><br><span class="line">NAME:</span><br><span class="line">   boom - make an explosive entrance</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   main [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.0.0</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">     help, h  Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --help, -h     show help</span><br><span class="line">   --version, -v  print the version</span><br></pre></td></tr></table></figure></p><p>3.支持参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">    app.Action = func(ctx *cli.Context) error &#123;</span><br><span class="line">        fmt.Printf(&quot;Hello %q\n&quot;, ctx.Args().Get(0))</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := app.Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.1.输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/three$ ./main huanhuan</span><br><span class="line">Hello &quot;huanhuan&quot;</span><br></pre></td></tr></table></figure></p><p>4.支持标识位 flags<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">    app.Flags = []cli.Flag&#123;</span><br><span class="line">        cli.StringFlag&#123;</span><br><span class="line">            Name:  &quot;lang&quot;,</span><br><span class="line">            Value: &quot;english&quot;,</span><br><span class="line">            Usage: &quot;language for the greeting&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.Action = func(ctx *cli.Context) error &#123;</span><br><span class="line"></span><br><span class="line">        name := &quot;huanhuan&quot;</span><br><span class="line">        if ctx.NArg() &gt; 0 &#123;</span><br><span class="line">            name = ctx.Args().Get(0)</span><br><span class="line">            fmt.Printf(&quot;there have %d args&quot;,len(ctx.Args()))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ctx.String(&quot;lang&quot;) == &quot;spanish&quot; &#123;</span><br><span class="line">            fmt.Println(&quot;Hala&quot;, name)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Println(&quot;Hello&quot;, name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := app.Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.1.注：Flag和argumens要分清楚 ./main –lang spanish aa bb cc ，其中有3个参数，1个标识<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/four$ ./main --lang spanish aa bb cc</span><br><span class="line">there have 3 args</span><br><span class="line">Hala aa</span><br></pre></td></tr></table></figure></p><p>5.还可以将flag值注入到变量中，通过变量来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;log&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com/urfave/cli&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var language string</span><br><span class="line"></span><br><span class="line">  app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">  app.Flags = []cli.Flag &#123;</span><br><span class="line">    cli.StringFlag&#123;</span><br><span class="line">      Name:        &quot;lang&quot;,</span><br><span class="line">      Value:       &quot;english&quot;,</span><br><span class="line">      Usage:       &quot;language for the greeting&quot;,</span><br><span class="line">      Destination: &amp;language,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.Action = func(c *cli.Context) error &#123;</span><br><span class="line">    name := &quot;someone&quot;</span><br><span class="line">    if c.NArg() &gt; 0 &#123;</span><br><span class="line">      name = c.Args()[0]</span><br><span class="line">    &#125;</span><br><span class="line">    if language == &quot;spanish&quot; &#123;</span><br><span class="line">      fmt.Println(&quot;Hola&quot;, name)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fmt.Println(&quot;Hello&quot;, name)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err := app.Run(os.Args)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.指定flag的值，这些值的占位符用后引号表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;log&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com/urfave/cli&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">  app.Flags = []cli.Flag&#123;</span><br><span class="line">    cli.StringFlag&#123;</span><br><span class="line">      Name:  &quot;config, c&quot;,</span><br><span class="line">      Usage: &quot;Load configuration from `FILE`&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err := app.Run(os.Args)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.1.我们将会在帮助中看到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--config FILE, -c FILE   Load configuration from FILE</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linix之间几种文件传输方式</title>
      <link href="/2019/04/22/tranfer-in-linux/"/>
      <url>/2019/04/22/tranfer-in-linux/</url>
      
        <content type="html"><![CDATA[<p>当我们需要在类UNIX主机间，互传文件，下面几个命令可以排上用场了</p><hr><ol><li><p>rsync</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz user@src_host:/path/to/file ./ --delete</span><br></pre></td></tr></table></figure></li><li><p>scp</p></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu</title>
      <link href="/2019/04/22/about-ubuntu/"/>
      <url>/2019/04/22/about-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>这是关于Ubuntu系统运维的</p><hr><ul><li><a href="/2019/04/22/change-ip-on-ubuntu/">ubuntu系统修改网卡ip</a></li><li><a href="/2019/04/29/ubuntu-change-runlevel/">ubuntu系统修改默认运行级别</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu系统修改网卡ip</title>
      <link href="/2019/04/22/change-ip-on-ubuntu/"/>
      <url>/2019/04/22/change-ip-on-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>需求：将ubuntu系统<code>ens33</code>网卡ip修改为<code>192.168.244.140</code></p><hr><p>1.编辑<code>/etc/network/interfaces</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu:~$ cat /etc/network/interfaces</span><br><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 新增内容</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">address 192.168.244.140</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.244.2</span><br></pre></td></tr></table></figure><p>2.重启网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用docker搭建samba目录共享</title>
      <link href="/2019/04/22/docker-run-samba/"/>
      <url>/2019/04/22/docker-run-samba/</url>
      
        <content type="html"><![CDATA[<p>1.下载samba镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dperson/samba</span><br></pre></td></tr></table></figure></p><p>2.启动镜像，具体配置看文档，但重要的配置是一下的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name samba \</span><br><span class="line">-it -p 139:139 -p 445:445 \</span><br><span class="line">-v /home/meichaofan:/home/meichaofan \</span><br><span class="line">-v /etc/passwd:/etc/passwd \</span><br><span class="line">-v /etc/group:/etc/group \</span><br><span class="line">-d dperson/samba \</span><br><span class="line">-u &quot;meichaofan;huanhuan0921&quot; \</span><br><span class="line">-s &quot;meichaofan home;/home/meichaofan;yes;no;no;all;none&quot;</span><br></pre></td></tr></table></figure></p><p>3.替换samba的启动用户，与权限相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it samba sed -i &apos;s/force user = smbuser/force user = meichaofan/g&apos; /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></p><p>3.替换samba的启动组，与权限相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it samba sed -i &apos;s/force group = users/force group = meichaofan/g&apos; /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></p><p>4.重启samba<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart samba</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 存储驱动之 overlay</title>
      <link href="/2019/04/21/docker-overlay/"/>
      <url>/2019/04/21/docker-overlay/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> overlayFs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 存储驱动之 overlay2</title>
      <link href="/2019/04/21/docker-overlay2/"/>
      <url>/2019/04/21/docker-overlay2/</url>
      
        <content type="html"><![CDATA[<h3 id="overlay2中镜像和容器的磁盘结构"><a href="#overlay2中镜像和容器的磁盘结构" class="headerlink" title="overlay2中镜像和容器的磁盘结构"></a>overlay2中镜像和容器的磁盘结构</h3><p>docker pull ubuntu:14.04下载了包含4层的镜像，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# docker pull ubuntu:14.04</span><br><span class="line">14.04: Pulling from library/ubuntu</span><br><span class="line">e082d4499130: Pull complete </span><br><span class="line">371450624c9e: Pull complete </span><br><span class="line">c8a555b3a57c: Pull complete </span><br><span class="line">1456d810d42e: Pull complete </span><br><span class="line">Digest: sha256:6612de24437f6f01d6a2988ed9a36b3603df06e8d2c0493678f3ee696bc4bb2d</span><br><span class="line">Status: Downloaded newer image for ubuntu:14.04</span><br></pre></td></tr></table></figure></p><p>可以在/var/lib/docker/overlay2中看到，有5个目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www overlay2]# ll -h</span><br><span class="line">total 28K</span><br><span class="line">drwx------ 4 root root 4.0K Apr 21 00:32 0734cd8060d194cf3db93162b421e4f245151920f0b9acda5313ec9f671bc5cc</span><br><span class="line">drwx------ 3 root root 4.0K Apr 21 00:32 153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3</span><br><span class="line">drwx------ 4 root root 4.0K Apr 21 00:32 658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3</span><br><span class="line">drwx------ 4 root root 4.0K Apr 21 00:32 9ff7c96e688b25a7353c83904d791eae357c2e16315ecbe602009678965ce761</span><br><span class="line">drwx------ 2 root root 4.0K Apr 21 00:33 l</span><br></pre></td></tr></table></figure></p><h3 id="l目录的内容"><a href="#l目录的内容" class="headerlink" title="l目录的内容"></a><strong>l</strong>目录的内容</h3><p>其中<strong>l</strong>目录中包含了很多软连接，使用短名称指向了其它层。短名称用于避免mount参数时达到页面大小的限制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www overlay2]# ll l/</span><br><span class="line">total 24</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 2AQ2F7X67IL4TATXIIYO62CM67 -&gt; ../153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 HMOMCX3OAMM4K6KUZORQ7NTIG4 -&gt; ../9ff7c96e688b25a7353c83904d791eae357c2e16315ecbe602009678965ce761/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 JZPHZPG7ZLX7GTKCFVHQZDEF43 -&gt; ../658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 OJ5PMEVISSBQ4X4N2U66YEE6IH -&gt; ../0734cd8060d194cf3db93162b421e4f245151920f0b9acda5313ec9f671bc5cc/diff</span><br></pre></td></tr></table></figure></p><h3 id="mount-查看容器-镜像的层次关系"><a href="#mount-查看容器-镜像的层次关系" class="headerlink" title="mount 查看容器/镜像的层次关系"></a>mount 查看容器/镜像的层次关系</h3><p><strong>现在起一个容器，它会在rootfs层上，加上init层（环境相关）和容器层（读写）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure></p><p>查看mount相关信息，可以看出层级关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mount -l | grep overlay2</span><br><span class="line">/dev/vda1 on /var/lib/docker/overlay2 type ext3 (rw,relatime,data=ordered)</span><br><span class="line">overlay on /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/MXQORLOJXLIRFVZ3R26TNWWURM:/var/lib/docker/overlay2/l/HMOMCX3OAMM4K6KUZORQ7NTIG4:/var/lib/docker/overlay2/l/OJ5PMEVISSBQ4X4N2U66YEE6IH:/var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43:/var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67,upperdir=/var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/diff,workdir=/var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/work)</span><br></pre></td></tr></table></figure></p><p>整理mount信息,如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">merged:</span><br><span class="line">    /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/merged (联合挂载到此目录下)</span><br><span class="line"></span><br><span class="line">workdir:</span><br><span class="line">    /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/work </span><br><span class="line"></span><br><span class="line">upperdir:</span><br><span class="line">    /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/diff (第六层 rw)</span><br><span class="line"></span><br><span class="line">lowerdir:</span><br><span class="line">    /var/lib/docker/overlay2/l/MXQORLOJXLIRFVZ3R26TNWWURM (第5层 init层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/HMOMCX3OAMM4K6KUZORQ7NTIG4 (第四层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/OJ5PMEVISSBQ4X4N2U66YEE6IH (第三层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43 (第二层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67 (rootfs 第一层 ro)</span><br></pre></td></tr></table></figure></p><h3 id="各个rootfs层文件内容介绍"><a href="#各个rootfs层文件内容介绍" class="headerlink" title="各个rootfs层文件内容介绍"></a>各个rootfs层文件内容介绍</h3><p>查看rootfs第一层的目录信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 /var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67 -&gt; ../153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/diff</span><br><span class="line"></span><br><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 21 root root 4096 Apr 21 00:32 diff</span><br><span class="line">-rw-r--r--  1 root root   26 Apr 21 00:32 link</span><br></pre></td></tr></table></figure></p><p>可以看到，最低层只有两个文件，一个是diff，存放当前层的文件和目录，link则和<code>l</code>目录的软链接向对应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/diff</span><br><span class="line">total 76</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:46 bin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 boot</span><br><span class="line">drwxr-xr-x  3 root root 4096 Mar  5 12:45 dev</span><br><span class="line">drwxr-xr-x 61 root root 4096 Mar  5 12:46 etc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 home</span><br><span class="line">drwxr-xr-x 12 root root 4096 Mar  5 12:46 lib</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 lib64</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 media</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 mnt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 opt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 proc</span><br><span class="line">drwx------  2 root root 4096 Mar  5 12:46 root</span><br><span class="line">drwxr-xr-x  7 root root 4096 Mar  5 12:46 run</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:46 sbin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 srv</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar 13  2014 sys</span><br><span class="line">drwxrwxrwt  2 root root 4096 Mar  5 12:46 tmp</span><br><span class="line">drwxr-xr-x 10 root root 4096 Mar  5 12:45 usr</span><br><span class="line">drwxr-xr-x 11 root root 4096 Mar  5 12:46 var</span><br><span class="line"></span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/link </span><br><span class="line">2AQ2F7X67IL4TATXIIYO62CM67</span><br></pre></td></tr></table></figure></p><p>查看rootfs第二层信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 /var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43 -&gt; ../658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3/diff</span><br><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x 6 root root 4096 Apr 21 00:32 diff</span><br><span class="line">-rw-r--r-- 1 root root   26 Apr 21 00:32 link</span><br><span class="line">-rw-r--r-- 1 root root   28 Apr 21 00:32 lower</span><br><span class="line">drwx------ 2 root root 4096 Apr 21 00:32 work</span><br></pre></td></tr></table></figure></p><p>第二层有四个文件，diff 和 link如上所序一样。lower文件的内容是当前层下面的rootfs的软连接名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 第二层rootfs的lower内容</span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3/lower </span><br><span class="line">l/2AQ2F7X67IL4TATXIIYO62CM67</span><br><span class="line"></span><br><span class="line">#第三层rootfs的lower内容</span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/0734cd8060d194cf3db93162b421e4f245151920f0b9acda5313ec9f671bc5cc/lower </span><br><span class="line">l/JZPHZPG7ZLX7GTKCFVHQZDEF43:l/2AQ2F7X67IL4TATXIIYO62CM67</span><br><span class="line"></span><br><span class="line">#第四层rootfs的lower内容</span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/9ff7c96e688b25a7353c83904d791eae357c2e16315ecbe602009678965ce761/lower </span><br><span class="line">l/OJ5PMEVISSBQ4X4N2U66YEE6IH:l/JZPHZPG7ZLX7GTKCFVHQZDEF43:l/2AQ2F7X67IL4TATXIIYO62CM67</span><br></pre></td></tr></table></figure></p><p>最顶层，也就是upperdir层，看一下它的文件目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15]# ls</span><br><span class="line">diff  link  lower  merged  work</span><br></pre></td></tr></table></figure></p><p>upperdir是容器层，是可读写的。在容器中所有修改文件操作最后都在upperdir的<code>diff</code>目录体现，并合并到<code>merged</code>目录下。<code>merged</code>目录是联合后挂载的目录，也是容器的文件系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 假如我docker run -it ubuntu:14.04 /bin/bash 启动了一个容器，然后再其/(根目录)下创建一个Test目录,并在/root目录下新建了一个aa文件，并删除了/bin/ss文件。我们现在看一下upperdir的`diff`目录</span><br><span class="line"></span><br><span class="line">[root@www bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15]# tree diff/</span><br><span class="line">diff/</span><br><span class="line">├── bin</span><br><span class="line">│   └── ss</span><br><span class="line">├── root</span><br><span class="line">│   └── aa</span><br><span class="line">└── Test</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br><span class="line"></span><br><span class="line"># 在看一个merged目录，它是叠加后一个完整的文件系统目录结构</span><br><span class="line">[root@www bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15]# ls merged/</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  Test  tmp  usr  var</span><br></pre></td></tr></table></figure></p><h3 id="OverlayFS-constructs"><a href="#OverlayFS-constructs" class="headerlink" title="OverlayFS constructs"></a>OverlayFS constructs</h3><p>OverlayFS将单个Linux主机上的两个目录合并成一个目录。这些目录被称为层，统一过程被称为联合挂载。OverlayFS底层目录称为lowerdir， 高层目录称为upperdir。合并统一视图称为merged。当需要修改一个文件时，使用CoW将文件从只读的Lower复制到可写的Upper进行修改，结果也保存在Upper层。在Docker中，底下的只读层就是image，可写层就是Container</p><p>下图分层图，镜像层是lowdir，容器层是upperdir，统一的视图层是merged层</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/docker/overlay_constructs.jpg?raw=true" width="50%" height="50%"></div><br><div align="center">OverlayFs constructs</div>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> overlay2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Docker CE</title>
      <link href="/2019/04/20/install-docker/"/>
      <url>/2019/04/20/install-docker/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官网安装文档</a></p><h3 id="卸载老版本"><a href="#卸载老版本" class="headerlink" title="卸载老版本"></a>卸载老版本</h3><p>老版本的Docker，以前叫做<code>docker</code>,<code>docker.io</code>和<code>docker-engine</code>，如果系统里安装了它们，就先卸载掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></p><h3 id="支持的存储系统"><a href="#支持的存储系统" class="headerlink" title="支持的存储系统"></a>支持的存储系统</h3><p>Docker CE在Ubuntu上支持<code>overlay2</code>，<code>aufs</code>,和<code>btrfs</code>文件系统。在Linux内核4.0或更高的内核版本上，默认使用<code>overlay2</code>文件系统，它的性能能高于<code>aufs</code>。如果非要使用<code>aufs</code>，请见<a href>配置Docker CE使用aufs文件系统</a>。</p><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><h4 id="1-使用apt-repository"><a href="#1-使用apt-repository" class="headerlink" title="1.使用apt repository"></a>1.使用apt repository</h4><p><strong>添加仓库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 更新 `apt`</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 安装一些必要的软件</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line"></span><br><span class="line"># 下载Docker官方GPG key</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># 检验指纹 `9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">    </span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br><span class="line"></span><br><span class="line"># 添加仓库</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></p><p><strong>安装Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 默认安装最新版本</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"># 可以安装指定版本</span><br><span class="line"># 1.查看可用版本</span><br><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"># 2.安装指定版本</span><br><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure></p><h4 id="2-使用deb包安装"><a href="#2-使用deb包安装" class="headerlink" title="2.使用deb包安装"></a>2.使用deb包安装</h4><p>1.去 <a href="https://download.docker.com/linux/ubuntu/dists/" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu/dists/</a> 网站，选择合适的<code>.deb</code>文件<br>2.安装<code>.deb</code>包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i /path/to/package.deb</span><br></pre></td></tr></table></figure></p><h4 id="3-使用shell脚本安装"><a href="#3-使用shell脚本安装" class="headerlink" title="3.使用shell脚本安装"></a>3.使用shell脚本安装</h4><ol><li>脚本在 get.docker.com</li><li>不建议在生产环境直接使用脚本安装docker</li><li>安装步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line">&lt;output truncated&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="添加非root用户到docker组"><a href="#添加非root用户到docker组" class="headerlink" title="添加非root用户到docker组"></a>添加非root用户到docker组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker your-user</span><br></pre></td></tr></table></figure><h3 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h3><p>1.卸载Docker CE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure></p><p>2.镜像、数据卷、容器和一些自定义的配置文件不会自动删除，需要手动删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker运维相关</title>
      <link href="/2019/04/20/about-use-docker/"/>
      <url>/2019/04/20/about-use-docker/</url>
      
        <content type="html"><![CDATA[<p>记录Docker在日常学习和工作中的相关积累</p><hr><ul><li><p>Docker运维</p><ul><li>安装Docker</li></ul></li><li><p>Image相关</p></li><li><p>Unionfs<br> *overlay2</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手写docker</title>
      <link href="/2019/04/20/write-docker-self/"/>
      <url>/2019/04/20/write-docker-self/</url>
      
        <content type="html"><![CDATA[<p>Docker目前是后端服务中最火的技术之一，读这本书《自己动手写docker》，对自己来说，主要是从原理上熟悉docker，顺便复习go语言</p><hr><ul><li><p>容器技术的发展</p><ul><li>docker VS 虚拟机</li></ul></li><li><p>基础技术</p><ul><li>docker namespace<ul><li>UTS</li><li>USER</li></ul></li><li>docker cgroup</li><li>aufs</li></ul></li><li><p>构建容器</p><ul><li><a href="/2019/04/24/write-docker-run/">构建实现run命令的容器</a></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解容器镜像</title>
      <link href="/2019/04/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/"/>
      <url>/2019/04/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Namespace和Cgroups"><a href="#Namespace和Cgroups" class="headerlink" title="Namespace和Cgroups"></a>Namespace和Cgroups</h2><p>正如前面所讲，“容器的本质只是一个特殊的进程”。主要是利用Namespace和Cgroup的特性。正如前面所讲，Namespace的作用是“隔离”，它让应用程序只能看到Namespace内的“世界”；而Cgroups的作用是“限制”，它限制“世界”使用某些资源。经过这么一折腾，进程就被“装”在了一个与世隔绝的房间里，而这些房间就是Paas项目赖以生存的应用“沙盒”。</p><h2 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h2><p>可是，还有一个问题不知道你有没有仔细思考过：<strong>这个房间四周虽然有了墙，但是如果容器进程低头一看地面，又是怎样一副景象呢？</strong></p><p>可能你立即想到了,这一定是一个Mount Namespace的问题：容器里的应用进程，理应当看到了一份完全独立的文件系统，这样它就可以在自己容器目录(/tmp)下进行操作，而完全不受宿主主机以及其他容器的影响。</p><p>那么，真实情况是这样吗？</p><p>“左耳朵耗子”叔在多年前写的一篇<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">关于 Docker 基础知识的博客</a>里，曾经介绍过一段小程序。这段小程序的作用是，在创建子进程时开启指定的 Namespace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/mount.h&gt; </span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">  &quot;/bin/bash&quot;,</span><br><span class="line">  NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;  </span><br><span class="line">  printf(&quot;Container - inside the container!\n&quot;);</span><br><span class="line">  execv(container_args[0], container_args);</span><br><span class="line">  printf(&quot;Something&apos;s wrong!\n&quot;);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Parent - start a container!\n&quot;);</span><br><span class="line">  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , NULL);</span><br><span class="line">  waitpid(container_pid, NULL, 0);</span><br><span class="line">  printf(&quot;Parent - container stopped!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是：在main函数中，通过clone()系统调用创建一个新的子进程 container_main，并且声明要为它启用Mount Namespace（即：CLONE_NEWNS标志）</p><p>而这个子进程执行的，是一个“/bin/bash”程序，也就是一个 shell。所以这个 shell 就运行在了 Mount Namespace 的隔离环境中。</p><p>编译运行这个程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make ns</span><br><span class="line">$ ./ns</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br></pre></td></tr></table></figure></p><p>这样，我们就进入了这个“容器”当中。可是，如果在“容器”里执行一下 ls 指令的话，我们就会发现一个有趣的现象： /tmp 目录下的内容跟宿主机的内容是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /tmp</span><br><span class="line"># 你会看到好多宿主机的文件</span><br></pre></td></tr></table></figure><p>也就是说：</p><blockquote><p>即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。</p></blockquote><p>这是怎么回事呢？</p><p>其实这并不难理解：Mount Namespace修改的，是容器进程对“挂载点”的认知。但是这就意味着，只有在“挂载点”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器进程挂载点是直接继承宿主主机的各个挂载点。</p><p>这时，你可能已经想到了一个解决办法：创建新进程时，除了声明要启用 Mount Namespace 之外，我们还可以告诉容器进程，有哪些目录需要重新挂载，就比如这个 /tmp 目录。于是，我们在容器进程执行前可以添加一步重新挂载 /tmp 目录的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Container - inside the container!\n&quot;);</span><br><span class="line">  // 如果你的机器的根目录的挂载类型是 shared，那必须先重新挂载根目录</span><br><span class="line">  // mount(&quot;&quot;, &quot;/&quot;, NULL, MS_PRIVATE, &quot;&quot;);</span><br><span class="line">  mount(&quot;none&quot;, &quot;/tmp&quot;, &quot;tmpfs&quot;, 0, &quot;&quot;);</span><br><span class="line">  execv(container_args[0], container_args);</span><br><span class="line">  printf(&quot;Something&apos;s wrong!\n&quot;);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在修改后的代码里，我在容器进程启动之前，加上了一句 mount(“none”, “/tmp”, “tmpfs”, 0, “”) 语句。就这样，我告诉了容器以 tmpfs（内存盘）格式，重新挂载了 /tmp 目录。</p><p>这段修改后的代码，编译执行后的结果又如何呢？我们可以试验一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns ns.c</span><br><span class="line">$ ./ns</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">$ ls /tmp</span><br></pre></td></tr></table></figure><p>可以看到，这次 /tmp 变成了一个空目录，这意味着重新挂载生效了。我们可以用 mount -l 检查一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount -l | grep tmpfs</span><br><span class="line">none on /tmp type tmpfs (rw,relatime)</span><br></pre></td></tr></table></figure><p>可以看到，容器里的 /tmp 目录是以 tmpfs 方式单独挂载的。</p><p>更重要的是，因为我们创建的新进程启用了 Mount Namespace，所以这次重新挂载的操作，只在容器进程的 Mount Namespace 中有效。如果在宿主机上用 mount -l 来检查一下这个挂载，你会发现它是不存在的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机上</span><br><span class="line">$ mount -l | grep tmpfs</span><br></pre></td></tr></table></figure><p>这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</p><p>可是，作为一个普通用户，我们希望的是一个更友好的情况：每当创建一个新容器时，我希望容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统。怎么才能做到这一点呢？</p><p>不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p><p>为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls /“ 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。</p><p>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</p><p>所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br><span class="line">bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var</span><br></pre></td></tr></table></figure><p>而你进入容器之后执行的 /bin/bash，就是 /bin 目录下的可执行文件，与宿主机的 /bin/bash 完全不同。</p><p>现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p><ul><li>启用 Linux Namespace 配置；</li><li>设置指定的 Cgroups 参数；</li><li>切换进程的根目录（Change Root）。</li></ul><p>这样，一个完整的容器就诞生了。不过，Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。这两个系统调用虽然功能类似，但是也有细微的区别，这一部分小知识就交给你课后去探索了。</p><h2 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h2><p>另外，需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p><p>所以说，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。<br>那么，对于容器来说，这个操作系统的“灵魂”又在哪里呢？<br>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核。</p><p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</p><p>这也是容器相比于虚拟机的主要缺陷之一：毕竟后者不仅有模拟出来的硬件机器充当沙盒，而且每个沙盒里还运行着一个完整的 Guest OS 给应用随便折腾。</p><p>不过，正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性。</p><p>什么是容器的“一致性”呢？</p><p>我在专栏的第一篇文章《小鲸鱼大事记（一）：初出茅庐》中曾经提到过：由于云端与本地服务器环境不同，应用的打包过程，一直是使用 PaaS 时最“痛苦”的一个步骤。</p><p>但有了容器之后，更准确地说，有了容器镜像（即 rootfs）之后，这个问题被非常优雅地解决了。</p><p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</p><p>事实上，对于大多数开发者而言，他们对应用依赖的理解，一直局限在编程语言层面。比如 Golang 的 Godeps.json。但实际上，一个一直以来很容易被忽视的事实是，对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”。</p><p>有了容器镜像“打包操作系统”的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器所谓的一致性：无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。</p><p><strong>这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。</strong></p><p>不过，这时你可能已经发现了另一个非常棘手的问题：难道我每开发一个应用，或者升级一下现有的应用，都要重复制作一次 rootfs 吗？</p><p>比如，我现在用 Ubuntu 操作系统的 ISO 做了一个 rootfs，然后又在里面安装了 Java 环境，用来部署我的 Java 应用。那么，我的另一个同事在发布他的 Java 应用时，显然希望能够直接使用我安装过 Java 环境的 rootfs，而不是重复这个流程。</p><p>一种比较直观的解决办法是，我在制作 rootfs 的时候，每做一步“有意义”的操作，就保存一个 rootfs 出来，这样其他同事就可以按需求去用他需要的 rootfs 了。</p><p>但是，这个解决办法并不具备推广性。原因在于，一旦你的同事们修改了这个 rootfs，新旧两个 rootfs 之间就没有任何关系了。这样做的结果就是极度的碎片化。</p><p>那么，既然这些修改都基于一个旧的 rootfs，我们能不能以增量的方式去做这些修改呢？这样做的好处是，所有人都只需要维护相对于 base rootfs 修改的增量内容，而不是每次修改都制造一个“fork”。</p><p>答案当然是肯定的。</p><p>这也正是为何，Docker 公司在实现 Docker 镜像时并没有沿用以前制作 rootfs 的标准流程，而是做了一个小小的创新：</p><blockquote><p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p></blockquote><p>当然，这个想法不是凭空臆造出来的，而是用到了一种叫作联合文件系统（Union File System）的能力。Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│  ├── a</span><br><span class="line">│  └── x</span><br><span class="line">└── B</span><br><span class="line">  ├── b</span><br><span class="line">  └── x</span><br></pre></td></tr></table></figure><p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir C</span><br><span class="line">$ mount -t aufs -o dirs=./A:./B none ./C</span><br></pre></td></tr></table></figure></p><p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./C</span><br><span class="line">./C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br></pre></td></tr></table></figure></p><p>可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。这，就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。</p><p>那么在Docker中如何使用这种Union File System的呢？</p><p>我的环境是 Ubuntu 16.04 和 Docker CE 18.05，这对组合默认使用的是 AuFS 这个联合文件系统的实现。你可以通过 docker info 命令，查看到这个信息。<br>AuFS 的全称是 Another UnionFS，后改名为 Alternative UnionFS，再后来干脆改名叫作 Advance UnionFS。</p><p>对于 AuFS 来说，它最关键的目录结构在 /var/lib/docker 路径下的 diff 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/diff/&lt;layer_id&gt;</span><br></pre></td></tr></table></figure></p><p>现在，我们启动一个容器，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:latest sleep 3600</span><br></pre></td></tr></table></figure></p><p>这时候，Docker 就会从 Docker Hub 上拉取一个 Ubuntu 镜像到本地。</p><p>这个所谓的“镜像”，实际上就是一个 Ubuntu 操作系统的 rootfs，它的内容是 Ubuntu 操作系统的所有文件和目录。不过，与之前我们讲述的 rootfs 稍微不同的是，Docker 镜像使用的 rootfs，往往由多个“层”组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect ubuntu:latest</span><br><span class="line">...</span><br><span class="line">     &quot;RootFS&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">      &quot;Layers&quot;: [</span><br><span class="line">        &quot;sha256:f49017d4d5ce9c0f544c...&quot;,</span><br><span class="line">        &quot;sha256:8f2b771487e9d6354080...&quot;,</span><br><span class="line">        &quot;sha256:ccd4d61916aaa2159429...&quot;,</span><br><span class="line">        &quot;sha256:c01d74f99de40e097c73...&quot;,</span><br><span class="line">        &quot;sha256:268a067217b5fe78e000...&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个 Ubuntu 镜像，实际上由五个层组成。这五个层就是五个增量 rootfs，每一层都是 Ubuntu 操作系统文件与目录的一部分；而在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上（等价于前面例子里的“/C”目录）。这个挂载点就是 /var/lib/docker/aufs/mnt/，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e</span><br></pre></td></tr></table></figure><p>不出意外的，这个目录里面正是一个完整的 Ubuntu 操作系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>那么，前面提到的五个镜像层，又是如何被联合挂载成这样一个完整的 Ubuntu 文件系统的呢？<br>这个信息记录在 AuFS 的系统目录 /sys/fs/aufs 下面。<br>首先，通过查看 AuFS 的挂载信息，我们可以找到这个目录对应的 AuFS 的内部 ID（也叫：si）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/mounts| grep aufs</span><br><span class="line">none /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc... aufs rw,relatime,si=972c6d361e6b32ba,dio,dirperm1 0 0</span><br></pre></td></tr></table></figure><p>即，si=972c6d361e6b32ba。<br>然后使用这个 ID，你就可以在 /sys/fs/aufs 下查看被联合挂载在一起的各个层的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*</span><br><span class="line">/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...=rw</span><br><span class="line">/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...-init=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/32e8e20064858c0f2...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/2b8858809bce62e62...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/20707dce8efc0d267...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/72b0744e06247c7d0...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/a524a729adadedb90...=ro+wh</span><br></pre></td></tr></table></figure><p>从这些信息里，我们可以看到，镜像的层都放置在 /var/lib/docker/aufs/diff 目录下，然后被联合挂载在 /var/lib/docker/aufs/mnt 里面。<br>而且，从这个结构可以看出来，这个容器的 rootfs 由如下图所示的三部分组成：</p><p><strong>这里有一个图</strong></p><p>第一部分，只读层。<br>它是这个容器的 rootfs 最下面的五层，对应的正是 ubuntu:latest 镜像的五层。可以看到，它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout，至于什么是 whiteout，我下面马上会讲到）。<br>这时，我们可以分别查看一下这些层的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker/aufs/diff/72b0744e06247c7d0...</span><br><span class="line">etc sbin usr var</span><br><span class="line">$ ls /var/lib/docker/aufs/diff/32e8e20064858c0f2...</span><br><span class="line">run</span><br><span class="line">$ ls /var/lib/docker/aufs/diff/a524a729adadedb900...</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>可以看到，这些层，都以增量的方式分别包含了 Ubuntu 操作系统的一部分。</p><p>第二部分，可读写层。</p><p>它是这个容器的 rootfs 最上面的一层（6e3be5d2ecccae7cc），它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。<br>可是，你有没有想到这样一个问题：如果我现在要做的，是删除只读层里的一个文件呢？<br>为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。<br>比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。我喜欢把 whiteout 形象地翻译为：“白障”。<br>所以，最上面这个可读写层的作用，就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。</p><p>第三部分，Init 层。</p><p>它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。<br>需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。<br>可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。<br>所以，Docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 docker commit 只会提交可读写层，所以是不包含这些内容的。<br>最终，这 7 个层都被联合挂载到 /var/lib/docker/aufs/mnt 目录下，表现为一个完整的 Ubuntu 操作系统供容器使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在今天的分享中，我着重介绍了 Linux 容器文件系统的实现方式。而这种机制，正是我们经常提到的容器镜像，也叫作：rootfs。它只是一个操作系统的所有文件和目录，并不包含内核，最多也就几百兆。而相比之下，传统虚拟机的镜像大多是一个磁盘的“快照”，磁盘有多大，镜像就至少有多大。</p><p>通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。当然，这个功能的实现还必须感谢 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。</p><p>而在 rootfs 的基础上，Docker 公司创新性地提出了使用多个增量 rootfs 联合挂载一个完整 rootfs 的方案，这就是容器镜像中“层”的概念。</p><p>通过“分层镜像”的设计，以 Docker 镜像为核心，来自不同公司、不同团队的技术人员被紧密地联系在了一起。而且，由于容器镜像的操作是增量式的，这样每次镜像拉取、推送的内容，比原本多个完整的操作系统的大小要小得多；而共享层的存在，可以使得所有这些容器镜像需要的总空间，也比每个镜像的总和要小。这样就使得基于容器镜像的团队协作，要比基于动则几个 GB 的虚拟机磁盘镜像的协作要敏捷得多。<br>更重要的是，一旦这个镜像被发布，那么你在全世界的任何一个地方下载这个镜像，得到的内容都完全一致，可以完全复现这个镜像制作者当初的完整环境。这，就是容器技术“强一致性”的重要体现。</p><p>而这种价值正是支撑 Docker 公司在 2014~2016 年间迅猛发展的核心动力。容器镜像的发明，不仅打通了“开发 - 测试 - 部署”流程的每一个环节，更重要的是：</p><blockquote><p>容器镜像将会成为未来软件的主流发布方式。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C程序分析工具 valgrind</title>
      <link href="/2019/04/18/04-introducing-valgrind/"/>
      <url>/2019/04/18/04-introducing-valgrind/</url>
      
        <content type="html"><![CDATA[<p>现在介绍另外一个工具，在学习C的过程中，要习惯性的使用，它就是 Valgrind 。Valgrind是一个运行你的程序的程序，并且随后会报告所有你犯下的可怕错误。</p><h2 id="安装-Valgrind"><a href="#安装-Valgrind" class="headerlink" title="安装 Valgrind"></a>安装 Valgrind</h2><p>有两种安装方式，在Centos中，可以通过yum install -y Valgrind方式安装，另外是下载Valgrind源码安装。</p><p>这里演示源码安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 下载Valgrind源码包</span><br><span class="line">wget wget https://sourceware.org/pub/valgrind/valgrind-3.15.0.tar.bz2</span><br><span class="line"></span><br><span class="line">2) 解压</span><br><span class="line">tar jxvf valgrind-3.15.0.tar.bz2</span><br><span class="line"></span><br><span class="line">3) configure</span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">4) 编译</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">5) 安装</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="使用Valgrind"><a href="#使用Valgrind" class="headerlink" title="使用Valgrind"></a>使用Valgrind</h2><p>这里写一个带有错误的C程序，待会儿让Valgrind来运行一下,error.c源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int age = 12;</span><br><span class="line">    int height;</span><br><span class="line"></span><br><span class="line">    printf(&quot;I am %d years old.\n&quot;);</span><br><span class="line">    printf(&quot;I am %d inches tall.\n&quot;,height);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前程序有两个错误：</p><ul><li>没有初始化height变量</li><li>没有将age变量传入第一个printf函数</li></ul><p>使用make构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www practice04]# make</span><br><span class="line">cc -Wall -g    error.c   -o error</span><br><span class="line">error.c: In function ‘main’:</span><br><span class="line">error.c:7:5: warning: format ‘%d’ expects a matching ‘int’ argument [-Wformat=]</span><br><span class="line">     printf(&quot;I am %d years old.\n&quot;);</span><br><span class="line">     ^</span><br><span class="line">error.c:4:9: warning: unused variable ‘age’ [-Wunused-variable]</span><br><span class="line">     int age = 12;</span><br><span class="line">         ^</span><br><span class="line">error.c:8:11: warning: ‘height’ is used uninitialized in this function [-Wuninitialized]</span><br><span class="line">     printf(&quot;I am %d inches tall.\n&quot;,height);</span><br><span class="line">           ^</span><br></pre></td></tr></table></figure><p>使用Valgrind来运行error程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">==17432== Memcheck, a memory error detector</span><br><span class="line">==17432== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==17432== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==17432== Command: ./error</span><br><span class="line">==17432== </span><br><span class="line">I am -16775928 years old.</span><br><span class="line">==17432== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==17432==    at 0x4E7C9F2: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E86878: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x400561: main (error.c:8)</span><br><span class="line">==17432== </span><br><span class="line">==17432== Use of uninitialised value of size 8</span><br><span class="line">==17432==    at 0x4E7BE8B: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E7CF05: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E86878: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x400561: main (error.c:8)</span><br><span class="line">==17432== </span><br><span class="line">==17432== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==17432==    at 0x4E7BE95: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E7CF05: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E86878: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x400561: main (error.c:8)</span><br><span class="line">==17432== </span><br><span class="line">==17432== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==17432==    at 0x4E7CF54: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E86878: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x400561: main (error.c:8)</span><br><span class="line">==17432== </span><br><span class="line">==17432== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==17432==    at 0x4E7CABD: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E86878: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x400561: main (error.c:8)</span><br><span class="line">==17432== </span><br><span class="line">==17432== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==17432==    at 0x4E7CB40: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x4E86878: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==17432==    by 0x400561: main (error.c:8)</span><br><span class="line">==17432== </span><br><span class="line">I am 0 inches tall.</span><br><span class="line">==17432== </span><br><span class="line">==17432== HEAP SUMMARY:</span><br><span class="line">==17432==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==17432==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated</span><br><span class="line">==17432== </span><br><span class="line">==17432== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==17432== </span><br><span class="line">==17432== Use --track-origins=yes to see where uninitialised values come from</span><br><span class="line">==17432== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==17432== ERROR SUMMARY: 6 errors from 6 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure></p><p>Valgrind运行并分析程序，返回的数据分成三部分，第一部分是Vargrind版本信息,第二部分报告程序的相关错误信息，第三部分会生成一个简短报告，告诉你你的程序有多烂。</p><h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><ul><li>根据Valgrind错误信息，修复程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">==17515== Memcheck, a memory error detector</span><br><span class="line">==17515== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==17515== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==17515== Command: ./error</span><br><span class="line">==17515== </span><br><span class="line">I am 12345 years old.</span><br><span class="line">I am 72 inches tall.</span><br><span class="line">==17515== </span><br><span class="line">==17515== HEAP SUMMARY:</span><br><span class="line">==17515==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==17515==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated</span><br><span class="line">==17515== </span><br><span class="line">==17515== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==17515== </span><br><span class="line">==17515== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==17515== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> valgrind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化输出</title>
      <link href="/2019/04/18/03-format-print/"/>
      <url>/2019/04/18/03-format-print/</url>
      
        <content type="html"><![CDATA[<h2 id="printf格式化函数"><a href="#printf格式化函数" class="headerlink" title="printf格式化函数"></a>printf格式化函数</h2><p>许多编程语言都使用了C风格格式化输出，所以让我们也尝试一下,编写format-output.c，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    int height = 72;</span><br><span class="line"></span><br><span class="line">    printf(&quot;I am %d years old.\n&quot;,age);</span><br><span class="line">    printf(&quot;I am %d inches tall.\n&quot;,height);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-Wall -g</span><br><span class="line"></span><br><span class="line">all: format-output</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf format-output</span><br></pre></td></tr></table></figure></p><p>执行<code>make</code>，将看到如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www practice03]# make</span><br><span class="line">cc -Wall -g    format-output.c   -o format-output</span><br></pre></td></tr></table></figure></p><p>这段代码量很小，我们逐行分析一下：</p><ul><li>首先你包含了一个叫做 <code>stdio.h</code> 的头文件。这告诉你的编译器要使用“标准的输入/输出函数”。他们之一就是下面的<code>printf</code>。</li><li>然后你声明了一个int类型的age变量，并赋值为10。</li><li>接着你又声明了一个int类型的height变量，并赋值为72。</li><li>再然后用<code>printf</code>函数来打印你的年龄和身高</li><li>在<code>printf</code>中你会注意到你传入了一个字符串，这就是格式字符串，和其它语言中一样。</li><li>在格式化字符串后面，你传入了一些变量，他们应该被<code>printf</code>“替换”进格式化字符串中。</li></ul><h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><ul><li>执行 man 3 printf 来阅读它更多可用的“%”格式的占位符。</li></ul><table><thead><tr><th>控制符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>%d</td><td style="text-align:center">按十进制整型数据的实际长度输出。</td></tr><tr><td>%ld</td><td style="text-align:center">输出长整型数据。</td></tr><tr><td>%md</td><td style="text-align:center">m为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 m，则按实际位数输出。</td></tr><tr><td>%u</td><td style="text-align:center">输出无符号整型（unsigned）。输出无符号整型时也可以用 %d，这时是将无符号转换成有符号数，然后输出。但编程的时候最好不要这么写，因为这样要进行一次转换，使 CPU 多做一次无用功。</td></tr><tr><td>%c</td><td style="text-align:center">输出一个字符</td></tr><tr><td>%f</td><td style="text-align:center">用来输出实数，包括单精度和双精度，以小数形式输出。不指定字段宽度，由系统自动指定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。</td></tr><tr><td>%.mf</td><td style="text-align:center">输出实数时小数点后保留 m 位，注意 m 前面有个点。</td></tr><tr><td>%o</td><td style="text-align:center">以八进制整数形式输出，这个就用得很少了，了解一下就行了。</td></tr><tr><td>%s</td><td style="text-align:center">用来输出字符串。用 %s 输出字符串同前面直接输出字符串是一样的。但是此时要先定义字符数组或字符指针存储或指向字符串。</td></tr><tr><td>%x（或 %X 或 %#x 或 %#X）</td><td style="text-align:center">以十六进制形式输出整数，这个很重要。</td></tr></tbody></table><ul><li>%x、%X、%#x、%#X 的区别</li></ul><p>一定要掌握 %x（或 %X 或 %#x 或 %#X），因为调试的时候经常要将内存中的二进制代码全部输出，然后用十六进制显示出来。下面写一个程序看看它们四个有什么区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 47;</span><br><span class="line">    printf(&quot;%x\n&quot;, i);   </span><br><span class="line">    printf(&quot;%X\n&quot;, i);   </span><br><span class="line">    printf(&quot;%#x\n&quot;, i);   </span><br><span class="line">    printf(&quot;%#X\n&quot;, i);   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VC++ 6.0 中的输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2f</span><br><span class="line">2F</span><br><span class="line">0x2f</span><br><span class="line">0X2F</span><br></pre></td></tr></table></figure></p><p>从输出结果可以看出：如果是小写的<code>x</code>，输出的字母就是小写的；如果是大写的<code>X</code>，输出的字母就是大写的；如果加一个<code>#</code>，就以标准的十六进制形式输出。</p><p>最好是加一个#，否则如果输出的十六进制数正好没有字母的话会误认为是一个十进制数呢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker:从进程说起</title>
      <link href="/2019/04/12/docker-process/"/>
      <url>/2019/04/12/docker-process/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是运行的程序，一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运起来后的计算机执行环境的总和，就是<strong>进程</strong>。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“<strong>边界</strong>”。</p><p>对于 Docker 等大多数 Linux 容器来说，<strong>Cgroups</strong> 技术是用来制造约束的主要手段，而<strong>Namespace</strong> 技术则是用来修改进程视图的主要方法。</p><p>假设你已经有了一个 Linux 操作系统上的 Docker 项目在运行，比如我的环境是 Ubuntu 16.04 和 Docker CE 18.05。</p><p>接下来，让我们创建一个容器试试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it busybox /bin/bash</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这就是大名鼎鼎的<code>docker run</code>。-it参数告诉Docker项目在启动的时候分配一个输入/输出环境，也就是TTY，跟容器的标准输入相关联，这样我们就可以和这个容器交互了。而/bin/bash就是在这个容器里运行的程序。</p><p>所以，上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。</p><p>在容器里执行<code>ps</code>，会出现如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ps</span></span><br><span class="line">PID  USER   TIME COMMAND</span><br><span class="line">  1 root   0:00 /bin/sh</span><br><span class="line">  10 root   0:00 ps</span><br></pre></td></tr></table></figure><p>我们可以看到，容器启动时执行的/bin/bash，就是这个容器里第1号进程（PID=1）,当前，容器里有两个进程在运行。这两个进程，已经被Docker隔离在了一个跟宿主主机完全不同的世界当中。</p><p>那么，这究竟是这么做到的呢？</p><p>本来，当我们在宿主主机执行<code>/bin/bash</code>,操作系统会给它分配一个进程编号，比如PID=100。而现在，我们通过Docker把<code>/bin/bash</code>运行在容器当中。这时候，Docker就会在这个进程启动时，给它实时一个“障眼法”，让它永远也看不到前面的<strong>99</strong>个进程，这里，它就会误认为自己是第1号进程了。</p><p>这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主主机的操作系统中，还是原来的第100号进程。</p><p>这种技术，就是Linux中的<strong>Namespace</strong>机制。而Namespace的使用方式也非常有意思：它其实只是Linux创建新进程的一个可选参数。我们知道，在Linux系统中创建线程的系统调用是clone(),比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid = <span class="built_in">clone</span>(main_function, stack_size, SIGCHLD, NULL);</span><br></pre></td></tr></table></figure><p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。<br>而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid = <span class="built_in">clone</span>(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure><p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p><p>而除了刚刚这种PID Namespace，Linux操作系统还提供了<strong>Mount</strong>、<strong>UTS</strong>、<strong>IPC</strong>、<strong>Network</strong>和<strong>User</strong> 这些Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</p><p>这就是Linux容器最基本的实现原理了。所以说，<strong>容器只是一种特殊的进程而已</strong>，在创建该容器进程时，指定了这个进程所需要启用的一组Namespace参数。这样，容器就只能“看”到当前Namespace所限定的资源、文件、设备、状态或者配置。而宿主主机以及其他不想关的程序，它就完全看不到了。</p><h2 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h2><p>除了<strong>Namespace</strong>对容器环境进行隔离，还通过<strong>Linux CGroup</strong>限制容器进程使用相关资源</p><p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。在 Ubuntu 16.04 机器里，我可以用 mount 指令把它们展示出来，这条命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到，在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/cpu</span><br><span class="line">cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release</span><br><span class="line">cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks</span><br></pre></td></tr></table></figure><p>如果熟悉 Linux CPU 管理的话，你就会在它的输出里注意到 cfs_period 和 cfs_quota 这样的关键词。这两个参数需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p><p>而这样的配置文件又如何使用呢？<br>你需要在对应的子系统下面创建一个目录，比如，我们现在进入 /sys/fs/cgroup/cpu 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ mkdir container</span><br><span class="line">root@ubuntu:/sys/fs/cgroup/cpu$ ls container/</span><br><span class="line">cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release</span><br><span class="line">cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks</span><br></pre></td></tr></table></figure><p>这个目录就称为一个“控制组”。你会发现，操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。</p><p>现在，我们在后台执行这样一条脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> : ; <span class="keyword">do</span> : ; <span class="keyword">done</span> &amp;</span><br><span class="line">[1] 226</span><br></pre></td></tr></table></figure><p>显然，它执行了一个死循环，可以把计算机的 CPU 吃到 100%，根据它的输出，我们可以看到这个脚本在后台运行的进程号（PID）是 226。<br>这样，我们可以用 top 指令来确认一下 CPU 有没有被打满：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">%Cpu0 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br></pre></td></tr></table></figure><p>在输出里可以看到，CPU 的使用率已经 100% 了（%Cpu0 :100.0 us）。<br>而此时，我们可以通过查看 container 目录下的文件，看到 container 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us </span><br><span class="line">-1</span><br><span class="line">$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us </span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>接下来，我们可以通过修改这些文件的内容来设置限制。<br>比如，向 container 组里的 cfs_quota 文件写入 20 ms（20000 us）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 20000 &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure><p>结合前面的介绍，你应该能明白这个操作的含义，它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。<br>接下来，我们把被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 226 &gt; /sys/fs/cgroup/cpu/container/tasks</span><br></pre></td></tr></table></figure><p>我们可以用 top 指令查看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">%Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br></pre></td></tr></table></figure><p>可以看到，计算机的 CPU 使用率立刻降到了 20%（%Cpu0 : 20.3 us）。</p><p>除 CPU 子系统外，Cgroups 的每一项子系统都有其独有的资源限制能力，比如：</p><ul><li>blkio，为​​​块​​​设​​​备​​​设​​​定​​​I/O 限​​​制,一般用于磁盘等设备；</li><li>cpuset，为进程分配单独的 CPU 核和对应的内存节点；</li><li>memory，为进程设定内存使用的限制。</li></ul><p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。<br>而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us </span><br><span class="line">100000</span><br><span class="line">$ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us </span><br><span class="line">20000</span><br></pre></td></tr></table></figure><p>这就意味着这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用make</title>
      <link href="/2019/04/09/02-use-make/"/>
      <url>/2019/04/09/02-use-make/</url>
      
        <content type="html"><![CDATA[<h2 id="使用make"><a href="#使用make" class="headerlink" title="使用make"></a>使用make</h2><p>使用make的第一个阶段，就是用它已知的方法来构建程序。make预置了一些知识，来从其它文件构建多种文件。在上一个练习中，有如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make hello-world</span><br><span class="line">$ CFLAG=&quot;-Wall&quot; make hello-world</span><br></pre></td></tr></table></figure><p>第一条命令中你告诉make，“我想创建名为hello-word的文件”。于是，make执行了下面的动作：</p><ul><li>文件hello-world存在吗？</li><li>没有的话。好的，那有没有其它文件是以hello-world开头的？</li><li>有，叫做hello-world.c。我知道如何构建.c文件吗？</li><li>知道。我会运行 <code>cc hello-world.c -o hello-world</code> 来构建它。</li><li>我将使用 <code>cc</code> 从 hello-world.c 文件为你构建 hello-world</li></ul><p>上面的第二条命令，是向 make 命令传递“修改器”的途径。这个例子中，我执行了 <code>CFLAGS=&quot;-Wall&quot; make hello-world</code>，它会给make使用的 <code>cc</code> 命令添加 -Wall 选项。这行命令告诉编译器要报告所有的警告。</p><h2 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h2><p>创建文件并写入一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-Wall -g</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf hello-world</span><br></pre></td></tr></table></figure><p>将文件在你当前文件夹下保存为Makefile。Make会自动假设当前文件夹下有一个叫Makefile的文件，并且会执行它。</p><p>首先我们在文件中设置CFLAGS,所以之后都不用再设置了。并且添加了-g标识来获取调试信息。接着我们写了一个<code>clean</code>的部门，它告诉make如何清理我们的小项目。</p><p>请确保，你的makefile文件和hello-world.c在同一个目录下，hello-world.c内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char *argv[])&#123;</span><br><span class="line">    puts(&quot;Hello world.\nnice to see you!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后可以执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">$ make hello-world</span><br></pre></td></tr></table></figure><p>如果代码正常执行，你应该看到下面这些内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www practice02]# make clean</span><br><span class="line">rm -f hello-world</span><br><span class="line">[root@www practice02]# make hello-world</span><br><span class="line">cc -Wall -g    hello-world.c   -o hello-world</span><br><span class="line">hello-world.c: In function ‘main’:</span><br><span class="line">hello-world.c:2:5: warning: implicit declaration of function ‘puts’ [-Wimplicit-function-declaration]</span><br><span class="line">     puts(&quot;Hello world.\nnice to see you!&quot;);</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure><p>你可以看出来,我执行了<code>make clean</code>，它告诉make执行我们的<code>clean</code>目标。在看makefile，发现<code>clean</code>下面有一些shell命令。你可以在此处输入任意多的命令，所以它是一个非常棒的自动化工具。</p><blockquote><p>注:<br>如果你修改了 ex1.c ，添加了 #include\&lt;stdio> ，输出中的关于 puts 的警告就会消失（这其实应该算作一个错误） 。我这里有警告是因为我并没有去掉它</p></blockquote><h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><ul><li><p>创建目标 all:hello-world,可以用单个命令make构建hello-world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-Wall -g</span><br><span class="line"></span><br><span class="line">all: hello-world</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f hello-world</span><br></pre></td></tr></table></figure></li><li><p>阅读 man make 来了解关于他的更多信息。</p></li><li>阅读 man cc 来了解关于 -Wall 和 -g 行为的更多信息。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启用编译器</title>
      <link href="/2019/04/09/01-dust-off-that-compiler/"/>
      <url>/2019/04/09/01-dust-off-that-compiler/</url>
      
        <content type="html"><![CDATA[<p>这是一个最简单的C程序,hello-world.c：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    puts("Hello world.");</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make hello-world</span><br><span class="line">cc hello-world.c -o hello-world</span><br></pre></td></tr></table></figure><p>现在，你可以运行并可以看到程序输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./hello-world</span><br><span class="line">Hello World.</span><br></pre></td></tr></table></figure><p>思考：</p><ul><li>1.make指令的运行原理和流程</li><li>2.puts函数的作用<br> C 库函数 int puts(const char *str) 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</li><li><p>3.C语言中的空字符<br> 在C语言中空字符用’\0’表示;<br> ‘\0’对应的整数值是0，所以给一个字符变量赋值为空字符时，以下两种都是可以的：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch=&apos;\0&apos;;</span><br><span class="line">char ch=0;</span><br></pre></td></tr></table></figure></li><li><p>4.字符串<br> 字符串就是一串零个或多个字符，并且以位模式为全0的NUL字节即空字符(‘\0’)结尾。C语言中字符串没有显示的数据类型，字符串通常存储在字符数组或动态分配的内存中，在编码操作中通常将整个字符串作为操作对象，常用操作包括复制、查找、比较等。</p></li><li>5.空字符与字符串<ul><li>1、空字符是字符串的终止符。注：空字符本身不是字符串的一部分，所以字符串的长度并不包含空字符； </li><li>2、操作字符串时，必须保证字符串以空字符结尾(注：不以空字符结尾的字符序列，不是字符串)。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笨方法学C</title>
      <link href="/2019/04/09/learn-c-the-hard-way/"/>
      <url>/2019/04/09/learn-c-the-hard-way/</url>
      
        <content type="html"><![CDATA[<p>这几年，我一直在学习编程语言，从JAVA、PHP、JS到Go，其实我一直想学好的是C语言，C即是基础。这个《笨方法学C》的读书系列，希望自己一定要坚持下来，好好学习，好好总结。</p><p>这本书的目的是让你足够熟悉C语言，并能够使用它编写自己的软件，或者修改其他人的代码。你需要学习下面这些东西来达到这一阶段：</p><ul><li>C的基本语法和编写习惯;</li><li>编译,make文件和链接;</li><li>寻找和预防bug;</li><li>防御性编程实战;</li><li>使C的代码崩溃;</li><li>编写基本的Unix系统软件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis源码从哪里读起?</title>
      <link href="/2019/04/03/Redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/"/>
      <url>/2019/04/03/Redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>转载至 <a href="http://zhangtielei.com/posts/blog-redis-how-to-start.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-how-to-start.html</a></p><hr><h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>Redis使用C语言写的。首先，你应该从main函数读起。但是我们在读的时候应该抓住一条主线，也就是当我们向Redis输入一条命令的时候，代码是如何一步一步执行的。这样我们就可以先从外部观察，尝试执行一些命令，在了解了这些命令执行的外部表现之后，再钻进去看对应的源码是如何实现的。要想读懂这些代码，首先我们需要理解Redis的事件机制。而且，一旦理解了<strong>Redis的事件循环（Event Loop）</strong>的机制，我们还会搞明白一个有趣的问题：为什么Redis是单线程执行却能同时处理多个请求？（当然严格来说Redis运行并不是只有一个线程，但除了主线程外，Redis的其它线程只是起辅助作用，它们是一些在后台运行做异步耗时任务的线程）。</p><p>从main函数开始，沿着代码执行路径，实际上我们可以一直追下去。但为了让本文不至于太过冗长，我们还是限定一下返回。本文的目标就定为：引领读者从main函数开始，一步步追踪下去，最终到达任一Redis命令执行入口。这样接下来就可以与<strong>Redis内部数据结构详解</strong>的一些列文章衔接上。</p><p>为了表述清楚，本文按照如下思路进行：</p><ul><li>1.先概括地介绍整个代码初始化流程（从main函数开始）和事件循环的结构；</li><li>2.再概括地介绍对于Redis命令请求的处理流程；</li><li>3.重点介绍事件机制；</li><li>4.对于前面介绍的各个代码流程处理，给出详细的代码调用关系，方便随时查阅；</li></ul><p>根据这样几部分的划分，如果你只想粗读大致的处理流程，那么只需要阅读前两个部分就可以了。而后两部分则会深入到某些值得关注的细节。</p><p>注：本文的分析基于Redis源码的5.0分支。</p><h2 id="初始化流程和事件循环概述"><a href="#初始化流程和事件循环概述" class="headerlink" title="初始化流程和事件循环概述"></a>初始化流程和事件循环概述</h2><p>Redis源码的main函数在源文件server.c中。main函数开始执行后的逻辑可以分为两个阶段：</p><ul><li>各种初始化（包括事件循环的初始化）</li><li>执行事件循环。</li></ul><p>这两个执行阶段可以用下面的流程图来表达：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/redis/main_start_event_loop.png?raw=true" width="50%" height="50%"></div><br><div align="center">图1：main函数执行逻辑</div><p>首先，我们开一下初始化阶段中的各个步骤：</p><ul><li><p><strong>配置加载和初始化</strong>，这一步表示Redis服务器基本数据结构和各种参数的初始化。在Redis源码中，Redis服务器就是用一个叫做redisServer的struct来表示的。 里面定义了Redis服务器赖以运行的各种参数，比如监听的端口号和文件描述符、当前连接的各个client端、Redis命令表（command table）配置、持久化相关的各种参数，等等。Redis服务器在运行时就是由一个<code>redisServer</code>类型的全局变量来表示的（变量名叫 <code>server</code>）,这一步的初始化主要对于这个全局变量进行初始化。在整个初始化过程中，有一个特别需要注意的函数：<code>populateCommandTable</code>。它初始化了Redis命令表，通过它可以由任意一个Redis命令的名字查找该命令的配置信息（比如该命令接受的命令参数个数、执行函数入口等）。在本文的第二部分，我们将会一起来看看如何从接受一个Redis命令的请求开始，一步步执行到查阅这个命令表，从而找到该命令的执行入口。另外，这一步中还有一个值得一提的地方，在对全局的<code>redisServer</code>结构进行初始化之后，还需要从配置文件（redis.conf）中加载配置。这个过程可能覆盖掉之前的初始化过的<code>redisServer</code>结构中的某些参数。换句话说，就是先经过一轮初始化，保证Redis的各个内部数据结构以及参数都有缺省值，然后再从配置文件中加载自定义的配置。</p></li><li><p><strong>创建事件循环</strong>，在Redis中，事件循环是用一个叫aeEventLoop的struct来表示的。<strong>创建事件循环</strong>这一步主要就是创建一个aeEventLoop结构，并存储到<code>server</code>全局变量中。另外，事件循环的执行依赖系统低层的I/O多路复用机制，比如Linux系统上的epoll机制。因此，这一步也包含对于低层I/O多路复用机制的初始化。（调用系统API）</p></li><li><p><strong>开始监听socket</strong>。服务器程序需要监听才能收到请求。根据配置，这一步可能会打开两种监听：对于<code>TCP</code>连接的监听和对于<code>Unix domain socket</code>的监听，<code>Unix domain socket</code>是一种高效的进程间通信机制，在<code>POSIX</code>规范中也有明确的定义，用于在同一台主机上的两个不同进程之间进行通信，比使用TCP协议性能跟高（因为省去了协议栈的开销）。当使用Redis客户端连接同一台机器上的Redis服务器时，可以使用<code>Unix domain socket</code>进行连接。但是不管是哪一种监听，程序都会获得文件描述符，并存储到<code>server</code>全局变量中。对于TCP的监听来说，由于监听的IP地址和端口可以绑定多个，因此获得的用于监听TCP连接的文件描述符也可以包含多个。后面，程序就可以拿这一步获得的文件描述符去注册I/O事件回调了。</p></li><li><p><strong>注册timer事件回调</strong>。Redis作为一个单线程(single-threaded)的程序，它如果想调度一些异步执行的任务，比如比如周期性的执行过期key的回收动作，除了依赖事件循环机制，没有其它办法。这一步就是向前面刚刚创建好的事件循环中注册一个timer事件，并配置成可以周期性地执行一个回调函数：<code>serverCron</code>。由于Redis只有一个主线程，因此这个函数周期性的执行也是在这个线程内，它由事件循环来驱动（即在合适的时机调用），但不影响同一个线程上其它逻辑的执行（相当于按时间分片了）。<code>serverCron</code>函数到底做了什么呢？实际上，它除了周期性地执行过期key的回收动作，还执行了很多其它任务，比如主从重连、Cluster节点间的重连、bgsave和aof rewrite的触发执行，等等。</p></li><li><p><strong>注册I/O事件回调</strong>。Redis服务器最主要的工作就是监听I/O事件，从中分析出来自客户端的命令请求，执行命令，然后返回响应结果。对于I/O事件的监听，自然也是依赖事件循环。前面提到过，Redis可以打开两种监听：对于TCP连接的监听和对于Unix domain socket的监听。因此，这里就包含对于这两种I/O事件的回调的注册，两个回调函数分别是<code>acceptTcpHandler</code>和<code>acceptUnixHandler</code>。对于来自Redis客户端的请求的处理，就会走到这两个函数中去。我们在下一部分就会讨论到这个处理过程。另外，其实Redis在这里还会注册一个I/O事件，用于通过管道(pipe[6])机制与module进行双向通信。这个也不是本文的重点，我们暂时忽略它。</p></li><li><p><strong>初始化后台线程</strong>。Redis会创建一些额外的线程，在后台运行，专门用于处理一些耗时的并且可以被延迟执行的任务（一般是一些清理工作）。在Redis里面这些后台线程被称为bio（background i/o server）。它们负责的任务包括：可以延迟执行的文件关闭操作（比如unlink命令的执行），AOF的持久化写库操作（即fsync调用，但注意只有可以被延迟执行的fsync操作才在后台线程执行），还有一些大key的清除操作（比如flushdb async命令的执行）。可见bio这个名字有点名不副实，它做的事情不一定跟I/O有关。对于这些后台线程，我们可能还会产生一个疑问：前面的初始化过程，已经注册了一个timer事件回调，即<code>serverCron</code>函数，按说后台线程执行的这些任务似乎也可以放在<code>serverCron</code>中去执行。因为<code>serverCron</code>函数也是可以用来执行后台任务的。实际上这样做是不行的。前面我们已经提到过，<code>serverCron</code>由事件循环来驱动，执行还是在Redis主线程上，相当于和主线程上执行的其它操作（主要是对于命令请求的执行）按时间进行分片了。这样的话，<code>serverCron</code>里面就不能执行过于耗时的操作，否则它就会影响Redis执行命令的响应时间。因此，对于耗时的、并且可以被延迟执行的任务，就只能放到单独的线程中去执行了。</p></li><li><p><strong>启动事件循环</strong>。前面创建好了事件循环的结构，但还没有真正进入循环的逻辑。过了这一步，事件循环就运行起来，驱动前面注册的<strong>timer事件回调</strong>和<strong>I/O事件回调</strong>不断执行。</p></li></ul><p>注意：Redis服务器初始化其实还有很多其它事情，比如加载数据到内存，Cluster集群的初始化，module的初始化，等等。但为了简化，上面讨论的初始化流程，只列出了我们当前关注的步骤。本文关注的是由事件驱动的整个运行机制以及跟命令执行直接相关的部分，因此我们暂时忽略掉其它不太相关的步骤。</p><p>现在，我们继续去讨论上面流程图中的第二个阶段：事件循环。</p><p>我们先想一下为什么这里需要一个循环。</p><p>一个程序启动后，如果没有循环，那么它从第一条指令执行到最后一条指令，然后就只能退出了。而Redis作为一个服务端程序，是要等客户端不停地发来请求然后做相应的处理，不能自己执行完就退出了。因此，Redis启动后必定要进入一个无限循环，显然，程序在每一次循环执行中，如果有事件（包括客户端请求的I/O事件）发生，就会去处理这些事件。如果没有事件发生呢？程序显然也不应该空转，而是应该等待，把整个循环阻塞住。这里的等待，就是上面流程图的【等待事件发生】这个步骤。那么，当整个循环被阻塞住之后，什么时候再恢复执行呢？自然是等待的事件发生的时候，程序被重新唤醒，循环继续下去。这里需要的等待和唤醒操作，是怎么实现呢？它们都需要依赖系统的能力才能做到。</p><p>实际上，这种事件循环机制，对于开发过手机客户端的同学来说，是非常常见且基础的机制。比如跑在iOS/Android上面的App，这些程序都有一个消息循环，负责等待各种UI事件（点击、滑动等）的发生，然后进行处理。同理，对应到服务端，这个循环的原理可以认为差不多，只是等待和处理的事件变成是I/O事件了。另外，除了I/O事件，整个系统在运行过程中肯定还需要根据时间来调度执行一些任务，比如延迟100毫秒再执行某个操作，或者周期性地每隔1秒执行某个任务，这就需要等待和处理另外一种事件——timer事件。</p><p>timer事件和I/O事件是两种截然不同的事件，如何由事件循环来统一调度呢？假设事件循环有空闲的时候去等待I/O事件的发生，那么有可能一个timer事件先发生了，这时事件循环就没有被及时唤醒（仍在等待I/O事件）；反之，如果事件循环在等待timer事件，而一个I/O事件先发生了，那么同样没能够及时唤醒。因此，我们必须有一种机制能够同时等待这两种事件的发生。而恰好，一些系统的API可以做到这一点（比如我们前面提到的epoll机制）。</p><p>前面流程图的第二阶段已经比较清楚地表达出了事件循环的执行流程。在这里我们对于其中一些步骤需要关注的地方做一些补充说明：</p><ul><li><p><strong>查找最近的timer事件</strong>。如前所序，事件循环需要等待timerI/O两种事件。对于I/O事件，只需要明确等待的是哪些文件描述符就可以了；而对于timer事件，还需要经过一番比较，明确在当前这一轮循环中需要等待多长时间。由于系统运行过程中可能注册多个timer事件回调，比如先要求在100毫秒后执行一个回调，同时又要求在200毫秒后执行另外一个回调，这就要求事件循环在它的每一轮执行之前，首先要找出最近需要执行的那次timer事件。这样事件循环在接下来等待中就知道该等待多长时间（在这个例子中，我们需要等待100毫秒）。</p></li><li><p><strong>等待事件发生</strong>。这一步我们需要能够同时等待timer和I/O两种事件的发生。要做到这一点，我们依赖系统低层的I/O多路复用机制。这种机制一般是这样设计的：它允许我们针对多个文件描述符来等待对应的I/O事件发生，并同时可以指定一个最长的阻塞超时时间。如果在这段阻塞时间内，有I/O事件发生，那么程序会被唤醒继续执行；如果一直没有I/O事件发生，而是指定的时间先超时了，那么程序也会被唤醒。对于timer事件的等待，就是依赖这里的<strong>超时机制</strong>。当然，这里的超时时间也可以指定成无限长，这就相当于只等待I/O事件。我们再看一下上一步<strong>查找最近timer事件</strong>，查找完之后可能有三种结果，因此这一步等待也可能出现三种对应的情况：</p><ul><li>第一种情况，查找到了一个最近的timer事件，它要求在未来某一个时刻触发。那么，这一步只需要把这个未来时刻转换成阻塞超时时间即可。</li><li>第二种情况，查找到了一个最近的timer事件，但它要求的时刻已经过去了。那么，这时候它应该立刻被触发，而不应该再有任何等待。当然，在实现的时候还是调用了事件等待的API，只是把超时事件设置成0就可以达到这个效果。</li><li>第三种情况，没有查找到任何注册的timer事件。那么，这时候应该把超时时间设置成无限长。接下来只有I/O事件发生才能唤醒。</li></ul></li><li><p>判断有I/O事件发生还是超时。这里是程序从上一步（可能的）阻塞状态中恢复后执行逻辑。如果是I/O事件发生了，那么先指向I/O事件回调，然后根据需要把到期的timer事件的回调也执行掉（如果有的话）；如果是超时先发生了，那么表示只有timer事件需要触发（没有I/O事件发生），那么就直接把到期的timer事件的回调执行掉。</p></li><li><p><strong>执行I/O事件回调</strong>。我们前面提到的对于TCP连接的监听和对于Unix domain socket的监听，这两种I/O事件的回调函数acceptTcpHandler和acceptUnixHandler，就是在这一步被调用的。</p></li><li><p><strong>执行timer事件回调</strong>。我们前面提到的周期性回调函数<code>serverCron</code>，就是在这一步被调用的。一般情况下，一个timer事件被处理后，它就会被从队列中删除，不会再次执行了。但serverCron却是被周期性调用的，这是怎么回事呢？这是因为Redis对于timer事件回调的处理设计了一个小机制：timer事件的回调函数可以返回一个需要下次执行的毫秒数。如果返回值是正常的正值，那么Redis就不会把这个timer事件从事件循环的队列中删除，这样它后面还有机会再次执行。例如，按照默认的设置，serverCron返回值是100，因此它每隔100毫秒会执行一次（当然这个执行频率可以在redis.conf中通过hz变量来调整）。</p></li></ul><p>至此，Redis整个事件循环的轮廓我们就清楚了。Redis主要的处理流程，包括接收请求、执行命令，以及周期性地执行后台任务（<code>serverCron</code>），都是由这个事件循环驱动的。当请求到来时，I/O事件被触发，事件循环被唤醒，根据请求执行命令并返回响应结果；同时，后台异步任务（如回收过期的key）被拆分成若干小段，由timer事件所触发，夹杂在I/O事件处理的间隙来周期性地运行。这种执行方式允许仅仅使用一个线程来处理大量的请求，并能提供快速的响应时间。当然，这种实现方式之所以能够高效运转，除了事件循环的结构之外，还得益于系统提供的异步的I/O多路复用机制(I/O multiplexing)。事件循环使得CPU资源被分时复用了，不同代码块之间并没有「真正的」并发执行，但I/O多路复用机制使得CPU和I/O的执行是真正并发的。而且，使用单线程还有额外的好处：避免了代码的并发执行，在访问各种数据结构的时候都无需考虑线程安全问题，从而大大降低了实现的复杂度。</p><h2 id="Redis命令请求的处理流程概述"><a href="#Redis命令请求的处理流程概述" class="headerlink" title="Redis命令请求的处理流程概述"></a>Redis命令请求的处理流程概述</h2><p>我们在前面讨论[注册I/O事件回调]的时候提到过，Redis对于来自客户端的请求的处理，都会走到<code>acceptTcpHandler</code>和<code>acceptUnixHandler</code>这两个回调函数中去。实际上，这样的描述还过于粗略。</p><p>Redis客户端向服务器发送命令，可以细分为两个过程：</p><ul><li><p>1.<strong>建立连接</strong>。客户端发起连接请求（通过TCP或<code>Unix Domain Socket</code>）,服务器接受连接。</p></li><li><p>2.<strong>命令发送、执行和响应</strong>。连接一旦建立好，客户端就可以在这个新连接的基础上发送命令数据，服务器收到后执行这个命令，并把执行结果返回给客户端。而且，在新连接上，这整个的[命令发送、执行和响应]的过程就可以反复执行。</p></li></ul><p>上述第一个过程，「连接建立」，对应到服务端的代码，就是会走到<code>acceptTcpHandler</code>或<code>acceptUnixHandler</code>这两个回调函数中去。换句话说，Redis服务器每收到一个新的连接请求，就会由事件循环触发一个I/O事件，从而执行到<code>acceptTcpHandler</code>或<code>acceptUnixHandler</code>回调函数的代码。</p><p>接下来，从socket编程的角度，服务器应该调用<code>accept</code>系统API来接受连接请求，并为新的连接创建出一个socket。这个新的socket也就对应着一个新的文件描述符。为了在新的连接上能接收到客户端发来的命令，接下来必须在事件循环中为这个新的文件描述符注册一个I/O事件回调。这个过程的流程图如下：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/redis/accept_handler_flow_chart.png?raw=true" width="50%" height="50%"></div><br><div align="center">图2：接收客户端连接请求</div><p>从上面流程图可以看出，新的连接注册了一个I/O事件回调，即<code>readQueryFromClient</code>。也就是说，对应前面讲的第二个过程，[命令发送、执行和响应]，当服务器收到命令数据的时候，也会由事件循环触发一个I/O事件，执行到<code>readQueryFromClient</code>回调。这个函数的实现就是在处理命令的[执行和响应]了。因此，下面我们看一下这个函数的执行流程图。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/redis/process_query_flow_chart.png?raw=true" width="50%" height="50%"></div><br><div align="center">图3：readQueryFromClient函数执行流程图</div><ul><li><p>从socket中读入数据，是按照流的方式。也就是说，站在应用层的角度，从底层网络层读入的数据，是由一个个字节组成的字节流。而我们需要从这些字节流中解析出完整的Redis命令，才能知道接下来如何处理。但由于网络传输的特点，我们并不能控制一次读入多少个字节。实际上，即使服务器只是收到一个Redis命令的部分数据（哪怕只有一个字节），也有可能触发一次I/O事件回调。这时我们是调用<code>read</code>系统API来读入数据的。虽然调用<code>read</code>时我们可以指定期望读取的字节数，但它并不会保证一定能返回期望长度的数据。比如我们想读100个字节，但可能只能读到80个字节，剩下的20个字节可能还在网络传输中没有到达。这种情况给接收Redis命令的过程造成了很大的麻烦：首先，可能我们读到的数据还不够一个完整的命令，这时我们应该继续等待更多的数据到达。其次，我们可能一次性收到了大量的数据，里面包含不止一个命令，这时我们必须把里面包含的所有命令都解析出来，而且要正确解析到最后一个完整命令的边界。如果最后一个完整命令后面还有多余的数据，那么这些数据应该留在下次有更多数据到达时再处理。这个复杂的过程一般称为「粘包」。</p></li><li><p>「粘包」处理的第一个表现，就是当尝试解析出一个完整的命令时，如果解析失败了，那么上面的流程就直接退出了。接下来，如果有更多数据到达，事件循环会再次触发I/O事件回调，重新进入上面的流程继续处理。</p></li><li><p>「粘包」处理的第二个表现，是上面流程图中的大循环。只要暂存输入数据的<code>query buffer</code>中还有数据可以处理，那么就不停地去尝试解析完整命令，直到把里面所有的完整命令都处理完，才退出循环。</p></li><li><p>查命令表那一步，就是查找本文前面提到的由<code>populateCommandTable</code>初始化的命令表，这个命令表存储在server.c的全局变量<code>redisCommandTable</code>当中。命令表中存有各个Redis命令的执行入口。</p></li><li><p>对于命令的执行结果，在上面的流程图中只是最后存到了一个输出buffer中，并没有真正输出给客户端。输出给客户端的过程不在这个流程当中，而是由另外一个同样是由事件循环驱动的过程来完成。这个过程涉及很多细节，我们在这里先略过，留在后面第四部分再来讨论。</p></li></ul><h2 id="事件机制介绍"><a href="#事件机制介绍" class="headerlink" title="事件机制介绍"></a>事件机制介绍</h2><p>在本文第一部分，我们提到过，我们必须有一种机制能够同时等待I/O和timer这两种事件的发生。这一机制就是系统底层的I/O多路复用机制(I/O multiplexing)。但是，在不同的系统上，存在多种不同的I/O多路复用机制。因此，为了方便上层程序实现，Redis实现了一个简单的事件驱动程序库，即ae.c的代码，它屏蔽了系统底层在事件处理上的差异，并实现了我们前面一直在讨论的事件循环。</p><p>在Redis的事件库的实现中，目前它低层支持4种I/O多路复用机制：</p><ul><li><p><code>select</code>系统调用，这应该是最早出现的一种I/O多路复用机制了，于1983年在4.2BSD Unix中被首次使用。它是POSIX规范的一部分。另外，跟select类似的还有一个poll系统调用，它是1986年在SVR3 Unix系统中首次使用的，也遵循POSIX规范。只要是遵循POSIX规范的操作系统，它就能支持select和poll机制，因此在目前我们常见的系统中这两种I/O事件机制一般都是支持的。</p></li><li><p><code>epoll机制</code>。epoll是比select更新的一种I/O多路复用机制，最早出现在Linux内核的2.5.44版本中。它被设计出来是为了代替旧的select和poll，提供一种更高效的I/O机制。注意，epoll是Linux系统所特有的，它不属于POSIX规范。</p></li><li><p><code>kqueue机制</code>。kqueue最早是2000年在FreeBSD 4.1上被设计出来的，后来也支持NetBSD、OpenBSD、DragonflyBSD和macOS系统。它和Linux系统上的epoll是类似的。</p></li><li><p><code>event ports</code>。这是在illumos系统上特有的一种I/O事件机制。</p></li></ul><p>既然在不同系统上有不同的事件机制，那么Redis在不同系统上编译时采用的是哪个机制呢？由于在上面四种机制中，后三种是更现代，也是比<code>select</code>和<code>poll</code>更高效的方案，因此Redis优先选择使用后三种机制。</p><p>通过上面对各种I/O机制所适用的操作系统的总结，我们很容易看出，如果你在macOS上编译Redis，那么它底层会选用<code>kqueue</code>；而如果在Linux上编译则会选择<code>epoll</code>，这也是Redis在实际运行中比较常见的情况。</p><p>现在我们回过头来再看一下底层的这些I/O事件机制是如何支持了Redis的事件循环的（下面的描述是对本文前面第一部分中事件循环流程的细化）：</p><ul><li>首先，向事件循环中注册I/O事件回调的时候，需要指定哪个回调函数注册到哪个事件上（事件用文件描述符来表示）。事件和回调函数的对应关系，由Redis上层封装的事件驱动程序库来维护。具体参见函数<code>aeCreateFileEvent</code>的代码。</li><li>类似地，向事件循环中注册timer事件回调的时候，需要指定多长时间之后执行哪个回调函数。这里需要记录哪个回调函数预期在哪个时刻被调用，这也是由Redis上层封装的事件驱动程序库来维护的。具体参见函数<code>aeCreateTimeEvent</code>的代码。</li><li>底层的各种事件机制都会提供一个等待事件的操作，比如epoll提供的epoll_wait API。这个等待操作一般可以指定预期等待的事件列表（事件用文件描述符来表示），并同时可以指定一个超时时间（即最大等待多长时间）。在事件循环中需要等待事件发生的时候，就调用这个等待操作，传入之前注册过的所有I/O事件，并把最近的timer事件所对应的时刻转换成这里需要的超时时间。具体参见函数<code>aeProcessEvents</code>的代码。</li><li>从上一步的等待操作中唤醒，有两种情况：如果是I/O事件发生了，那么就根据触发的事件查到I/O回调函数，进行调用；如果是超时了，那么检查所有注册过的timer事件，对于预期调用时刻超过当前时间的回调函数都进行调用。</li></ul><p>最后，关于事件机制，还有一些信息值得关注：业界已经有一些比较成熟的开源的事件库了，典型的比如libevent和libev。一般来说，这些开源库屏蔽了非常复杂的底层系统细节，并对不同的系统版本实现做了兼容，是非常有价值的。那为什么Redis的作者还是自己实现了一套呢？在Google Group的一个帖子上，Redis的作者给出了一些原因。帖子地址如下：</p><ul><li><a href="https://groups.google.com/group/redis-db/browse_thread/thread/b52814e9ef15b8d0/" target="_blank" rel="noopener">https://groups.google.com/group/redis-db/browse_thread/thread/b52814e9ef15b8d0/</a></li></ul><p>原因大致总结起来就是：</p><ul><li>不想引入太大的外部依赖。比如libevent太大了，比Redis的代码库还大。</li><li>方便做一些定制化的开发。</li><li>第三方库有时候会出现一些意想不到的bug。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF攻击与防御</title>
      <link href="/2019/04/02/CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
      <url>/2019/04/02/CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
      
        <content type="html"><![CDATA[<p>转载至 <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p><hr><h2 id="一、CSRF是什么？"><a href="#一、CSRF是什么？" class="headerlink" title="一、CSRF是什么？"></a>一、CSRF是什么？</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h2 id="二、CSRF可以做什么？"><a href="#二、CSRF可以做什么？" class="headerlink" title="二、CSRF可以做什么？"></a>二、CSRF可以做什么？</h2><p>你这可以这么理解CSRF攻击：<strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong>。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h2 id="三、CSRF漏洞现状"><a href="#三、CSRF漏洞现状" class="headerlink" title="三、CSRF漏洞现状"></a>三、CSRF漏洞现状</h2><p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p><h2 id="四、CSRF的原理"><a href="#四、CSRF的原理" class="headerlink" title="四、CSRF的原理"></a>四、CSRF的原理</h2><p>下图简单阐述了CSRF攻击的思想：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/web%E5%AE%89%E5%85%A8/2009040916453171.jpg?raw=true" width="50%" height="50%"></div><br><div align="center">图1：CSRF攻击原理</div><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1.<strong>登录受信任网站A，并在本地生成Cookie。</strong></p><p>　　2.<strong>在不登出A的情况下，访问危险网站B。</strong></p><p>　　看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><p>　　1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p><p>　　2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</p><p>　　3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p><p>　　上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></p><p>危险网站B，它里面有一段HTML的代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure></p><p>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</p><p>为什么会这样呢？<strong>原因是银行网站A违反了HTTP规范，使用GET请求更新资源</strong>。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源”<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&quot;，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作....." target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&quot;，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作.....</a>.</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p><p>银行网站A的WEB表单如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"Transfer.php"</span> method=<span class="string">"POST"</span>&gt;</span><br><span class="line">　　&lt;p&gt;ToBankId: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"toBankId"</span> /&gt;&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;Money: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"money"</span> /&gt;&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"Transfer"</span> /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面Transfer.php如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (isset(<span class="variable">$_REQUEST</span>[<span class="string">'toBankId'</span>] &amp;&amp;　isset(<span class="variable">$_REQUEST</span>[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_REQUEST</span>[<span class="string">'toBankId'</span>],　<span class="variable">$_REQUEST</span>[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>危险网站B，仍然只是包含那句HTML代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><p>　经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (isset(<span class="variable">$_POST</span>[<span class="string">'toBankId'</span>] &amp;&amp;　isset(<span class="variable">$_POST</span>[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_POST</span>[<span class="string">'toBankId'</span>],　<span class="variable">$_POST</span>[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>然而，危险网站B与时俱进，它改了一下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">　　　　　　<span class="keyword">function</span> steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[<span class="string">"steal"</span>];</span><br><span class="line">　　     　　      iframe.document.Submit(<span class="string">"transfer"</span>);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=<span class="string">"steal()"</span>&gt;</span><br><span class="line">　　　　&lt;iframe name=<span class="string">"steal"</span> display=<span class="string">"none"</span>&gt;</span><br><span class="line">　　　　　　&lt;form method=<span class="string">"POST"</span> name=<span class="string">"transfer"</span>　action=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span><br><span class="line">　　　　　　　　&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"toBankId"</span> value=<span class="string">"11"</span>&gt;</span><br><span class="line">　　　　　　　　&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"money"</span> value=<span class="string">"1000"</span>&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!</p><p>总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个<img>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p><p>理解上面的3种攻击模式，其实可以看出，<strong>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</strong></p><h2 id="五-CSRF的防御"><a href="#五-CSRF的防御" class="headerlink" title="五.CSRF的防御"></a>五.CSRF的防御</h2><p>我总结了一下看到的资料，CSRF的防御可以从<strong>服务端</strong>和<strong>客户端</strong>两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p><h3 id="1-服务器端进行CSRF防御"><a href="#1-服务器端进行CSRF防御" class="headerlink" title="1.服务器端进行CSRF防御"></a>1.服务器端进行CSRF防御</h3><p>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><h4 id="1-Cookie-Hashing-所有表单都包含同一个伪随机值-："><a href="#1-Cookie-Hashing-所有表单都包含同一个伪随机值-：" class="headerlink" title="1).Cookie Hashing(所有表单都包含同一个伪随机值)："></a>1).Cookie Hashing(所有表单都包含同一个伪随机值)：</h4><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　//构造加密的Cookie信息</span><br><span class="line">　　　　<span class="variable">$value</span> = “DefenseSCRF”;</span><br><span class="line">　　　　setcookie(”cookie”, <span class="variable">$value</span>, time()+3600);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　<span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">'cookie'</span>]);</span><br><span class="line">?&gt;</span><br><span class="line">　　&lt;form method=”POST” action=”transfer.php”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”text” name=”toBankId”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”text” name=”money”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”hidden” name=”<span class="built_in">hash</span>” value=”&lt;?=<span class="variable">$hash</span>;?&gt;”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”submit” name=”submit” value=”Submit”&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后再服务器端进行Hash值验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isset(<span class="variable">$_POST</span>[<span class="string">'check'</span>])) &#123;</span><br><span class="line">        <span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">'cookie'</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">'check'</span>] == <span class="variable">$hash</span>) &#123;</span><br><span class="line">        　　 doJob();</span><br><span class="line">　　     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　 　　//...</span><br><span class="line">         </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　       &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。</p><h4 id="2-验证码"><a href="#2-验证码" class="headerlink" title="2).验证码"></a>2).验证码</h4><p>这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p><h4 id="3-One-Time-Tokens-不同的表单包含一个不同的伪随机值"><a href="#3-One-Time-Tokens-不同的表单包含一个不同的伪随机值" class="headerlink" title="3).One-Time Tokens(不同的表单包含一个不同的伪随机值)"></a>3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</h4><p>在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p><h4 id="4-slim框架CSRF实现"><a href="#4-slim框架CSRF实现" class="headerlink" title="4)slim框架CSRF实现"></a>4)slim框架CSRF实现</h4><p><a href="https://github.com/slimphp/Slim-Csrf" target="_blank" rel="noopener">slim框架的csrf预防源码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码文件</title>
      <link href="/2019/03/29/%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/"/>
      <url>/2019/03/29/%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>go文件主要分为下面3类:</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/go/9d08647d238e21e7184d60c0afe5afcb.png?raw=true" width="50%" height="50%" alt="内容"></div><br><div align="center">图1：go文件</div>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作区和GOPATH</title>
      <link href="/2019/03/29/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH/"/>
      <url>/2019/03/29/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH/</url>
      
        <content type="html"><![CDATA[<p>我们学习Go语言时，第一件要做的是，就是根据自己电脑的操作系统和计算架构，从<a href="https://golang.google.cn" target="_blank" rel="noopener">Go语言官网</a>下载对应的二进制包，也就是拿来即用的安装包。</p><p>随后，<strong>解压安装包</strong>、<strong>放置到某个目录</strong>、<strong>配置环境变量</strong>，并在命令行输入 <code>go version</code> 来验证是否安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@www package]# ls go1.12.1.linux-amd64.tar.gz </span><br><span class="line">go1.12.1.linux-amd64.tar.gz</span><br><span class="line">[root@www package]# tar zxvf go1.12.1.linux-amd64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置GOROOT、GOPATH、GOBIN环境变量</span></span><br><span class="line">[root@www ~]# vim .bash_profile</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin:/usr/local/php/bin:/usr/local/go/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/root/peek-a-bow</span><br><span class="line">export GOBIN=/root/peek-a-bow/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建工作目录</span></span><br><span class="line">mkdir -p /root/peek-a-bow/&#123;src,bin,pkg&#125;</span><br></pre></td></tr></table></figure><p>在整个安装过程中，需要配置3个环境变量，简单介绍一下:</p><ul><li>GOROOT: Go语言的安装目录</li><li>GOPATH: 自定义的工作目录</li><li>GOBIN: Go语言生成的可执行文件的目录</li></ul><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区（workspace）。</p><p>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file）,以及安装(install)后的归档文件（archive file）和可执行文件（executable file）。</p><p>事实上，由于Go语言项目在其生命周期内的所有操作（编码依赖管理、构建、测试、安装等）基本上都是围绕着GOPATH和工作区进行的。它的背后有3个知识点需要注意:</p><ul><li>1.Go语言源码的组织是怎样的；</li><li>2.你是否了解源码安装后的结果；</li><li>3.你是否理解构建和安装Go程序的过程。</li></ul><h3 id="1-Go语言源码组织方式"><a href="#1-Go语言源码组织方式" class="headerlink" title="1.Go语言源码组织方式"></a>1.Go语言源码组织方式</h3><p>Go语言是以代码包为基本组织单位的。所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录和代码包为主线的。</p><h3 id="2-了解源码安装后的结果"><a href="#2-了解源码安装后的结果" class="headerlink" title="2.了解源码安装后的结果"></a>2.了解源码安装后的结果</h3><p>源码文件在安装过程中，如果产生了归档文件，就会放进该工作区的pkg子目录；如果产生了可执行文件，就会放进该工作区的bin子目录。</p><h3 id="3-理解构建和安装Go程序的过程"><a href="#3-理解构建和安装Go程序的过程" class="headerlink" title="3.理解构建和安装Go程序的过程"></a>3.理解构建和安装Go程序的过程</h3><p>构建使用 <code>go build</code>,安装使用命令 <code>go install</code>。构建和安装代码包的时候都会执行编译、打包等操作。并且，这些操作产生的任何文件都会先被保存到某个临时的目录中。</p><p>如果构建的是<strong>库源码</strong>文件,那么操作结果只会保存在临时目录中，安装<strong>库源码</strong>文件，那么它的结果会被搬运到它所在工作区的pkg目录下的某个子目录中。</p><p>如果构建的是<strong>命令源码</strong>文件，那么它的操作结果文件会被搬运到源码文件所在的目录中。如果安装的是<strong>命令源码</strong>文件，那么结果文件会被搬运到它所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go string 实现原理剖析</title>
      <link href="/2019/03/28/Go-string-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
      <url>/2019/03/28/Go-string-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>倒排索引原理</title>
      <link href="/2019/03/27/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
      <url>/2019/03/27/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>关于<a href="https://www.elastic.co/" target="_blank" rel="noopener">ElasticSearch</a>为什么搜索这么快，大家应该有所了解，主要是利用倒排索引数据结构，下面简单介绍一下倒排索引。</p><h2 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h2><p>任何事物都是相对的，有倒排索引(inverted index)，当然也会有正向索引(forward index)。</p><h3 id="正向索引结构"><a href="#正向索引结构" class="headerlink" title="正向索引结构"></a>正向索引结构</h3><p>在搜索引擎中，每个文件(document)对应一个文件id(document id)，文件内容可以看作是一些列关键词的集合(实际上，在搜索引擎库中，关键词也转化为关键词id)。例如“文档1”经过分词，提取了20个关键词，每个关键词都会记录它在文档中的出现次数和出现位置。</p><p>得到正向索引结构如下：</p><p>“文档1”的ID &gt; 关键词1：出现次数，出现位置列表；关键词2：出现次数，出现位置列表；……</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/forward_index.png" width="50%" height="50%"></div><br><div align="center">图1：正向索引结构</div><p><strong>通过文档，去找关键词</strong>。</p><h3 id="正向索引查找过程"><a href="#正向索引查找过程" class="headerlink" title="正向索引查找过程"></a>正向索引查找过程</h3><p>当用户在主页上搜索关键词“<strong>华为手机</strong>”时，假设只存在正向索引(forward index)，那么就需要<strong>扫描索引库中的所有文档</strong>，找出所有包含关键词“<strong>华为手机</strong>”的文档，再根据<strong>打分模型</strong>进行打分，排出名次后呈现给用户。因为互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="倒排索引结构"><a href="#倒排索引结构" class="headerlink" title="倒排索引结构"></a>倒排索引结构</h3><p>由于正向索引无法满足实时返回排名结果的要求，所以，搜索引擎会将正向索引重新构建为倒排索引，即把<strong>文件id对应到关键词的映射</strong>转化为<strong>关键词到文件id的映射</strong>，每个关键词对应着一些列文件，这些文件中都出现这个关键词。</p><p>得到倒排索引的结构如下：</p><p>“关键词1” ：“文档1”的id ， “文档2”的id ，……。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/reverted-index.png" width="50%" height="50%" alt="倒排索引"></div><br><div align="center">图2：倒排索引结构</div><p><strong>通过关键词，去找文档</strong>。</p><h3 id="单词-文档矩阵"><a href="#单词-文档矩阵" class="headerlink" title="单词-文档矩阵"></a>单词-文档矩阵</h3><p>单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%8D%95%E8%AF%8D%E6%96%87%E6%A1%A3%E7%9F%A9%E9%98%B5.png" width="50%" height="50%" alt="单词文档矩阵"></div><br><div align="center">图3：单词-文档矩阵</div><p>从纵向看（即从文档这个维度看），每列代表文档包含了哪些单词，比如文档1包含了词汇1和词汇4，而不包含其它单词。</p><p>从横向看（即从单词这个维度看），每行代表了哪些文档包含了这个单词。比如词汇1来说，文档1和文档4中出现过单词1，而其它文档不包含词汇1。</p><p>搜索引擎，其实就是实现了 “<strong>单词-文档矩阵</strong>”的具体<strong>数据结构</strong>，可以有不同的方式来实现上述概念模型，比如“<strong>倒排索引</strong>”、“<strong>签名文件</strong>”、“<strong>后缀树</strong>”等方式。目前ElasticSearch中是使用“倒排索引”实现单词到文档映射关系。</p><h3 id="倒排索引基本概念"><a href="#倒排索引基本概念" class="headerlink" title="倒排索引基本概念"></a>倒排索引基本概念</h3><p>文档(document):一般搜索引擎的处理对象是互联网网页，而文档这个概念要更宽泛些，代表以文本形式存在的存储对象，相比网页来说，涵盖更多种形式，比如Word，PDF，html，XML等不同格式的文件都可以称之为文档。再比如一封邮件，一条短信，一条微博也可以称之为文档。在本书后续内容，很多情况下会使用文档来表征文本信息。</p><p>文档集合(Document Collection)：由若干文档构成的集合称之为文档集合。比如海量的互联网网页或者说大量的电子邮件都是文档集合的具体例子。</p><p>文档编号(Document ID):在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。</p><p>单词编号(Word ID):与文档编号类似，搜索引擎内部以唯一的编号来表征某个单词，单词编号可以作为某个单词的唯一表征。</p><p>倒排索引(Inverted Index):倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p><p>单词字典(Lexicon)：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</p><p>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</p><p>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</p><p>关于这些概念之间的关系，通过图4可以比较清晰的看出来。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8%E6%A6%82%E5%BF%B5%E5%9B%BE.png" width="50%" height="50%" alt="倒排列表模型"></div><br><div align="center">图4：倒排列表模型</div><h3 id="倒排索引简单实例"><a href="#倒排索引简单实例" class="headerlink" title="倒排索引简单实例"></a>倒排索引简单实例</h3><p>倒排索引从逻辑结构和基本思路上来讲非常简单。下面我们通过具体实例来进行说明，使得读者能够对倒排索引有一个宏观而直接的感受。</p><p> 假设文档集合包含五个文档，每个文档内容如图3所示，在图中最左端一栏是每个文档对应的文档编号。我们的任务就是对这个文档集合建立倒排索引。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E6%96%87%E6%A1%A3%E9%9B%86%E5%90%88.png" width="50%" height="50%" alt="文档集合"></div><br> <div align="center">图5：文档集合</div><p> 中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引（参考图6）。在图6中，“单词ID”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" width="50%" height="50%" alt="最简单的倒排索引"></div><br> <div align="center">图6：最简单的倒排索引</div><p> 之所以说图6所示倒排索引是最简单的，是因为这个索引系统只记载了哪些文档包含某个单词，而事实上，索引系统还可以记录除此之外的更多信息。图7是一个相对复杂些的倒排索引，与图6的基本索引系统比，在单词对应的倒排列表中不仅记录了文档编号，还记载了单词频率信息（TF），即这个单词在某个文档中的出现次数，之所以要记录这个信息，是因为词频信息在搜索结果排序时，计算查询和文档相似度是很重要的一个计算因子，所以将其记录在倒排列表中，以方便后续排序时进行分值计算。在图7的例子里，单词“创始人”的单词编号为7，对应的倒排列表内容为：（3:1），其中的3代表文档编号为3的文档包含这个单词，数字1代表词频信息，即这个单词在3号文档中只出现过1次，其它单词对应的倒排列表所代表含义与此相同。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%B8%A6%E6%9C%89%E8%AF%8D%E9%A2%91%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" width="50%" height="50%" alt="带有单词频率信息的倒排索引"></div><br> <div align="center">图7：带有单词频率信息的倒排索引</div><p> 实用的倒排索引还可以记载更多的信息，图8所示索引系统除了记录文档编号和单词频率信息外，额外记载了两类信息，即每个单词对应的“文档频率信息”（对应图8的第三栏）以及在倒排列表中记录单词在某个文档出现的位置信息。</p><p> “文档频率信息”代表了在文档集合中有多少个文档包含某个单词，之所以要记录这个信息，其原因与单词频率信息一样，这个信息在搜索结果排序计算中是非常重要的一个因子。而单词在某个文档中出现的位置信息并非索引系统一定要记录的，在实际的索引系统里可以包含，也可以选择不包含这个信息，之所以如此，因为这个信息对于搜索系统来说并非必需的，位置信息只有在支持“短语查询”的时候才能够派上用场。</p><p> 以单词“拉斯”为例，其单词编号为8，文档频率为2，代表整个文档集合中有两个文档包含这个单词，对应的倒排列表为：{(3;1;<4>)，(5;1;<4>)},其含义为在文档3和文档5出现过这个单词，单词频率都为1，单词“拉斯”在两个文档中的出现位置都是4，即文档中第四个单词是“拉斯”。</4></4></p><p> 图7所示倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此，区别无非是采取哪些具体的数据结构来实现上述逻辑结构。</p><p> 有了这个索引系统，搜索引擎可以很方便地响应用户的查询，比如用户输入查询词“Facebook”，搜索系统查找倒排索引，从中可以读出包含这个单词的文档，这些文档就是提供给用户的搜索结果，而利用单词频率信息、文档频率信息即可以对这些候选搜索结果进行排序，计算文档和查询的相似性，按照相似性得分由高到低排序输出，此即为搜索系统的部分内部流程。</p><h2 id="单词词典"><a href="#单词词典" class="headerlink" title="单词词典"></a>单词词典</h2><p>单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。</p><p>对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词，这直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找，常用的数据结构包括<strong>哈希加链表结构</strong>和<strong>树形词典结构</strong>。</p><h3 id="哈希加链表"><a href="#哈希加链表" class="headerlink" title="哈希加链表"></a>哈希加链表</h3><p>图8是这种词典结构的示意图。这种词典结构主要由两个部分构成：</p><p>主体部分是哈希表，每个哈希表项保存一个指针，指针指向冲突链表，在冲突链表里，相同哈希值的单词形成链表结构。之所以会有冲突链表，是因为两个不同单词获得相同的哈希值，如果是这样，在哈希方法里被称做是一次冲突，可以将相同哈希值的单词存储在链表里，以供后续查找。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%93%88%E5%B8%8C%E5%8A%A0%E9%93%BE%E8%A1%A8.png" width="50%" height="50%" alt="哈希加链表"></div><br><div align="center">图8：哈希加链表结构</div><p>在建立索引的过程中，词典结构也会相应地被构建出来。比如在解析一个新文档的时候，对于某个在文档中出现的单词T，首先利用哈希函数获得其哈希值，之后根据哈希值对应的哈希表项读取其中保存的指针，就找到了对应的冲突链表。如果冲突链表里已经存在这个单词，说明单词在之前解析的文档里已经出现过。如果在冲突链表里没有发现这个单词，说明该单词是首次碰到，则将其加入冲突链表里。通过这种方式，当文档集合内所有文档解析完毕时，相应的词典结构也就建立起来了。</p><p>在响应用户查询请求时，其过程与建立词典类似，不同点在于即使词典里没出现过某个单词，也不会添加到词典内。以图8为例，假设用户输入的查询请求为单词3，对这个单词进行哈希，定位到哈希表内的2号槽，从其保留的指针可以获得冲突链表，依次将单词3和冲突链表内的单词比较，发现单词3在冲突链表内，于是找到这个单词，之后可以读出这个单词对应的倒排列表来进行后续的工作，如果没有找到这个单词，说明文档集合内没有任何文档包含单词，则搜索结果为空。</p><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p> B树（或者B+树）是另外一种高效查找结构。B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式则无须数据满足此项要求。</p><p> B树形成了层级查找结构，中间节点用于指出一定顺序范围的词典项目存储在哪个子树中，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/content.png" width="50%" height="50%" alt="内容"></div><br><div align="center">图9：文档集合</div><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/content2.png" width="50%" height="50%" alt="倒排索引结构"></div><br><div align="center">图10：倒排索引结构</div><ul><li>单词ID：记录每个单词的单词编号；</li><li>单词：对应的单词；</li><li>文档频率：代表文档集合中有多少个文档包含某个单词</li><li>倒排列表：包含单词ID及其他必要信息</li><li>DocId：单词出现的文档id</li><li>TF：单词在某个文档中出现的次数</li><li>POS：单词在文档中出现的位置</li></ul><p>以单词“加盟”为例，其单词编号为6，文档频率为3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为{(2;1;<4>),(3;1;<7>),(5;1;<5>)}，含义是在文档2，3，5出现过这个单词，在每个文档的出现过1次，单词“加盟”在第一个文档的POS是4，即文档的第四个单词是“加盟”，其他的类似。</5></7></4></p><p>这个倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 倒排索引 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
