<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>huany</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meichaofan.github.io/"/>
  <updated>2019-04-12T15:55:15.081Z</updated>
  <id>https://meichaofan.github.io/</id>
  
  <author>
    <name>meichaofan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker:从进程说起</title>
    <link href="https://meichaofan.github.io/2019/04/12/docker-process/"/>
    <id>https://meichaofan.github.io/2019/04/12/docker-process/</id>
    <published>2019-04-12T15:54:23.000Z</published>
    <updated>2019-04-12T15:55:15.081Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Docker" scheme="https://meichaofan.github.io/tags/Docker/"/>
    
      <category term="容器" scheme="https://meichaofan.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用make</title>
    <link href="https://meichaofan.github.io/2019/04/09/02-use-make/"/>
    <id>https://meichaofan.github.io/2019/04/09/02-use-make/</id>
    <published>2019-04-08T18:12:59.000Z</published>
    <updated>2019-04-08T18:14:40.009Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="C" scheme="https://meichaofan.github.io/tags/C/"/>
    
      <category term="Makefile" scheme="https://meichaofan.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>启用编译器</title>
    <link href="https://meichaofan.github.io/2019/04/09/01-dust-off-that-compiler/"/>
    <id>https://meichaofan.github.io/2019/04/09/01-dust-off-that-compiler/</id>
    <published>2019-04-08T17:39:05.000Z</published>
    <updated>2019-04-08T18:03:38.997Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个最简单的C程序,hello-world.c：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    puts("Hello world.");</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make hello-world</span><br><span class="line">cc hello-world.c -o hello-world</span><br></pre></td></tr></table></figure><p>现在，你可以运行并可以看到程序输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> ./hello-world</span><br><span class="line">Hello World.</span><br></pre></td></tr></table></figure><p>思考：</p><ul><li>1.make指令的运行原理和流程</li><li>2.puts函数的作用<br> C 库函数 int puts(const char *str) 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</li><li><p>3.C语言中的空字符<br> 在C语言中空字符用’\0’表示;<br> ‘\0’对应的整数值是0，所以给一个字符变量赋值为空字符时，以下两种都是可以的：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch=&apos;\0&apos;;</span><br><span class="line">char ch=0;</span><br></pre></td></tr></table></figure></li><li><p>4.字符串<br> 字符串就是一串零个或多个字符，并且以位模式为全0的NUL字节即空字符(‘\0’)结尾。C语言中字符串没有显示的数据类型，字符串通常存储在字符数组或动态分配的内存中，在编码操作中通常将整个字符串作为操作对象，常用操作包括复制、查找、比较等。</p></li><li>5.空字符与字符串<ul><li>1、空字符是字符串的终止符。注：空字符本身不是字符串的一部分，所以字符串的长度并不包含空字符； </li><li>2、操作字符串时，必须保证字符串以空字符结尾(注：不以空字符结尾的字符序列，不是字符串)。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个最简单的C程序,hello-world.c：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="C" scheme="https://meichaofan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>笨方法学C</title>
    <link href="https://meichaofan.github.io/2019/04/09/learn-c-the-hard-way/"/>
    <id>https://meichaofan.github.io/2019/04/09/learn-c-the-hard-way/</id>
    <published>2019-04-08T16:55:42.000Z</published>
    <updated>2019-04-08T17:22:47.803Z</updated>
    
    <content type="html"><![CDATA[<p>这几年，我一直在学习编程语言，从JAVA、PHP、JS到Go，其实我一直想学好的是C语言，C即是基础。这个《笨方法学C》的读书系列，希望自己一定要坚持下来，好好学习，好好总结。</p><p>这本书的目的是让你足够熟悉C语言，并能够使用它编写自己的软件，或者修改其他人的代码。你需要学习下面这些东西来达到这一阶段：</p><ul><li>C的基本语法和编写习惯;</li><li>编译,make文件和链接;</li><li>寻找和预防bug;</li><li>防御性编程实战;</li><li>使C的代码崩溃;</li><li>编写基本的Unix系统软件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几年，我一直在学习编程语言，从JAVA、PHP、JS到Go，其实我一直想学好的是C语言，C即是基础。这个《笨方法学C》的读书系列，希望自己一定要坚持下来，好好学习，好好总结。&lt;/p&gt;
&lt;p&gt;这本书的目的是让你足够熟悉C语言，并能够使用它编写自己的软件，或者修改其他人的代码
      
    
    </summary>
    
    
      <category term="C" scheme="https://meichaofan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码从哪里读起?</title>
    <link href="https://meichaofan.github.io/2019/04/03/Redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/"/>
    <id>https://meichaofan.github.io/2019/04/03/Redis源码从哪里读起/</id>
    <published>2019-04-03T15:52:12.000Z</published>
    <updated>2019-04-09T11:46:06.978Z</updated>
    
    <content type="html"><![CDATA[<p>转载至 <a href="http://zhangtielei.com/posts/blog-redis-how-to-start.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-how-to-start.html</a></p><hr><h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>Redis使用C语言写的。首先，你应该从main函数读起。但是我们在读的时候应该抓住一条主线，也就是当我们向Redis输入一条命令的时候，代码是如何一步一步执行的。这样我们就可以先从外部观察，尝试执行一些命令，在了解了这些命令执行的外部表现之后，再钻进去看对应的源码是如何实现的。要想读懂这些代码，首先我们需要理解Redis的事件机制。而且，一旦理解了<strong>Redis的事件循环（Event Loop）</strong>的机制，我们还会搞明白一个有趣的问题：为什么Redis是单线程执行却能同时处理多个请求？（当然严格来说Redis运行并不是只有一个线程，但除了主线程外，Redis的其它线程只是起辅助作用，它们是一些在后台运行做异步耗时任务的线程）。</p><p>从main函数开始，沿着代码执行路径，实际上我们可以一直追下去。但为了让本文不至于太过冗长，我们还是限定一下返回。本文的目标就定为：引领读者从main函数开始，一步步追踪下去，最终到达任一Redis命令执行入口。这样接下来就可以与<strong>Redis内部数据结构详解</strong>的一些列文章衔接上。</p><p>为了表述清楚，本文按照如下思路进行：</p><ul><li>1.先概括地介绍整个代码初始化流程（从main函数开始）和事件循环的结构；</li><li>2.再概括地介绍对于Redis命令请求的处理流程；</li><li>3.重点介绍事件机制；</li><li>4.对于前面介绍的各个代码流程处理，给出详细的代码调用关系，方便随时查阅；</li></ul><p>根据这样几部分的划分，如果你只想粗读大致的处理流程，那么只需要阅读前两个部分就可以了。而后两部分则会深入到某些值得关注的细节。</p><p>注：本文的分析基于Redis源码的5.0分支。</p><h2 id="初始化流程和事件循环概述"><a href="#初始化流程和事件循环概述" class="headerlink" title="初始化流程和事件循环概述"></a>初始化流程和事件循环概述</h2><p>Redis源码的main函数在源文件server.c中。main函数开始执行后的逻辑可以分为两个阶段：</p><ul><li>各种初始化（包括事件循环的初始化）</li><li>执行事件循环。</li></ul><p>这两个执行阶段可以用下面的流程图来表达：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/redis/main_start_event_loop.png?raw=true" width="50%" height="50%"></div><br><div align="center">图1：main函数执行逻辑</div><p>首先，我们开一下初始化阶段中的各个步骤：</p><ul><li><p><strong>配置加载和初始化</strong>，这一步表示Redis服务器基本数据结构和各种参数的初始化。在Redis源码中，Redis服务器就是用一个叫做redisServer的struct来表示的。 里面定义了Redis服务器赖以运行的各种参数，比如监听的端口号和文件描述符、当前连接的各个client端、Redis命令表（command table）配置、持久化相关的各种参数，等等。Redis服务器在运行时就是由一个<code>redisServer</code>类型的全局变量来表示的（变量名叫 <code>server</code>）,这一步的初始化主要对于这个全局变量进行初始化。在整个初始化过程中，有一个特别需要注意的函数：<code>populateCommandTable</code>。它初始化了Redis命令表，通过它可以由任意一个Redis命令的名字查找该命令的配置信息（比如该命令接受的命令参数个数、执行函数入口等）。在本文的第二部分，我们将会一起来看看如何从接受一个Redis命令的请求开始，一步步执行到查阅这个命令表，从而找到该命令的执行入口。另外，这一步中还有一个值得一提的地方，在对全局的<code>redisServer</code>结构进行初始化之后，还需要从配置文件（redis.conf）中加载配置。这个过程可能覆盖掉之前的初始化过的<code>redisServer</code>结构中的某些参数。换句话说，就是先经过一轮初始化，保证Redis的各个内部数据结构以及参数都有缺省值，然后再从配置文件中加载自定义的配置。</p></li><li><p><strong>创建事件循环</strong>，在Redis中，事件循环是用一个叫aeEventLoop的struct来表示的。<strong>创建事件循环</strong>这一步主要就是创建一个aeEventLoop结构，并存储到<code>server</code>全局变量中。另外，事件循环的执行依赖系统低层的I/O多路复用机制，比如Linux系统上的epoll机制。因此，这一步也包含对于低层I/O多路复用机制的初始化。（调用系统API）</p></li><li><p><strong>开始监听socket</strong>。服务器程序需要监听才能收到请求。根据配置，这一步可能会打开两种监听：对于<code>TCP</code>连接的监听和对于<code>Unix domain socket</code>的监听，<code>Unix domain socket</code>是一种高效的进程间通信机制，在<code>POSIX</code>规范中也有明确的定义，用于在同一台主机上的两个不同进程之间进行通信，比使用TCP协议性能跟高（因为省去了协议栈的开销）。当使用Redis客户端连接同一台机器上的Redis服务器时，可以使用<code>Unix domain socket</code>进行连接。但是不管是哪一种监听，程序都会获得文件描述符，并存储到<code>server</code>全局变量中。对于TCP的监听来说，由于监听的IP地址和端口可以绑定多个，因此获得的用于监听TCP连接的文件描述符也可以包含多个。后面，程序就可以拿这一步获得的文件描述符去注册I/O事件回调了。</p></li><li><p><strong>注册timer事件回调</strong>。Redis作为一个单线程(single-threaded)的程序，它如果想调度一些异步执行的任务，比如比如周期性的执行过期key的回收动作，除了依赖事件循环机制，没有其它办法。这一步就是向前面刚刚创建好的事件循环中注册一个timer事件，并配置成可以周期性地执行一个回调函数：<code>serverCron</code>。由于Redis只有一个主线程，因此这个函数周期性的执行也是在这个线程内，它由事件循环来驱动（即在合适的时机调用），但不影响同一个线程上其它逻辑的执行（相当于按时间分片了）。<code>serverCron</code>函数到底做了什么呢？实际上，它除了周期性地执行过期key的回收动作，还执行了很多其它任务，比如主从重连、Cluster节点间的重连、bgsave和aof rewrite的触发执行，等等。</p></li><li><p><strong>注册I/O事件回调</strong>。Redis服务器最主要的工作就是监听I/O事件，从中分析出来自客户端的命令请求，执行命令，然后返回响应结果。对于I/O事件的监听，自然也是依赖事件循环。前面提到过，Redis可以打开两种监听：对于TCP连接的监听和对于Unix domain socket的监听。因此，这里就包含对于这两种I/O事件的回调的注册，两个回调函数分别是<code>acceptTcpHandler</code>和<code>acceptUnixHandler</code>。对于来自Redis客户端的请求的处理，就会走到这两个函数中去。我们在下一部分就会讨论到这个处理过程。另外，其实Redis在这里还会注册一个I/O事件，用于通过管道(pipe[6])机制与module进行双向通信。这个也不是本文的重点，我们暂时忽略它。</p></li><li><p><strong>初始化后台线程</strong>。Redis会创建一些额外的线程，在后台运行，专门用于处理一些耗时的并且可以被延迟执行的任务（一般是一些清理工作）。在Redis里面这些后台线程被称为bio（background i/o server）。它们负责的任务包括：可以延迟执行的文件关闭操作（比如unlink命令的执行），AOF的持久化写库操作（即fsync调用，但注意只有可以被延迟执行的fsync操作才在后台线程执行），还有一些大key的清除操作（比如flushdb async命令的执行）。可见bio这个名字有点名不副实，它做的事情不一定跟I/O有关。对于这些后台线程，我们可能还会产生一个疑问：前面的初始化过程，已经注册了一个timer事件回调，即<code>serverCron</code>函数，按说后台线程执行的这些任务似乎也可以放在<code>serverCron</code>中去执行。因为<code>serverCron</code>函数也是可以用来执行后台任务的。实际上这样做是不行的。前面我们已经提到过，<code>serverCron</code>由事件循环来驱动，执行还是在Redis主线程上，相当于和主线程上执行的其它操作（主要是对于命令请求的执行）按时间进行分片了。这样的话，<code>serverCron</code>里面就不能执行过于耗时的操作，否则它就会影响Redis执行命令的响应时间。因此，对于耗时的、并且可以被延迟执行的任务，就只能放到单独的线程中去执行了。</p></li><li><p><strong>启动事件循环</strong>。前面创建好了事件循环的结构，但还没有真正进入循环的逻辑。过了这一步，事件循环就运行起来，驱动前面注册的<strong>timer事件回调</strong>和<strong>I/O事件回调</strong>不断执行。</p></li></ul><p>注意：Redis服务器初始化其实还有很多其它事情，比如加载数据到内存，Cluster集群的初始化，module的初始化，等等。但为了简化，上面讨论的初始化流程，只列出了我们当前关注的步骤。本文关注的是由事件驱动的整个运行机制以及跟命令执行直接相关的部分，因此我们暂时忽略掉其它不太相关的步骤。</p><p>现在，我们继续去讨论上面流程图中的第二个阶段：事件循环。</p><p>我们先想一下为什么这里需要一个循环。</p><p>一个程序启动后，如果没有循环，那么它从第一条指令执行到最后一条指令，然后就只能退出了。而Redis作为一个服务端程序，是要等客户端不停地发来请求然后做相应的处理，不能自己执行完就退出了。因此，Redis启动后必定要进入一个无限循环，显然，程序在每一次循环执行中，如果有事件（包括客户端请求的I/O事件）发生，就会去处理这些事件。如果没有事件发生呢？程序显然也不应该空转，而是应该等待，把整个循环阻塞住。这里的等待，就是上面流程图的【等待事件发生】这个步骤。那么，当整个循环被阻塞住之后，什么时候再恢复执行呢？自然是等待的事件发生的时候，程序被重新唤醒，循环继续下去。这里需要的等待和唤醒操作，是怎么实现呢？它们都需要依赖系统的能力才能做到。</p><p>实际上，这种事件循环机制，对于开发过手机客户端的同学来说，是非常常见且基础的机制。比如跑在iOS/Android上面的App，这些程序都有一个消息循环，负责等待各种UI事件（点击、滑动等）的发生，然后进行处理。同理，对应到服务端，这个循环的原理可以认为差不多，只是等待和处理的事件变成是I/O事件了。另外，除了I/O事件，整个系统在运行过程中肯定还需要根据时间来调度执行一些任务，比如延迟100毫秒再执行某个操作，或者周期性地每隔1秒执行某个任务，这就需要等待和处理另外一种事件——timer事件。</p><p>timer事件和I/O事件是两种截然不同的事件，如何由事件循环来统一调度呢？假设事件循环有空闲的时候去等待I/O事件的发生，那么有可能一个timer事件先发生了，这时事件循环就没有被及时唤醒（仍在等待I/O事件）；反之，如果事件循环在等待timer事件，而一个I/O事件先发生了，那么同样没能够及时唤醒。因此，我们必须有一种机制能够同时等待这两种事件的发生。而恰好，一些系统的API可以做到这一点（比如我们前面提到的epoll机制）。</p><p>前面流程图的第二阶段已经比较清楚地表达出了事件循环的执行流程。在这里我们对于其中一些步骤需要关注的地方做一些补充说明：</p><ul><li><p><strong>查找最近的timer事件</strong>。如前所序，事件循环需要等待timerI/O两种事件。对于I/O事件，只需要明确等待的是哪些文件描述符就可以了；而对于timer事件，还需要经过一番比较，明确在当前这一轮循环中需要等待多长时间。由于系统运行过程中可能注册多个timer事件回调，比如先要求在100毫秒后执行一个回调，同时又要求在200毫秒后执行另外一个回调，这就要求事件循环在它的每一轮执行之前，首先要找出最近需要执行的那次timer事件。这样事件循环在接下来等待中就知道该等待多长时间（在这个例子中，我们需要等待100毫秒）。</p></li><li><p><strong>等待事件发生</strong>。这一步我们需要能够同时等待timer和I/O两种事件的发生。要做到这一点，我们依赖系统低层的I/O多路复用机制。这种机制一般是这样设计的：它允许我们针对多个文件描述符来等待对应的I/O事件发生，并同时可以指定一个最长的阻塞超时时间。如果在这段阻塞时间内，有I/O事件发生，那么程序会被唤醒继续执行；如果一直没有I/O事件发生，而是指定的时间先超时了，那么程序也会被唤醒。对于timer事件的等待，就是依赖这里的<strong>超时机制</strong>。当然，这里的超时时间也可以指定成无限长，这就相当于只等待I/O事件。我们再看一下上一步<strong>查找最近timer事件</strong>，查找完之后可能有三种结果，因此这一步等待也可能出现三种对应的情况：</p><ul><li>第一种情况，查找到了一个最近的timer事件，它要求在未来某一个时刻触发。那么，这一步只需要把这个未来时刻转换成阻塞超时时间即可。</li><li>第二种情况，查找到了一个最近的timer事件，但它要求的时刻已经过去了。那么，这时候它应该立刻被触发，而不应该再有任何等待。当然，在实现的时候还是调用了事件等待的API，只是把超时事件设置成0就可以达到这个效果。</li><li>第三种情况，没有查找到任何注册的timer事件。那么，这时候应该把超时时间设置成无限长。接下来只有I/O事件发生才能唤醒。</li></ul></li><li><p>判断有I/O事件发生还是超时。这里是程序从上一步（可能的）阻塞状态中恢复后执行逻辑。如果是I/O事件发生了，那么先指向I/O事件回调，然后根据需要把到期的timer事件的回调也执行掉（如果有的话）；如果是超时先发生了，那么表示只有timer事件需要触发（没有I/O事件发生），那么就直接把到期的timer事件的回调执行掉。</p></li><li><p><strong>执行I/O事件回调</strong>。我们前面提到的对于TCP连接的监听和对于Unix domain socket的监听，这两种I/O事件的回调函数acceptTcpHandler和acceptUnixHandler，就是在这一步被调用的。</p></li><li><p><strong>执行timer事件回调</strong>。我们前面提到的周期性回调函数<code>serverCron</code>，就是在这一步被调用的。一般情况下，一个timer事件被处理后，它就会被从队列中删除，不会再次执行了。但serverCron却是被周期性调用的，这是怎么回事呢？这是因为Redis对于timer事件回调的处理设计了一个小机制：timer事件的回调函数可以返回一个需要下次执行的毫秒数。如果返回值是正常的正值，那么Redis就不会把这个timer事件从事件循环的队列中删除，这样它后面还有机会再次执行。例如，按照默认的设置，serverCron返回值是100，因此它每隔100毫秒会执行一次（当然这个执行频率可以在redis.conf中通过hz变量来调整）。</p></li></ul><p>至此，Redis整个事件循环的轮廓我们就清楚了。Redis主要的处理流程，包括接收请求、执行命令，以及周期性地执行后台任务（<code>serverCron</code>），都是由这个事件循环驱动的。当请求到来时，I/O事件被触发，事件循环被唤醒，根据请求执行命令并返回响应结果；同时，后台异步任务（如回收过期的key）被拆分成若干小段，由timer事件所触发，夹杂在I/O事件处理的间隙来周期性地运行。这种执行方式允许仅仅使用一个线程来处理大量的请求，并能提供快速的响应时间。当然，这种实现方式之所以能够高效运转，除了事件循环的结构之外，还得益于系统提供的异步的I/O多路复用机制(I/O multiplexing)。事件循环使得CPU资源被分时复用了，不同代码块之间并没有「真正的」并发执行，但I/O多路复用机制使得CPU和I/O的执行是真正并发的。而且，使用单线程还有额外的好处：避免了代码的并发执行，在访问各种数据结构的时候都无需考虑线程安全问题，从而大大降低了实现的复杂度。</p><h2 id="Redis命令请求的处理流程概述"><a href="#Redis命令请求的处理流程概述" class="headerlink" title="Redis命令请求的处理流程概述"></a>Redis命令请求的处理流程概述</h2><p>我们在前面讨论[注册I/O事件回调]的时候提到过，Redis对于来自客户端的请求的处理，都会走到<code>acceptTcpHandler</code>和<code>acceptUnixHandler</code>这两个回调函数中去。实际上，这样的描述还过于粗略。</p><p>Redis客户端向服务器发送命令，可以细分为两个过程：</p><ul><li><p>1.<strong>建立连接</strong>。客户端发起连接请求（通过TCP或<code>Unix Domain Socket</code>）,服务器接受连接。</p></li><li><p>2.<strong>命令发送、执行和响应</strong>。连接一旦建立好，客户端就可以在这个新连接的基础上发送命令数据，服务器收到后执行这个命令，并把执行结果返回给客户端。而且，在新连接上，这整个的[命令发送、执行和响应]的过程就可以反复执行。</p></li></ul><p>上述第一个过程，「连接建立」，对应到服务端的代码，就是会走到<code>acceptTcpHandler</code>或<code>acceptUnixHandler</code>这两个回调函数中去。换句话说，Redis服务器每收到一个新的连接请求，就会由事件循环触发一个I/O事件，从而执行到<code>acceptTcpHandler</code>或<code>acceptUnixHandler</code>回调函数的代码。</p><p>接下来，从socket编程的角度，服务器应该调用<code>accept</code>系统API来接受连接请求，并为新的连接创建出一个socket。这个新的socket也就对应着一个新的文件描述符。为了在新的连接上能接收到客户端发来的命令，接下来必须在事件循环中为这个新的文件描述符注册一个I/O事件回调。这个过程的流程图如下：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/redis/accept_handler_flow_chart.png?raw=true" width="50%" height="50%"></div><br><div align="center">图2：接收客户端连接请求</div><p>从上面流程图可以看出，新的连接注册了一个I/O事件回调，即<code>readQueryFromClient</code>。也就是说，对应前面讲的第二个过程，[命令发送、执行和响应]，当服务器收到命令数据的时候，也会由事件循环触发一个I/O事件，执行到<code>readQueryFromClient</code>回调。这个函数的实现就是在处理命令的[执行和响应]了。因此，下面我们看一下这个函数的执行流程图。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/redis/process_query_flow_chart.png?raw=true" width="50%" height="50%"></div><br><div align="center">图3：readQueryFromClient函数执行流程图</div><ul><li><p>从socket中读入数据，是按照流的方式。也就是说，站在应用层的角度，从底层网络层读入的数据，是由一个个字节组成的字节流。而我们需要从这些字节流中解析出完整的Redis命令，才能知道接下来如何处理。但由于网络传输的特点，我们并不能控制一次读入多少个字节。实际上，即使服务器只是收到一个Redis命令的部分数据（哪怕只有一个字节），也有可能触发一次I/O事件回调。这时我们是调用<code>read</code>系统API来读入数据的。虽然调用<code>read</code>时我们可以指定期望读取的字节数，但它并不会保证一定能返回期望长度的数据。比如我们想读100个字节，但可能只能读到80个字节，剩下的20个字节可能还在网络传输中没有到达。这种情况给接收Redis命令的过程造成了很大的麻烦：首先，可能我们读到的数据还不够一个完整的命令，这时我们应该继续等待更多的数据到达。其次，我们可能一次性收到了大量的数据，里面包含不止一个命令，这时我们必须把里面包含的所有命令都解析出来，而且要正确解析到最后一个完整命令的边界。如果最后一个完整命令后面还有多余的数据，那么这些数据应该留在下次有更多数据到达时再处理。这个复杂的过程一般称为「粘包」。</p></li><li><p>「粘包」处理的第一个表现，就是当尝试解析出一个完整的命令时，如果解析失败了，那么上面的流程就直接退出了。接下来，如果有更多数据到达，事件循环会再次触发I/O事件回调，重新进入上面的流程继续处理。</p></li><li><p>「粘包」处理的第二个表现，是上面流程图中的大循环。只要暂存输入数据的<code>query buffer</code>中还有数据可以处理，那么就不停地去尝试解析完整命令，直到把里面所有的完整命令都处理完，才退出循环。</p></li><li><p>查命令表那一步，就是查找本文前面提到的由<code>populateCommandTable</code>初始化的命令表，这个命令表存储在server.c的全局变量<code>redisCommandTable</code>当中。命令表中存有各个Redis命令的执行入口。</p></li><li><p>对于命令的执行结果，在上面的流程图中只是最后存到了一个输出buffer中，并没有真正输出给客户端。输出给客户端的过程不在这个流程当中，而是由另外一个同样是由事件循环驱动的过程来完成。这个过程涉及很多细节，我们在这里先略过，留在后面第四部分再来讨论。</p></li></ul><h2 id="事件机制介绍"><a href="#事件机制介绍" class="headerlink" title="事件机制介绍"></a>事件机制介绍</h2><p>在本文第一部分，我们提到过，我们必须有一种机制能够同时等待I/O和timer这两种事件的发生。这一机制就是系统底层的I/O多路复用机制(I/O multiplexing)。但是，在不同的系统上，存在多种不同的I/O多路复用机制。因此，为了方便上层程序实现，Redis实现了一个简单的事件驱动程序库，即ae.c的代码，它屏蔽了系统底层在事件处理上的差异，并实现了我们前面一直在讨论的事件循环。</p><p>在Redis的事件库的实现中，目前它低层支持4种I/O多路复用机制：</p><ul><li><p><code>select</code>系统调用，这应该是最早出现的一种I/O多路复用机制了，于1983年在4.2BSD Unix中被首次使用。它是POSIX规范的一部分。另外，跟select类似的还有一个poll系统调用，它是1986年在SVR3 Unix系统中首次使用的，也遵循POSIX规范。只要是遵循POSIX规范的操作系统，它就能支持select和poll机制，因此在目前我们常见的系统中这两种I/O事件机制一般都是支持的。</p></li><li><p><code>epoll机制</code>。epoll是比select更新的一种I/O多路复用机制，最早出现在Linux内核的2.5.44版本中。它被设计出来是为了代替旧的select和poll，提供一种更高效的I/O机制。注意，epoll是Linux系统所特有的，它不属于POSIX规范。</p></li><li><p><code>kqueue机制</code>。kqueue最早是2000年在FreeBSD 4.1上被设计出来的，后来也支持NetBSD、OpenBSD、DragonflyBSD和macOS系统。它和Linux系统上的epoll是类似的。</p></li><li><p><code>event ports</code>。这是在illumos系统上特有的一种I/O事件机制。</p></li></ul><p>既然在不同系统上有不同的事件机制，那么Redis在不同系统上编译时采用的是哪个机制呢？由于在上面四种机制中，后三种是更现代，也是比<code>select</code>和<code>poll</code>更高效的方案，因此Redis优先选择使用后三种机制。</p><p>通过上面对各种I/O机制所适用的操作系统的总结，我们很容易看出，如果你在macOS上编译Redis，那么它底层会选用<code>kqueue</code>；而如果在Linux上编译则会选择<code>epoll</code>，这也是Redis在实际运行中比较常见的情况。</p><p>现在我们回过头来再看一下底层的这些I/O事件机制是如何支持了Redis的事件循环的（下面的描述是对本文前面第一部分中事件循环流程的细化）：</p><ul><li>首先，向事件循环中注册I/O事件回调的时候，需要指定哪个回调函数注册到哪个事件上（事件用文件描述符来表示）。事件和回调函数的对应关系，由Redis上层封装的事件驱动程序库来维护。具体参见函数<code>aeCreateFileEvent</code>的代码。</li><li>类似地，向事件循环中注册timer事件回调的时候，需要指定多长时间之后执行哪个回调函数。这里需要记录哪个回调函数预期在哪个时刻被调用，这也是由Redis上层封装的事件驱动程序库来维护的。具体参见函数<code>aeCreateTimeEvent</code>的代码。</li><li>底层的各种事件机制都会提供一个等待事件的操作，比如epoll提供的epoll_wait API。这个等待操作一般可以指定预期等待的事件列表（事件用文件描述符来表示），并同时可以指定一个超时时间（即最大等待多长时间）。在事件循环中需要等待事件发生的时候，就调用这个等待操作，传入之前注册过的所有I/O事件，并把最近的timer事件所对应的时刻转换成这里需要的超时时间。具体参见函数<code>aeProcessEvents</code>的代码。</li><li>从上一步的等待操作中唤醒，有两种情况：如果是I/O事件发生了，那么就根据触发的事件查到I/O回调函数，进行调用；如果是超时了，那么检查所有注册过的timer事件，对于预期调用时刻超过当前时间的回调函数都进行调用。</li></ul><p>最后，关于事件机制，还有一些信息值得关注：业界已经有一些比较成熟的开源的事件库了，典型的比如libevent和libev。一般来说，这些开源库屏蔽了非常复杂的底层系统细节，并对不同的系统版本实现做了兼容，是非常有价值的。那为什么Redis的作者还是自己实现了一套呢？在Google Group的一个帖子上，Redis的作者给出了一些原因。帖子地址如下：</p><ul><li><a href="https://groups.google.com/group/redis-db/browse_thread/thread/b52814e9ef15b8d0/" target="_blank" rel="noopener">https://groups.google.com/group/redis-db/browse_thread/thread/b52814e9ef15b8d0/</a></li></ul><p>原因大致总结起来就是：</p><ul><li>不想引入太大的外部依赖。比如libevent太大了，比Redis的代码库还大。</li><li>方便做一些定制化的开发。</li><li>第三方库有时候会出现一些意想不到的bug。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载至 &lt;a href=&quot;http://zhangtielei.com/posts/blog-redis-how-to-start.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://zhangtielei.com/posts/blog-
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://meichaofan.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御</title>
    <link href="https://meichaofan.github.io/2019/04/02/CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>https://meichaofan.github.io/2019/04/02/CSRF攻击与防御/</id>
    <published>2019-04-01T16:15:59.000Z</published>
    <updated>2019-04-01T17:04:37.076Z</updated>
    
    <content type="html"><![CDATA[<p>转载至 <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p><hr><h2 id="一、CSRF是什么？"><a href="#一、CSRF是什么？" class="headerlink" title="一、CSRF是什么？"></a>一、CSRF是什么？</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h2 id="二、CSRF可以做什么？"><a href="#二、CSRF可以做什么？" class="headerlink" title="二、CSRF可以做什么？"></a>二、CSRF可以做什么？</h2><p>你这可以这么理解CSRF攻击：<strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong>。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h2 id="三、CSRF漏洞现状"><a href="#三、CSRF漏洞现状" class="headerlink" title="三、CSRF漏洞现状"></a>三、CSRF漏洞现状</h2><p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p><h2 id="四、CSRF的原理"><a href="#四、CSRF的原理" class="headerlink" title="四、CSRF的原理"></a>四、CSRF的原理</h2><p>下图简单阐述了CSRF攻击的思想：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/web%E5%AE%89%E5%85%A8/2009040916453171.jpg?raw=true" width="50%" height="50%"></div><br><div align="center">图1：CSRF攻击原理</div><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1.<strong>登录受信任网站A，并在本地生成Cookie。</strong></p><p>　　2.<strong>在不登出A的情况下，访问危险网站B。</strong></p><p>　　看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><p>　　1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p><p>　　2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</p><p>　　3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p><p>　　上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></p><p>危险网站B，它里面有一段HTML的代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure></p><p>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</p><p>为什么会这样呢？<strong>原因是银行网站A违反了HTTP规范，使用GET请求更新资源</strong>。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源”<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&quot;，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作....." target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&quot;，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作.....</a>.</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p><p>银行网站A的WEB表单如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"Transfer.php"</span> method=<span class="string">"POST"</span>&gt;</span><br><span class="line">　　&lt;p&gt;ToBankId: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"toBankId"</span> /&gt;&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;Money: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"money"</span> /&gt;&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"Transfer"</span> /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面Transfer.php如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (isset(<span class="variable">$_REQUEST</span>[<span class="string">'toBankId'</span>] &amp;&amp;　isset(<span class="variable">$_REQUEST</span>[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_REQUEST</span>[<span class="string">'toBankId'</span>],　<span class="variable">$_REQUEST</span>[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>危险网站B，仍然只是包含那句HTML代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><p>　经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (isset(<span class="variable">$_POST</span>[<span class="string">'toBankId'</span>] &amp;&amp;　isset(<span class="variable">$_POST</span>[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_POST</span>[<span class="string">'toBankId'</span>],　<span class="variable">$_POST</span>[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>然而，危险网站B与时俱进，它改了一下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">　　　　　　<span class="keyword">function</span> steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[<span class="string">"steal"</span>];</span><br><span class="line">　　     　　      iframe.document.Submit(<span class="string">"transfer"</span>);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=<span class="string">"steal()"</span>&gt;</span><br><span class="line">　　　　&lt;iframe name=<span class="string">"steal"</span> display=<span class="string">"none"</span>&gt;</span><br><span class="line">　　　　　　&lt;form method=<span class="string">"POST"</span> name=<span class="string">"transfer"</span>　action=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span><br><span class="line">　　　　　　　　&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"toBankId"</span> value=<span class="string">"11"</span>&gt;</span><br><span class="line">　　　　　　　　&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"money"</span> value=<span class="string">"1000"</span>&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!</p><p>总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个<img>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p><p>理解上面的3种攻击模式，其实可以看出，<strong>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</strong></p><h2 id="五-CSRF的防御"><a href="#五-CSRF的防御" class="headerlink" title="五.CSRF的防御"></a>五.CSRF的防御</h2><p>我总结了一下看到的资料，CSRF的防御可以从<strong>服务端</strong>和<strong>客户端</strong>两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p><h3 id="1-服务器端进行CSRF防御"><a href="#1-服务器端进行CSRF防御" class="headerlink" title="1.服务器端进行CSRF防御"></a>1.服务器端进行CSRF防御</h3><p>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><h4 id="1-Cookie-Hashing-所有表单都包含同一个伪随机值-："><a href="#1-Cookie-Hashing-所有表单都包含同一个伪随机值-：" class="headerlink" title="1).Cookie Hashing(所有表单都包含同一个伪随机值)："></a>1).Cookie Hashing(所有表单都包含同一个伪随机值)：</h4><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　//构造加密的Cookie信息</span><br><span class="line">　　　　<span class="variable">$value</span> = “DefenseSCRF”;</span><br><span class="line">　　　　setcookie(”cookie”, <span class="variable">$value</span>, time()+3600);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　<span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">'cookie'</span>]);</span><br><span class="line">?&gt;</span><br><span class="line">　　&lt;form method=”POST” action=”transfer.php”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”text” name=”toBankId”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”text” name=”money”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”hidden” name=”<span class="built_in">hash</span>” value=”&lt;?=<span class="variable">$hash</span>;?&gt;”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”submit” name=”submit” value=”Submit”&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后再服务器端进行Hash值验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isset(<span class="variable">$_POST</span>[<span class="string">'check'</span>])) &#123;</span><br><span class="line">        <span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">'cookie'</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">'check'</span>] == <span class="variable">$hash</span>) &#123;</span><br><span class="line">        　　 doJob();</span><br><span class="line">　　     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　 　　//...</span><br><span class="line">         </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　       &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。</p><h4 id="2-验证码"><a href="#2-验证码" class="headerlink" title="2).验证码"></a>2).验证码</h4><p>这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p><h4 id="3-One-Time-Tokens-不同的表单包含一个不同的伪随机值"><a href="#3-One-Time-Tokens-不同的表单包含一个不同的伪随机值" class="headerlink" title="3).One-Time Tokens(不同的表单包含一个不同的伪随机值)"></a>3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</h4><p>在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p><h4 id="4-slim框架CSRF实现"><a href="#4-slim框架CSRF实现" class="headerlink" title="4)slim框架CSRF实现"></a>4)slim框架CSRF实现</h4><p><a href="https://github.com/slimphp/Slim-Csrf" target="_blank" rel="noopener">slim框架的csrf预防源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载至 &lt;a href=&quot;http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/hyddd/ar
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://meichaofan.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="CSRF" scheme="https://meichaofan.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>源码文件</title>
    <link href="https://meichaofan.github.io/2019/03/29/%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    <id>https://meichaofan.github.io/2019/03/29/源码文件/</id>
    <published>2019-03-29T07:23:08.000Z</published>
    <updated>2019-04-09T10:26:33.711Z</updated>
    
    <content type="html"><![CDATA[<p>go文件主要分为下面3类:</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/go/9d08647d238e21e7184d60c0afe5afcb.png?raw=true" width="50%" height="50%" alt="内容"></div><br><div align="center">图1：go文件</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go文件主要分为下面3类:&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://github.com/meichaofan/static-file/blob/master/go/9d08647d238e21e7184d60c0afe5afcb
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>工作区和GOPATH</title>
    <link href="https://meichaofan.github.io/2019/03/29/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH/"/>
    <id>https://meichaofan.github.io/2019/03/29/工作区和GOPATH/</id>
    <published>2019-03-29T05:56:32.000Z</published>
    <updated>2019-03-29T07:18:28.665Z</updated>
    
    <content type="html"><![CDATA[<p>我们学习Go语言时，第一件要做的是，就是根据自己电脑的操作系统和计算架构，从<a href="https://golang.google.cn" target="_blank" rel="noopener">Go语言官网</a>下载对应的二进制包，也就是拿来即用的安装包。</p><p>随后，<strong>解压安装包</strong>、<strong>放置到某个目录</strong>、<strong>配置环境变量</strong>，并在命令行输入 <code>go version</code> 来验证是否安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@www package]# ls go1.12.1.linux-amd64.tar.gz </span><br><span class="line">go1.12.1.linux-amd64.tar.gz</span><br><span class="line">[root@www package]# tar zxvf go1.12.1.linux-amd64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置GOROOT、GOPATH、GOBIN环境变量</span></span><br><span class="line">[root@www ~]# vim .bash_profile</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin:/usr/local/php/bin:/usr/local/go/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/root/peek-a-bow</span><br><span class="line">export GOBIN=/root/peek-a-bow/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建工作目录</span></span><br><span class="line">mkdir -p /root/peek-a-bow/&#123;src,bin,pkg&#125;</span><br></pre></td></tr></table></figure><p>在整个安装过程中，需要配置3个环境变量，简单介绍一下:</p><ul><li>GOROOT: Go语言的安装目录</li><li>GOPATH: 自定义的工作目录</li><li>GOBIN: Go语言生成的可执行文件的目录</li></ul><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区（workspace）。</p><p>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file）,以及安装(install)后的归档文件（archive file）和可执行文件（executable file）。</p><p>事实上，由于Go语言项目在其生命周期内的所有操作（编码依赖管理、构建、测试、安装等）基本上都是围绕着GOPATH和工作区进行的。它的背后有3个知识点需要注意:</p><ul><li>1.Go语言源码的组织是怎样的；</li><li>2.你是否了解源码安装后的结果；</li><li>3.你是否理解构建和安装Go程序的过程。</li></ul><h3 id="1-Go语言源码组织方式"><a href="#1-Go语言源码组织方式" class="headerlink" title="1.Go语言源码组织方式"></a>1.Go语言源码组织方式</h3><p>Go语言是以代码包为基本组织单位的。所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录和代码包为主线的。</p><h3 id="2-了解源码安装后的结果"><a href="#2-了解源码安装后的结果" class="headerlink" title="2.了解源码安装后的结果"></a>2.了解源码安装后的结果</h3><p>源码文件在安装过程中，如果产生了归档文件，就会放进该工作区的pkg子目录；如果产生了可执行文件，就会放进该工作区的bin子目录。</p><h3 id="3-理解构建和安装Go程序的过程"><a href="#3-理解构建和安装Go程序的过程" class="headerlink" title="3.理解构建和安装Go程序的过程"></a>3.理解构建和安装Go程序的过程</h3><p>构建使用 <code>go build</code>,安装使用命令 <code>go install</code>。构建和安装代码包的时候都会执行编译、打包等操作。并且，这些操作产生的任何文件都会先被保存到某个临时的目录中。</p><p>如果构建的是<strong>库源码</strong>文件,那么操作结果只会保存在临时目录中，安装<strong>库源码</strong>文件，那么它的结果会被搬运到它所在工作区的pkg目录下的某个子目录中。</p><p>如果构建的是<strong>命令源码</strong>文件，那么它的操作结果文件会被搬运到源码文件所在的目录中。如果安装的是<strong>命令源码</strong>文件，那么结果文件会被搬运到它所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们学习Go语言时，第一件要做的是，就是根据自己电脑的操作系统和计算架构，从&lt;a href=&quot;https://golang.google.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go语言官网&lt;/a&gt;下载对应的二进制包，也就是拿来即用的安装包。&lt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go string 实现原理剖析</title>
    <link href="https://meichaofan.github.io/2019/03/28/Go-string-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>https://meichaofan.github.io/2019/03/28/Go-string-实现原理剖析/</id>
    <published>2019-03-27T16:18:04.000Z</published>
    <updated>2019-03-27T16:18:04.145Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>倒排索引原理</title>
    <link href="https://meichaofan.github.io/2019/03/27/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>https://meichaofan.github.io/2019/03/27/倒排索引原理/</id>
    <published>2019-03-26T18:39:09.000Z</published>
    <updated>2019-03-26T18:40:07.690Z</updated>
    
    <content type="html"><![CDATA[<p>关于<a href="https://www.elastic.co/" target="_blank" rel="noopener">ElasticSearch</a>为什么搜索这么快，大家应该有所了解，主要是利用倒排索引数据结构，下面简单介绍一下倒排索引。</p><h2 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h2><p>任何事物都是相对的，有倒排索引(inverted index)，当然也会有正向索引(forward index)。</p><h3 id="正向索引结构"><a href="#正向索引结构" class="headerlink" title="正向索引结构"></a>正向索引结构</h3><p>在搜索引擎中，每个文件(document)对应一个文件id(document id)，文件内容可以看作是一些列关键词的集合(实际上，在搜索引擎库中，关键词也转化为关键词id)。例如“文档1”经过分词，提取了20个关键词，每个关键词都会记录它在文档中的出现次数和出现位置。</p><p>得到正向索引结构如下：</p><p>“文档1”的ID &gt; 关键词1：出现次数，出现位置列表；关键词2：出现次数，出现位置列表；……</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/forward_index.png" width="50%" height="50%"></div><br><div align="center">图1：正向索引结构</div><p><strong>通过文档，去找关键词</strong>。</p><h3 id="正向索引查找过程"><a href="#正向索引查找过程" class="headerlink" title="正向索引查找过程"></a>正向索引查找过程</h3><p>当用户在主页上搜索关键词“<strong>华为手机</strong>”时，假设只存在正向索引(forward index)，那么就需要<strong>扫描索引库中的所有文档</strong>，找出所有包含关键词“<strong>华为手机</strong>”的文档，再根据<strong>打分模型</strong>进行打分，排出名次后呈现给用户。因为互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="倒排索引结构"><a href="#倒排索引结构" class="headerlink" title="倒排索引结构"></a>倒排索引结构</h3><p>由于正向索引无法满足实时返回排名结果的要求，所以，搜索引擎会将正向索引重新构建为倒排索引，即把<strong>文件id对应到关键词的映射</strong>转化为<strong>关键词到文件id的映射</strong>，每个关键词对应着一些列文件，这些文件中都出现这个关键词。</p><p>得到倒排索引的结构如下：</p><p>“关键词1” ：“文档1”的id ， “文档2”的id ，……。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/reverted-index.png" width="50%" height="50%" alt="倒排索引"></div><br><div align="center">图2：倒排索引结构</div><p><strong>通过关键词，去找文档</strong>。</p><h3 id="单词-文档矩阵"><a href="#单词-文档矩阵" class="headerlink" title="单词-文档矩阵"></a>单词-文档矩阵</h3><p>单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%8D%95%E8%AF%8D%E6%96%87%E6%A1%A3%E7%9F%A9%E9%98%B5.png" width="50%" height="50%" alt="单词文档矩阵"></div><br><div align="center">图3：单词-文档矩阵</div><p>从纵向看（即从文档这个维度看），每列代表文档包含了哪些单词，比如文档1包含了词汇1和词汇4，而不包含其它单词。</p><p>从横向看（即从单词这个维度看），每行代表了哪些文档包含了这个单词。比如词汇1来说，文档1和文档4中出现过单词1，而其它文档不包含词汇1。</p><p>搜索引擎，其实就是实现了 “<strong>单词-文档矩阵</strong>”的具体<strong>数据结构</strong>，可以有不同的方式来实现上述概念模型，比如“<strong>倒排索引</strong>”、“<strong>签名文件</strong>”、“<strong>后缀树</strong>”等方式。目前ElasticSearch中是使用“倒排索引”实现单词到文档映射关系。</p><h3 id="倒排索引基本概念"><a href="#倒排索引基本概念" class="headerlink" title="倒排索引基本概念"></a>倒排索引基本概念</h3><p>文档(document):一般搜索引擎的处理对象是互联网网页，而文档这个概念要更宽泛些，代表以文本形式存在的存储对象，相比网页来说，涵盖更多种形式，比如Word，PDF，html，XML等不同格式的文件都可以称之为文档。再比如一封邮件，一条短信，一条微博也可以称之为文档。在本书后续内容，很多情况下会使用文档来表征文本信息。</p><p>文档集合(Document Collection)：由若干文档构成的集合称之为文档集合。比如海量的互联网网页或者说大量的电子邮件都是文档集合的具体例子。</p><p>文档编号(Document ID):在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。</p><p>单词编号(Word ID):与文档编号类似，搜索引擎内部以唯一的编号来表征某个单词，单词编号可以作为某个单词的唯一表征。</p><p>倒排索引(Inverted Index):倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p><p>单词字典(Lexicon)：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</p><p>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</p><p>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</p><p>关于这些概念之间的关系，通过图4可以比较清晰的看出来。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8%E6%A6%82%E5%BF%B5%E5%9B%BE.png" width="50%" height="50%" alt="倒排列表模型"></div><br><div align="center">图4：倒排列表模型</div><h3 id="倒排索引简单实例"><a href="#倒排索引简单实例" class="headerlink" title="倒排索引简单实例"></a>倒排索引简单实例</h3><p>倒排索引从逻辑结构和基本思路上来讲非常简单。下面我们通过具体实例来进行说明，使得读者能够对倒排索引有一个宏观而直接的感受。</p><p> 假设文档集合包含五个文档，每个文档内容如图3所示，在图中最左端一栏是每个文档对应的文档编号。我们的任务就是对这个文档集合建立倒排索引。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E6%96%87%E6%A1%A3%E9%9B%86%E5%90%88.png" width="50%" height="50%" alt="文档集合"></div><br> <div align="center">图5：文档集合</div><p> 中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引（参考图6）。在图6中，“单词ID”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" width="50%" height="50%" alt="最简单的倒排索引"></div><br> <div align="center">图6：最简单的倒排索引</div><p> 之所以说图6所示倒排索引是最简单的，是因为这个索引系统只记载了哪些文档包含某个单词，而事实上，索引系统还可以记录除此之外的更多信息。图7是一个相对复杂些的倒排索引，与图6的基本索引系统比，在单词对应的倒排列表中不仅记录了文档编号，还记载了单词频率信息（TF），即这个单词在某个文档中的出现次数，之所以要记录这个信息，是因为词频信息在搜索结果排序时，计算查询和文档相似度是很重要的一个计算因子，所以将其记录在倒排列表中，以方便后续排序时进行分值计算。在图7的例子里，单词“创始人”的单词编号为7，对应的倒排列表内容为：（3:1），其中的3代表文档编号为3的文档包含这个单词，数字1代表词频信息，即这个单词在3号文档中只出现过1次，其它单词对应的倒排列表所代表含义与此相同。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%B8%A6%E6%9C%89%E8%AF%8D%E9%A2%91%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" width="50%" height="50%" alt="带有单词频率信息的倒排索引"></div><br> <div align="center">图7：带有单词频率信息的倒排索引</div><p> 实用的倒排索引还可以记载更多的信息，图8所示索引系统除了记录文档编号和单词频率信息外，额外记载了两类信息，即每个单词对应的“文档频率信息”（对应图8的第三栏）以及在倒排列表中记录单词在某个文档出现的位置信息。</p><p> “文档频率信息”代表了在文档集合中有多少个文档包含某个单词，之所以要记录这个信息，其原因与单词频率信息一样，这个信息在搜索结果排序计算中是非常重要的一个因子。而单词在某个文档中出现的位置信息并非索引系统一定要记录的，在实际的索引系统里可以包含，也可以选择不包含这个信息，之所以如此，因为这个信息对于搜索系统来说并非必需的，位置信息只有在支持“短语查询”的时候才能够派上用场。</p><p> 以单词“拉斯”为例，其单词编号为8，文档频率为2，代表整个文档集合中有两个文档包含这个单词，对应的倒排列表为：{(3;1;<4>)，(5;1;<4>)},其含义为在文档3和文档5出现过这个单词，单词频率都为1，单词“拉斯”在两个文档中的出现位置都是4，即文档中第四个单词是“拉斯”。</4></4></p><p> 图7所示倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此，区别无非是采取哪些具体的数据结构来实现上述逻辑结构。</p><p> 有了这个索引系统，搜索引擎可以很方便地响应用户的查询，比如用户输入查询词“Facebook”，搜索系统查找倒排索引，从中可以读出包含这个单词的文档，这些文档就是提供给用户的搜索结果，而利用单词频率信息、文档频率信息即可以对这些候选搜索结果进行排序，计算文档和查询的相似性，按照相似性得分由高到低排序输出，此即为搜索系统的部分内部流程。</p><h2 id="单词词典"><a href="#单词词典" class="headerlink" title="单词词典"></a>单词词典</h2><p>单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。</p><p>对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词，这直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找，常用的数据结构包括<strong>哈希加链表结构</strong>和<strong>树形词典结构</strong>。</p><h3 id="哈希加链表"><a href="#哈希加链表" class="headerlink" title="哈希加链表"></a>哈希加链表</h3><p>图8是这种词典结构的示意图。这种词典结构主要由两个部分构成：</p><p>主体部分是哈希表，每个哈希表项保存一个指针，指针指向冲突链表，在冲突链表里，相同哈希值的单词形成链表结构。之所以会有冲突链表，是因为两个不同单词获得相同的哈希值，如果是这样，在哈希方法里被称做是一次冲突，可以将相同哈希值的单词存储在链表里，以供后续查找。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%93%88%E5%B8%8C%E5%8A%A0%E9%93%BE%E8%A1%A8.png" width="50%" height="50%" alt="哈希加链表"></div><br><div align="center">图8：哈希加链表结构</div><p>在建立索引的过程中，词典结构也会相应地被构建出来。比如在解析一个新文档的时候，对于某个在文档中出现的单词T，首先利用哈希函数获得其哈希值，之后根据哈希值对应的哈希表项读取其中保存的指针，就找到了对应的冲突链表。如果冲突链表里已经存在这个单词，说明单词在之前解析的文档里已经出现过。如果在冲突链表里没有发现这个单词，说明该单词是首次碰到，则将其加入冲突链表里。通过这种方式，当文档集合内所有文档解析完毕时，相应的词典结构也就建立起来了。</p><p>在响应用户查询请求时，其过程与建立词典类似，不同点在于即使词典里没出现过某个单词，也不会添加到词典内。以图8为例，假设用户输入的查询请求为单词3，对这个单词进行哈希，定位到哈希表内的2号槽，从其保留的指针可以获得冲突链表，依次将单词3和冲突链表内的单词比较，发现单词3在冲突链表内，于是找到这个单词，之后可以读出这个单词对应的倒排列表来进行后续的工作，如果没有找到这个单词，说明文档集合内没有任何文档包含单词，则搜索结果为空。</p><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p> B树（或者B+树）是另外一种高效查找结构。B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式则无须数据满足此项要求。</p><p> B树形成了层级查找结构，中间节点用于指出一定顺序范围的词典项目存储在哪个子树中，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/content.png" width="50%" height="50%" alt="内容"></div><br><div align="center">图9：文档集合</div><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/content2.png" width="50%" height="50%" alt="倒排索引结构"></div><br><div align="center">图10：倒排索引结构</div><ul><li>单词ID：记录每个单词的单词编号；</li><li>单词：对应的单词；</li><li>文档频率：代表文档集合中有多少个文档包含某个单词</li><li>倒排列表：包含单词ID及其他必要信息</li><li>DocId：单词出现的文档id</li><li>TF：单词在某个文档中出现的次数</li><li>POS：单词在文档中出现的位置</li></ul><p>以单词“加盟”为例，其单词编号为6，文档频率为3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为{(2;1;<4>),(3;1;<7>),(5;1;<5>)}，含义是在文档2，3，5出现过这个单词，在每个文档的出现过1次，单词“加盟”在第一个文档的POS是4，即文档的第四个单词是“加盟”，其他的类似。</5></7></4></p><p>这个倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于&lt;a href=&quot;https://www.elastic.co/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ElasticSearch&lt;/a&gt;为什么搜索这么快，大家应该有所了解，主要是利用倒排索引数据结构，下面简单介绍一下倒排索引。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="倒排索引" scheme="https://meichaofan.github.io/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>
