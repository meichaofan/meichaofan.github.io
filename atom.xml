<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>huany</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meichaofan.github.io/"/>
  <updated>2019-05-29T09:35:10.894Z</updated>
  <id>https://meichaofan.github.io/</id>
  
  <author>
    <name>meichaofan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-1-two-sum</title>
    <link href="https://meichaofan.github.io/2019/05/29/leetcode-1-two-sum/"/>
    <id>https://meichaofan.github.io/2019/05/29/leetcode-1-two-sum/</id>
    <published>2019-05-29T08:28:57.000Z</published>
    <updated>2019-05-29T09:35:10.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="PHP版本"><a href="#PHP版本" class="headerlink" title="PHP版本"></a>PHP版本</h3><h3 id="JAVA版本"><a href="#JAVA版本" class="headerlink" title="JAVA版本"></a>JAVA版本</h3><h3 id="Go版本"><a href="#Go版本" class="headerlink" title="Go版本"></a>Go版本</h3><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://meichaofan.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://meichaofan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>好好过生活，知足最快乐</title>
    <link href="https://meichaofan.github.io/2019/05/28/have-a-good-life/"/>
    <id>https://meichaofan.github.io/2019/05/28/have-a-good-life/</id>
    <published>2019-05-28T09:09:41.000Z</published>
    <updated>2019-05-28T09:21:44.136Z</updated>
    
    <content type="html"><![CDATA[<p><em>还记得 你说家是唯一的城堡</em></p><p><em>随着稻香河流继续奔跑</em></p><p><em>微微笑 小时候的梦我知道</em></p><p><em>不要哭 让萤火虫带着你逃跑</em></p><p><em>乡间的歌谣 永远的依靠</em></p><p><em>回家吧 回到最初的美好</em></p><hr><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ul><li><a href="/2019/05/28/graduation-finally/">毕业在即，云胡不喜</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;还记得 你说家是唯一的城堡&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;随着稻香河流继续奔跑&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;微微笑 小时候的梦我知道&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不要哭 让萤火虫带着你逃跑&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;乡间的歌谣 永远的依靠&lt;/em&gt;&lt;
      
    
    </summary>
    
    
      <category term="life" scheme="https://meichaofan.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>毕业在即，云乎不喜</title>
    <link href="https://meichaofan.github.io/2019/05/28/graduation-finally/"/>
    <id>https://meichaofan.github.io/2019/05/28/graduation-finally/</id>
    <published>2019-05-28T08:51:23.000Z</published>
    <updated>2019-05-28T13:32:25.535Z</updated>
    
    <content type="html"><![CDATA[<p>终于要换一种身份开启人生新一段旅程。</p><p> <img src="https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/d909af140ea14cb3f8ce3385d22b0d6.jpg" alt="没有电的实验室"></p><p><img src="https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/380a3be32413d25df630dfe3b83b976.jpg" alt="第一次看见北京早上5点钟的天空"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于要换一种身份开启人生新一段旅程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/d909af140ea14cb3f8ce3385d22b0d6.jpg&quot; alt=&quot;没有电的实
      
    
    </summary>
    
    
      <category term="life" scheme="https://meichaofan.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Linux如何给应用程序创建一个桌面启动图标</title>
    <link href="https://meichaofan.github.io/2019/04/29/linux-create-a-desktop-app/"/>
    <id>https://meichaofan.github.io/2019/04/29/linux-create-a-desktop-app/</id>
    <published>2019-04-29T02:04:29.000Z</published>
    <updated>2019-04-29T02:07:22.952Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述的是linux中如何给应用程序创建一个快速启动图标，话不多说，我们来看实际的操作步骤：</p><p>本文的实例是给celipse创建一个启动图标</p><hr><ol><li><p>我们需要通过下列命令，来创建一个启动的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/applications/eclipse.desktop</span><br></pre></td></tr></table></figure></li><li><p>将下列内容复制到启动脚本中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=Eclipse</span><br><span class="line">Comment=Eclipse IDE</span><br><span class="line">Exec=/usr/local/android/eclipse/eclipse      </span><br><span class="line">Icon=/usr/local/android/eclipse/icon.xpm</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>说明部分：<br>Exec ：这个是应用程序可执行文件的目录<br>Icon ：这个是图标的目录</p></blockquote><ol start="3"><li>然后在applications -&gt; programming 菜单中就可以找到你所创建的图标了，然后再右键创建一个桌面图标即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲述的是linux中如何给应用程序创建一个快速启动图标，话不多说，我们来看实际的操作步骤：&lt;/p&gt;
&lt;p&gt;本文的实例是给celipse创建一个启动图标&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们需要通过下列命令，来创建一个启动的脚本：&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://meichaofan.github.io/tags/Linux/"/>
    
      <category term="Desktop" scheme="https://meichaofan.github.io/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 系统修改默认运行级别</title>
    <link href="https://meichaofan.github.io/2019/04/29/ubuntu-change-runlevel/"/>
    <id>https://meichaofan.github.io/2019/04/29/ubuntu-change-runlevel/</id>
    <published>2019-04-28T17:40:12.000Z</published>
    <updated>2019-04-28T17:48:54.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Deb系运行级别（Debian、Ubuntu）"><a href="#Deb系运行级别（Debian、Ubuntu）" class="headerlink" title="Deb系运行级别（Debian、Ubuntu）"></a>Deb系运行级别（Debian、Ubuntu）</h2><blockquote><p>0 – Halt，关机模式<br>1 – Single，单用户模式<br>2 - Full multi-user with display manager (GUI)<br>3 - Full multi-user with display manager (GUI)<br>4 - Full multi-user with display manager (GUI)<br>5 - Full multi-user with display manager (GUI)<br>6 – Reboot，重启<br>S - 单用户恢复模式</p></blockquote><p>2~5级是没有任何区别的，他们为多用户模式。</p><h2 id="Rpm系运行级别（Redhat、CentOS）"><a href="#Rpm系运行级别（Redhat、CentOS）" class="headerlink" title="Rpm系运行级别（Redhat、CentOS）"></a>Rpm系运行级别（Redhat、CentOS）</h2><blockquote><p>0 – Halt，关机模式<br>1 – Single，单用户模式<br>2 – 多用户模式，但不能使用NFS（相当于Windows下的网上邻居）<br>3 – 字符界面的多用户模式<br>4 – Undefined<br>5 – Full multi-user with display manager (GUI)<br>6 – Reboot，重启</p></blockquote><h2 id="查看当前运行级别"><a href="#查看当前运行级别" class="headerlink" title="查看当前运行级别"></a>查看当前运行级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu:~$ runlevel </span><br><span class="line">N 2</span><br></pre></td></tr></table></figure><h2 id="ubuntu系统下修改运行级别"><a href="#ubuntu系统下修改运行级别" class="headerlink" title="ubuntu系统下修改运行级别"></a>ubuntu系统下修改运行级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/default/grup</span><br><span class="line">将</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;</span><br><span class="line">改为</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;</span><br><span class="line">然后执行</span><br><span class="line">update-grub2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Deb系运行级别（Debian、Ubuntu）&quot;&gt;&lt;a href=&quot;#Deb系运行级别（Debian、Ubuntu）&quot; class=&quot;headerlink&quot; title=&quot;Deb系运行级别（Debian、Ubuntu）&quot;&gt;&lt;/a&gt;Deb系运行级别（Debian、U
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://meichaofan.github.io/tags/ubuntu/"/>
    
      <category term="runlevel" scheme="https://meichaofan.github.io/tags/runlevel/"/>
    
  </entry>
  
  <entry>
    <title>linux的进程调度</title>
    <link href="https://meichaofan.github.io/2019/04/28/linux-process-sche/"/>
    <id>https://meichaofan.github.io/2019/04/28/linux-process-sche/</id>
    <published>2019-04-28T09:53:20.000Z</published>
    <updated>2019-04-28T09:58:37.066Z</updated>
    
    <content type="html"><![CDATA[<p>转载至 <a href="https://blog.csdn.net/gatieme/article/details/51701149" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51701149</a></p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><hr><h3 id="1-1-进程调度"><a href="#1-1-进程调度" class="headerlink" title="1.1 进程调度"></a>1.1 进程调度</h3><p>内存中保存了对每个进程的唯一描述，并通过若干结构与其它进程连接起来。</p><p><strong>调度器</strong>面对的情形就是这样，其任务是在程序之间共享CPU时间，创造并行执行的错觉，该任务分为两个不同的部分，其中一个涉及<strong>调度策略</strong>，另外一个涉及<strong>上下文切换</strong>。</p><hr><h3 id="1-2-进程的分类"><a href="#1-2-进程的分类" class="headerlink" title="1.2 进程的分类"></a>1.2 进程的分类</h3><hr><p>Linux把进程区分为<strong>实时进程</strong>和<strong>非实时进程</strong>，其中非实时进程进一步划分为<strong>交互式进程</strong>和<strong>批处理进程</strong>。</p><table><thead><tr><th>类型</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td>实时进程（real-time process）</td><td style="text-align:center">这些进程需要很强的调度需要，这样的进程不会被低优先级进程阻塞，并且他们的响应时间要尽可能的短</td><td style="text-align:center">视频音频应用程程序，机器人控制程序以及物理传感器收集数据的程序</td></tr><tr><td>交互式进程（interactive process）</td><td style="text-align:center">此类进程经常与用户进行交互，因此需要花很多时间等待键盘和鼠标操作，当接受了用户输入后，进程必须很快被唤醒，否则用户感觉系统反应迟钝</td><td style="text-align:center">shell,文本编辑程序和图形应用程序</td></tr><tr><td>批处理进程（batch process）</td><td style="text-align:center">此类进程不必与用户交互，因此经常在后台运行，因为这样的进程不必很快响应，因此常受到调度程序的怠慢</td><td style="text-align:center">程序语言的编译程序，数据库搜索引擎以及科学计算</td></tr></tbody></table><p>在Linux中，调度算法可以明确的确认所有实时进程的身份，但是没办法区分交互式程序和批处理程序，在Linux2.6的调度程序实现了基于进程过去式行为的启发式算法，以确定进程应该被当做交互式进程还是批处理进程，当然与批处理进程相比，调度程序有偏爱交互式进程的倾向。</p><h3 id="1-3-不同进程采用不同的调度策略"><a href="#1-3-不同进程采用不同的调度策略" class="headerlink" title="1.3 不同进程采用不同的调度策略"></a>1.3 不同进程采用不同的调度策略</h3><hr><p>根据进程的不同分类Linux采用不同的调度策略。</p><p><strong>对于实时进程，采用FIFO或者Round Robin的调度策略</strong>。</p><p>对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器核心思想是<strong>“完全公平”</strong>。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。</p><p>注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和/或数据）的多个线程。因此进程调度也包含了线程调度的功能。</p><p>目前实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.</p><p>但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢，因此在linux调度器的发展历程中经过了多次重大变动, linux总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程.</p><h3 id="1-4-Linux调度器的演变"><a href="#1-4-Linux调度器的演变" class="headerlink" title="1.4 Linux调度器的演变"></a>1.4 Linux调度器的演变</h3><hr><p>一开始的调度器是复杂度为<em>O(n)</em>的调度算法（实际上每次遍历所有任务，所以复杂度为<em>O(n)</em>），这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从Linux2.5开始引入了赫赫有名<em>O(1)</em>的调度器。</p><p>然而，linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在<strong>O(1)</strong>调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是<strong>CFS调度器Completely Fair Scheduler</strong>. 这个也是在2.6内核中引入的，具体为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，<strong>O(1)</strong>调度器被抛弃了。</p><p>所以完全有理由相信，后续如果再会出现一个更优秀的调度器，CFS也不会幸免。因为linux只要最好的那个。</p><h2 id="2-O-n-的始调度算法"><a href="#2-O-n-的始调度算法" class="headerlink" title="2. O(n)的始调度算法"></a>2. <em>O(n)</em>的始调度算法</h2><hr><h3 id="2-1-Linux2-4之前的内核调度器"><a href="#2-1-Linux2-4之前的内核调度器" class="headerlink" title="2.1 Linux2.4之前的内核调度器"></a>2.1 Linux2.4之前的内核调度器</h3><hr><p>早期的Linux进程调度器使用了最低的设计，它显然不关注具有很多处理器的大型架构，更不用说是超线程了。</p><p>Linux调度器使用了<strong>环形队列</strong>用于可运行的任务管理, 使用循环调度策略.</p><p>此调度器添加和删除进程效率很高（具有保护结构的锁）。简而言之，该调度器并不复杂但是简单快捷.</p><p>Linux版本2.2引入了调度类的概念，允许针对实时任务、非抢占式任务、非实时任务的调度策略。调度器还包括对称多处理 (SMP) 支持。</p><h3 id="2-2-Linux2-4的调度器"><a href="#2-2-Linux2-4的调度器" class="headerlink" title="2.2 Linux2.4的调度器"></a>2.2 Linux2.4的调度器</h3><hr><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><hr><p>在Linux2.4.18中(linux-2.5)之前的内核, 当很多任务都处于活动状态时, 调度器有很明显的限制. 这是由于调度器是使用一个复杂度为<em>O(n)</em>的算法实现的.</p><p>调度器采用基于优先级的设计，这个调度器和Linus在1992年发布的调度器没有大的区别。该调度器的<code>pick next</code>算法非常简单：对runqueue中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程。(Runqueue是Linux 内核中保存所有就绪进程的队列)。 <code>pick next</code>用来指从所有候选进程中挑选下一个要被调度的进程的过程。</p><p>这种调度算法非常简单易懂: <strong>在每次进程切换时, 内核扫描可运行进程的链表, 计算优先级,然后选择“最佳”进程来运行。</strong></p><p>在这种调度器中, 调度任务所花费的时间是一个系统中任务个数的函数. 换而言之, 活动的任务越多, 调度任务所花费的时间越长. 在任务负载非常重时, 处理器会因调度消耗掉大量的时间, 用于任务本身的时间就非常少了。因此，这个算法缺乏可伸缩性</p><h4 id="2-2-2-详情"><a href="#2-2-2-详情" class="headerlink" title="2.2.2 详情"></a>2.2.2 详情</h4><hr><p>每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有RUNNING进程的时间片都被用完之后，才对所有进程重新分配时间片。这段时间被称为一个epoch。这种设计保证了每个进程都有机会得到执行。每个epoch中，每个进程允许执行到其时间切片用完。如果某个进程没有使用其所有的时间切片，那么剩余时间切片的一半将被添加到新时间切片使其在下个epoch中可以执行更长时间。调度器只是迭代进程，应用goodness函数（指标）决定下面执行哪个进程。当然，各种进程对调度的需求并不相同，Linux 2.4调度器主要依靠改变进程的优先级，来满足不同进程的调度需求。事实上，所有后来的调度器都主要依赖修改进程优先级来满足不同的调度需求。</p><p>实时进程：实时进程的优先级是静态设定的，而且始终大于普通进程的优先级。因此只有当runqueue中没有实时进程的情况下，普通进程才能够获得调度。</p><blockquote><p>实时进程采用两种调度策略，SCHED_FIFO 和 SCHED_RR。FIFO 采用先进先出的策略，对于所有相同优先级的进程，最先进入 runqueue 的进程总能优先获得调度；Round Robin采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流获得调度。</p></blockquote><p>普通进程：对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速的用户响应。普通进程的优先级主要由进程描述符中的<code>Counter</code>字段决定 (还要加上<code>nice</code>设定的静态优先级) 。进程被创建时子进程的counter值为父进程counter值的一半，这样保证了任何进程不能依靠不断地<code>fork()</code>子进程从而获得更多的执行机会。</p><p>Linux2.4调度器是如何提高交互式进程的优先级的呢？如前所述，当所有 RUNNING 进程的时间片被用完之后，调度器将重新计算所有进程的 counter 值，所有进程不仅包括 RUNNING 进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的 counter 本来就没有用完，在重新计算时，他们的 counter 值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因等待用户输入而处于睡眠状态，当它们重新被唤醒并进入 runqueue 时，就会优先于其它进程而获得 CPU。从用户角度来看，交互式进程的响应速度就提高了。</p><p>该调度器的主要缺点：</p><ul><li><p>可扩展性不好<br>调度器选择进程时需要遍历整个 runqueue 从中选出最佳人选，因此该算法的执行时间与进程数成正比。另外每次重新计算 counter 所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新 counter 操作的代价会非常高，导致系统整体的性能下降。</p></li><li><p>高负载系统上的调度性能比较低<br>2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间于该时间片的大小成正比。</p></li><li><p>交互式进程的优化并不完善<br>Linux2.4识别交互式进程的原理基于以下假设，即交互式进程比批处理进程更频繁地处于SUSPENDED状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行IO操作，比如一个数据库引擎在处理查询时会经常地进行磁盘IO，虽然它们并不需要快速地用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。</p></li><li><p>对实时进程的支持不够<br>Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</p></li></ul><p>为了解决这些问题，Ingo Molnar开发了新的<em>O(1)</em>调度器，在CFS和RSDL之前，这个调度器不仅被Linux2.6采用，还被backport到Linux2.4中，很多商业的发行版本都采用了这个调度器</p><h2 id="3-O-1-的调度算法"><a href="#3-O-1-的调度算法" class="headerlink" title="3. O(1)的调度算法"></a>3. <em>O(1)</em>的调度算法</h2><hr><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><hr><p>由于进程优先级的最大值为139，因此MAX_PRIO的最大值取140(具体的是，普通进程使用100到139的优先级，实时进程使用0到99的优先级).</p><p>因此，该调度算法为每个优先级都设置一个可运行队列, 即包含140个可运行状态的进程链表，每一条优先级链表上的进程都具有相同的优先级，而不同进程链表上的进程都拥有不同的优先级。</p><p>除此之外, 还包括一个优先级位图bitmap。该位图使用一个位(bit)来代表一个优先级，而140个优先级最少需要5个32位来表示， 因此只需要一个int[5]就可以表示位图，该位图中的所有位都被置0，当某个优先级的进程处于可运行状态时，该优先级所对应的位就被置1。</p><p>如果确定了优先级，那么选取下一个进程就简单了，只需在queue数组中对应的链表上选取一个进程即可。</p><p>最后，在早期的内核中，抢占是不可能的；这意味着如果有一个低优先级的任务在执行，高优先级的任务只能等待它完成。</p><h3 id="3-2-详情"><a href="#3-2-详情" class="headerlink" title="3.2 详情"></a>3.2 详情</h3><hr><p>从名字就可以看出O(1)调度器主要解决了以前版本中的扩展性问题。</p><p>O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。</p><p>此外Linux 2.6内核支持内核态抢占，因此更好地支持了实时进程。</p><p>相对于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。</p><p>Linux 2.6内核也支持三种调度策略。其中SCHED_FIFO和SCHED_RR用于实时进程，而SCHED_NORMAL用于普通进程。</p><p>O(1)调度器在两个方面修改了Linux 2.4调度器，<strong>一是进程优先级的计算方法；二是pick next算法。</strong></p><p>O(1)调度器跟踪运行队列中可运行的任务（实际上，每个优先级水平有两个运行队列，一个用于活动任务，一个用于过期任务）， 这意味着要确定接下来执行的任务，调度器只需按优先级将下一个任务从特定活动的运行队列中取出即可。</p><h3 id="3-2-1-普通进程的优先级计算"><a href="#3-2-1-普通进程的优先级计算" class="headerlink" title="3.2.1 普通进程的优先级计算"></a>3.2.1 普通进程的优先级计算</h3><hr><p>不同类型的进程应该有不同的优先级。每个进程与生俱来（即从父进程那里继承而来）都有一个优先级，我们将其称为静态优先级。普通进程的静态优先级范围从100到139，100为最高优先级，139 为最低优先级，0－99保留给实时进程。当进程用完了时间片后，系统就会为该进程分配新的时间片（即基本时间片），静态优先级本质上决定了时间片分配的大小。</p><p>静态优先级和基本时间片的关系如下：</p><blockquote><p>静态优先级&lt;120，基本时间片=max((140-静态优先级)<em>20,MIN_TIMESLICE)<br>静态优先级&gt;=120，基本时间片=max((140-静态优先级)</em>5,MIN_TIMESLICE)</p></blockquote><p>其中MIN_TIMESLICE为系统规定的最小时间片。从该计算公式可以看出，静态优先级越高（值越低），进程得到的时间片越长。其结果是，优先级高的进程会获得更长的时间片，而优先级低的进程得到的时间片则较短。进程除了拥有静态优先级外，还有动态优先级，其取值范围是100到139。当调度程序选择新进程运行时就会使用进程的动态优先级，动态优先级和静态优先级的关系可参考下面的公式：</p><blockquote><p>动态优先级=max(100，min(静态优先级-bonus+5)，139)</p></blockquote><p>从上面看出，动态优先级的生成是以静态优先级为基础，再加上相应的惩罚或奖励(bonus)。这个bonus并不是随机的产生，而是根据进程过去的平均睡眠时间做相应的惩罚或奖励。</p><p>所谓平均睡眠时间（sleep_avg，位于task_struct结构中）就是进程在睡眠状态所消耗的总时间数，这里的平均并不是直接对时间求平均数。平均睡眠时间随着进程的睡眠而增长，随着进程的运行而减少。因此，平均睡眠时间记录了进程睡眠和执行的时间，它是用来判断进程交互性强弱的关键数据。如果一个进程的平均睡眠时间很大，那么它很可能是一个交互性很强的进程。反之，如果一个进程的平均睡眠时间很小，那么它很可能一直在执行。另外，平均睡眠时间也记录着进程当前的交互状态，有很快的反应速度。比如一个进程在某一小段时间交互性很强，那么sleep_avg就有可能暴涨（当然它不能超过 MAX_SLEEP_AVG），但如果之后都一直处于执行状态，那么sleep_avg就又可能一直递减。理解了平均睡眠时间，那么bonus的含义也就显而易见了。交互性强的进程会得到调度程序的奖励（bonus为正），而那些一直霸占CPU的进程会得到相应的惩罚（bonus为负）。其实bonus相当于平均睡眠时间的缩影，此时只是将sleep_avg调整成bonus数值范围内的大小。可见平均睡眠时间可以用来衡量进程是否是一个交互式进程。如果满足下面的公式，进程就被认为是一个交互式进程：</p><blockquote><p>动态优先级≤3*静态优先级/4 + 28</p></blockquote><p>平均睡眠时间是进程处于等待睡眠状态下的时间，该值在进程进入睡眠状态时增加，而进入RUNNING状态后则减少。该值的更新时机分布在很多内核函数内：时钟中断scheduler_tick()；进程创建；进程从TASK_INTERRUPTIBLE状态唤醒；负载平衡等。</p><h3 id="3-2-2-实时进程的优先级计算"><a href="#3-2-2-实时进程的优先级计算" class="headerlink" title="3.2.2 实时进程的优先级计算"></a>3.2.2 实时进程的优先级计算</h3><hr><p>实时进程的优先级由sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用rt_priority域表示。</p><h3 id="3-2-3-pick-next算法"><a href="#3-2-3-pick-next算法" class="headerlink" title="3.2.3 pick next算法"></a>3.2.3 pick next算法</h3><hr><p>普通进程的调度选择算法基于进程的优先级，拥有最高优先级的进程被调度器选中。</p><p>Linux2.4中，时间片counter同时也表示了一个进程的优先级。Linux2.6中时间片用任务描述符中的time_slice域表示，而优先级用prio（普通进程）或者rt_priority（实时进程）表示。调度器为每一个CPU维护了两个进程队列数组：指向活动运行队列的active数组和指向过期运行队列的expire数组。数组中的元素着保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。它们是按照先进先出的顺序进行服务的。被调度执行的任务都会被添加到各自运行队列优先级列表的末尾。每个任务都有一个时间片，这取决于系统允许执行这个任务多长时间。运行队列的前100个优先级列表保留给实时任务使用，后40个用于用户任务，参见下图：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/Linux-runqueue.png?raw=true" width="50%" height="50%"></div><p>当需要选择当前最高优先级的进程时，2.6调度器不用遍历整个runqueue，而是直接从active数组中选择当前最高优先级队列中的第一个进程。假设当前所有进程中最高优先级为50（换句话说，系统中没有任何进程的优先级小于50）。则调度器直接读取 active[49]，得到优先级为50的进程队列指针。该队列头上的第一个进程就是被选中的进程。这种算法的复杂度为O(1)，从而解决了2.4调度器的扩展性问题。为了实现O(1)算法active数组维护了一个由5个32位的字（140个优先级）组成的bitmap，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。 sched_find_first_bit()函数查询该bitmap，返回当前被置位的最高优先级的数组下标。在上例中sched_find_first_bit函数将返回49。在IA处理器上可以通过bsfl等指令实现。可见查找一个任务来执行所需要的时间并不依赖于活动任务的个数，而是依赖于优先级的数量。这使得 2.6 版本的调度器成为一个复杂度为 O(1) 的过程，因为调度时间既是固定的，而且也不会受到活动任务个数的影响。</p><p>为了提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法：每次时钟tick中断时，进程的时间片(time_slice)被减一。当time_slice为0时，表示当前进程的时间片用完，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置其时间片并重新插入active数组。如果不是交互式进程则从active数组中移到expired数组，并根据上述公式重新计算时间片。这样实时进程和交互式进程就总能优先获得CPU。然而这些进程不能始终留在active数组中，否则进入expire数组的进程就会产生饥饿现象。当进程已经占用CPU时间超过一个固定值后，即使它是实时进程或者交互式进程也会被移到expire数组中。当active数组中的所有进程都被移到expire数组中后，调度器交换active数组和expire数组。因此新的active数组又恢复了初始情况，而expire数组为空，从而开始新的一轮调度。</p><p>Linux 2.6调度器改进了前任调度器的可扩展性问题，schedule()函数的时间复杂度为O(1)。这取决于两个改进：</p><ul><li>pick next算法借助于active数组，无需遍历runqueue；</li><li>消了定期更新所有进程counter的操作，动态优先级的修改分布在进程切换，时钟tick中断以及其它一些内核函数中进行。</li></ul><p>为了解决O(1)调度器面临的问题以及应对其他外部压力, 需要改变某些东西。这种改变来自Con Kolivas的内核补丁staircase scheduler（楼梯调度算法），以及改进的RSDL（Rotating Staircase Deadline Scheduler）。它为调度器设计提供了一个新的思路。Ingo Molnar在RSDL之后开发了CFS，并最终被2.6.23内核采用。接下来我们开始介绍这些新一代调度器。</p><h2 id="4-Linux-2-6的新一代调度器CFS"><a href="#4-Linux-2-6的新一代调度器CFS" class="headerlink" title="4. Linux 2.6的新一代调度器CFS"></a>4. Linux 2.6的新一代调度器CFS</h2><hr><h3 id="4-1-楼梯调度算法staircase-scheduler"><a href="#4-1-楼梯调度算法staircase-scheduler" class="headerlink" title="4.1 楼梯调度算法staircase scheduler"></a>4.1 楼梯调度算法staircase scheduler</h3><hr><p>楼梯算法(SD)在思路上和O(1)算法有很大不同，它抛弃了动态优先级的概念。而采用了一种完全公平的思路。前任算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。楼梯算法思路简单，但是实验证明它对应交互式进程的响应比其前任更好，而且极大地简化了代码。</p><p>和O(1)算法一样，楼梯算法也同样为每一个优先级维护一个进程列表，并将这些列表组织在active数组中。当选取下一个被调度进程时，SD算法也同样从active数组中直接读取。与O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到expire数组中。而是被加入active数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就象一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为1，当它到达最后一级台阶140后，再次用完时间片时将回到优先级为2的任务队列中，即第二级台阶。不过此时分配给该任务的time_slice将变成原来的2倍。比如原来该任务的时间片time_slice为10ms，则现在变成了20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为P，当它从第N级台阶开始下楼梯并到达底部后，将回到第N+1级台阶。并且赋予该任务N+1倍的时间片。</p><p>以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即FIFO或者Round Robin。</p><p>楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。</p><p>楼梯算法的优点：从实现角度看，SD基本上还是沿用了O(1)的整体框架，只是删除了O(1)调度器中动态修改优先级的复杂代码；还淘汰了expire数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。</p><h3 id="4-2-RSLD-Rotating-Staircase-Deadline-Scheduler"><a href="#4-2-RSLD-Rotating-Staircase-Deadline-Scheduler" class="headerlink" title="4.2 RSLD(Rotating Staircase Deadline Scheduler)"></a>4.2 RSLD(Rotating Staircase Deadline Scheduler)</h3><hr><p>RSDL也是由Con Kolivas开发的，它是对SD算法的改进。核心的思想还是”完全公平”。没有复杂的动态优先级调整策略。RSDL重新引入了expire数组。它为每一个优先级都分配了一个 “组时间配额”，记为Tg；同一优先级的每个进程都拥有同样的”优先级时间配额”，用Tp表示。当进程用完了自身的Tp时，就下降到下一优先级进程组中。这个过程和SD相同，在RSDL中这个过程叫做minor rotation（次轮询）。请注意Tp不等于进程的时间片，而是小于进程的时间片。下图表示了minor rotation。进程从priority1的队列中一步一步下到priority140之后回到priority2的队列中，这个过程如下图左边所示，然后从priority 2开始再次一步一步下楼，到底后再次反弹到priority3队列中，如下图所示。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/RSLD.png?raw=true" width="50%" height="50%"></div><p>在SD算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得CPU。因此低优先级进程的等待时间无法确定。RSDL中，当高优先级进程组用完了它们的Tg(即组时间配额)时，无论该组中是否还有进程Tp尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是RSDL中Deadline代表的含义。<br>进程用完了自己的时间片time_slice时（下图中T2），将放入expire数组指向的对应初始优先级队列中(priority 1)。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/3.png?raw=true" width="50%" height="50%"></div><p>当active数组为空，或者所有的进程都降低到最低优先级时就会触发主轮询major rotation。Major rotation交换active数组和expire数组，所有进程都恢复到初始状态，再一次从新开始minor rotation的过程。<br>RSDL对交互式进程的支持：和SD同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为minor rotation而降到了低优先级进程队列中。当它重新进入RUNNING状态时，就获得了相对较高的优先级，从而能被迅速响应。</p><h3 id="4-3-安全公平的调度器CFS"><a href="#4-3-安全公平的调度器CFS" class="headerlink" title="4.3 安全公平的调度器CFS"></a>4.3 安全公平的调度器CFS</h3><hr><p>CFS是最终被内核采纳的调度器。它从RSDL/SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS的算法和实现都相当简单，众多的测试表明其性能也非常优越。<br>按照作者Ingo Molnar的说法（参考Documentation/scheduler/sched-design-CFS.txt），</p><p>CFS百分之八十的工作可以用一句话概括：CFS在真实的硬件上模拟了完全理想的多任务处理器。在真空的硬件上，同一时刻我们只能运行单个进程，因此当一个进程占用CPU时，其它进程就必须等待，这就产生了不公平。但是在“完全理想的多任务处理器 “下，每个进程都能同时获得CPU的执行时间，即并行地每个进程占1/nr_running的时间。例如当系统中有两个进程时，CPU的计算时间被分成两份，每个进程获得50%。假设runqueue中有n个进程，当前进程运行了10ms。在“完全理想的多任务处理器”中，10ms应该平分给n个进程(不考虑各个进程的nice值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了10ms。所以CFS将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。</p><p>与之前的Linux调度器不同，CFS没有将任务维护在链表式的运行队列中，它抛弃了active/expire数组，而是对每个CPU维护一个以时间为顺序的红黑树。 </p><p>该树方法能够良好运行的原因在于：</p><ul><li>红黑树可以始终保持平衡，这意味着树上没有路径比任何其他路径长两倍以上。</li><li>由于红黑树是二叉树，查找操作的时间复杂度为O(log n)。但是除了最左侧查找以外，很难执行其他查找，并且最左侧的节点指针始终被缓存。</li><li>对于大多数操作（插入、删除、查找等），红黑树的执行时间为O(log n)，而以前的调度程序通过具有固定优先级的优先级数组使用 O(1)。O(log n) 行为具有可测量的延迟，但是对于较大的任务数无关紧要。Molnar在尝试这种树方法时，首先对这一点进行了测试。</li><li>红黑树可通过内部存储实现，即不需要使用外部分配即可对数据结构进行维护。</li></ul><p>要实现平衡，CFS使用”虚拟运行时”表示某个任务的时间量。任务的虚拟运行时越小，意味着任务被允许访问服务器的时间越短，其对处理器的需求越高。CFS还包含睡眠公平概念以便确保那些目前没有运行的任务（例如，等待 I/O）在其最终需要时获得相当份额的处理器。</p><h4 id="4-3-1-CFS如何实现pick-next"><a href="#4-3-1-CFS如何实现pick-next" class="headerlink" title="4.3.1 CFS如何实现pick next"></a>4.3.1 CFS如何实现pick next</h4><hr><p>下图是一个红黑树的例子</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/virtual_running_time.png?raw=true" width="50%" height="50%"></div><p>所有可运行的任务通过不断地插入操作最终都存储在以时间为顺序的红黑树中（由 sched_entity 对象表示），对处理器需求最多的任务（最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧。 为了公平，CFS调度器会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。这样，树左侧的进程就被给予时间运行了。</p><h4 id="4-3-2-tick中断"><a href="#4-3-2-tick中断" class="headerlink" title="4.3.2 tick中断"></a>4.3.2 tick中断</h4><hr><p>在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。从这里可以看到 CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有调度器都在tick中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。</p><h4 id="4-3-3-红黑树键值计算"><a href="#4-3-3-红黑树键值计算" class="headerlink" title="4.3.3 红黑树键值计算"></a>4.3.3 红黑树键值计算</h4><hr><p>理解CFS的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的CPU时间；二是当前进程的nice值；三是当前的cpu负载。进程已经占用的CPU时间对键值的影响最大，其实很大程度上我们在理解CFS时可以简单地认为键值就等于进程已占用的 CPU时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外CFS规定，nice值为1的进程比nice值为0的进程多获得10%的 CPU时间。在计算键值时也考虑到这个因素，因此nice值越大，键值也越大。</p><p>CFS为每个进程都维护两个重要变量：fair_clock和wait_runtime。这里我们将为每个进程维护的变量称为进程级变量，为每个CPU维护的称作CPU级变量，为每个runqueue维护的称为runqueue级变量。进程插入红黑树的键值即为fair_clock – wait_runtime。其中fair_clock从其字面含义上讲就是一个进程应获得的CPU时间，即等于进程已占用的CPU时间除以当前 runqueue中的进程总数；wait_runtime是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。对于交互式任务，wait_runtime长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。</p><p>红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是O(LogN)</p><h4 id="4-3-4-调度器管理器"><a href="#4-3-4-调度器管理器" class="headerlink" title="4.3.4 调度器管理器"></a>4.3.4 调度器管理器</h4><hr><p>为了支持实时进程，CFS提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23中，CFS实现了两个调度算法，CFS算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用CFS算法。CFS 调度模块（在 kernel/sched_fair.c 中实现）用于以下调度策略：SCHED_NORMAL、SCHED_BATCH 和 SCHED_IDLE。对于 SCHED_RR 和 SCHED_FIFO 策略，将使用实时调度模块（该模块在 kernel/sched_rt.c 中实现）。</p><h4 id="4-3-5-CFS组调度"><a href="#4-3-5-CFS组调度" class="headerlink" title="4.3.5 CFS组调度"></a>4.3.5 CFS组调度</h4><hr><p>CFS组调度（在 2.6.24 内核中引入）是另一种为调度带来公平性的方式，尤其是在处理产生很多其他任务的任务时。 假设一个产生了很多任务的服务器要并行化进入的连接（HTTP 服务器的典型架构）。不是所有任务都会被统一公平对待， CFS 引入了组来处理这种行为。产生任务的服务器进程在整个组中（在一个层次结构中）共享它们的虚拟运行时，而单个任务维持其自己独立的虚拟运行时。这样单个任务会收到与组大致相同的调度时间。您会发现 /proc 接口用于管理进程层次结构，让您对组的形成方式有完全的控制。使用此配置，您可以跨用户、跨进程或其变体分配公平性。</p><p>考虑一个两用户示例，用户 A 和用户 B 在一台机器上运行作业。用户 A 只有两个作业正在运行，而用户 B 正在运行 48 个作业。组调度使 CFS 能够对用户 A 和用户 B 进行公平调度，而不是对系统中运行的 50 个作业进行公平调度。每个用户各拥有 50% 的 CPU 使用。用户 B 使用自己 50% 的 CPU 分配运行他的 48 个作业，而不会占用属于用户 A 的另外 50% 的 CPU 分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载至 &lt;a href=&quot;https://blog.csdn.net/gatieme/article/details/51701149&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/gatieme/article
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>构建实现run命令的容器</title>
    <link href="https://meichaofan.github.io/2019/04/24/write-docker-run/"/>
    <id>https://meichaofan.github.io/2019/04/24/write-docker-run/</id>
    <published>2019-04-24T15:24:32.000Z</published>
    <updated>2019-04-25T04:24:32.469Z</updated>
    
    <content type="html"><![CDATA[<p>实现<code>run</code>命令</p><p>构建一个简单版本的<code>run</code>命令，类似于<code>docker run -it [command]</code>，为了了解<code>Docker</code>启动容器的原理，该简单版本的实现参考了<code>runC</code>的实现。</p><hr><p>1.目前的代码文件结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── container</span><br><span class="line">│   ├── container_process.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── main_command.go</span><br><span class="line">├── main.go</span><br><span class="line">├── README.md</span><br><span class="line">└── run.go</span><br></pre></td></tr></table></figure></p><p>2.首先，来看一下入口<code>main</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;github.com/Sirupsen/logrus&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const usage = `my docker is a simple container runtime implement`</span><br><span class="line"></span><br><span class="line">//mydocker run -it /bin/bash</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line">    app.Name = &quot;mydocker&quot;</span><br><span class="line">    app.Usage = usage</span><br><span class="line"></span><br><span class="line">    app.Commands = []cli.Command&#123;</span><br><span class="line">        initCommand,</span><br><span class="line">        runCommand,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置日志格式</span><br><span class="line">    app.Before = func(context *cli.Context) error &#123;</span><br><span class="line">        logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)</span><br><span class="line">        logrus.SetOutput(os.Stdout)</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if err := app.Run(os.Args); err != nil &#123;</span><br><span class="line">        logrus.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 github.com/urfave/cli 提供的命令行工具, 该工具的用法, <a href="/2019/04/22/introducing-urfave-cli/">点此</a>。定义mydocker的两个基本命令,<code>initCommand</code>和<code>runCommand</code>，在app.Before内初始化一下<code>logrus</code>的日志配置。下面看一下，具命令的定义。</p><p>3.<code>runCommand</code> &amp; <code>initCommand</code> 定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//这里定义`runCommand`的`Flags`，其作用类似于命令时使用 -- 来指定参数</span><br><span class="line"></span><br><span class="line">var runCommand = cli.Command&#123;</span><br><span class="line">    Name: &quot;run&quot;,</span><br><span class="line">    Usage: `Create a container with namespace and cgroups limit</span><br><span class="line">           mydocker run -it [command]`,</span><br><span class="line">    Flags: []cli.Flag&#123;</span><br><span class="line">        cli.BoolFlag&#123;</span><br><span class="line">            Name:  &quot;it&quot;,</span><br><span class="line">            Usage: &quot;enable tty&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">    这里是run命令执行的真正函数</span><br><span class="line">    1. 判断参数是否包含command</span><br><span class="line">    2. 获取用户指定的command</span><br><span class="line">    3. 调用 Run function 去准备启动容器</span><br><span class="line">     */</span><br><span class="line">    Action: func(context *cli.Context) error &#123;</span><br><span class="line">        if len(context.Args()) &lt; 1 &#123;</span><br><span class="line">            return fmt.Errorf(&quot;Missing container command&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        cmd := context.Args().Get(0)</span><br><span class="line">        tty := context.Bool(&quot;it&quot;)</span><br><span class="line">        Run(tty, cmd)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义initCommand的具体操作，此操作为内部方法，禁止外部调用</span><br><span class="line">var initCommand = cli.Command&#123;</span><br><span class="line">    Name:  &quot;init&quot;,</span><br><span class="line">    Usage: &quot;Init container process run user&apos;s process in container, Do not call it outside&quot;,</span><br><span class="line">    /**</span><br><span class="line">    1.获取传递过来的command参数</span><br><span class="line">    2.执行容器初始化操作</span><br><span class="line">     */</span><br><span class="line">    Action: func(context *cli.Context) error &#123;</span><br><span class="line">        logrus.Infof(&quot;init come on&quot;)</span><br><span class="line">        cmd := context.Args().Get(0)</span><br><span class="line">        logrus.Infof(&quot;command %s&quot;, cmd)</span><br><span class="line">        err := container.RunContainerInitProcess(cmd, nil)</span><br><span class="line">        return err</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.先来看一下<code>Run</code>和<code>NewParentProcess</code>做了哪些事情。<br>这里是父进程，也就是当前进程执行的内容。</p><ul><li>这里的<code>/proc/self/exe</code>的调用中，<code>/proc/self</code>指的是当前运行进程自己的环境，<code>exec</code>其实就是自己调用了自己，使用这种方式对创建出来的进程初始化。</li><li>后面的<code>args</code>是参数，其中<code>init</code>是传递给本进程的第一个参数，在本例中，其实就会去调用<code>initCommand</code>去初始化进程的一些环境和资源。<code>./mydocker init [command]</code> </li><li>下面的<code>clone</code>参数就是去fork出来一个新的进程，并且使用了<code>namespace</code>隔离新创建的进程和外部环境。</li><li>如果用户指定了 <code>-it</code> 参数，就需要把当前进程的输入输出导入到标准的输入输出上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// conatiner_process.go</span><br><span class="line">package container</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os/exec&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func NewParentProcess(tty bool, command string) *exec.Cmd &#123;</span><br><span class="line">    args := []string&#123;&quot;init&quot;, command&#125;</span><br><span class="line">    cmd := exec.Command(&quot;/proc/self/exe&quot;, args...)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWNET | syscall.CLONE_NEWIPC,</span><br><span class="line">    &#125;</span><br><span class="line">    if tty &#123;</span><br><span class="line">        cmd.Stdin = os.Stdout</span><br><span class="line">        cmd.Stdout = os.Stdout</span><br><span class="line">        cmd.Stderr = os.Stderr</span><br><span class="line">    &#125;</span><br><span class="line">    return cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// run.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;mydocker/container&quot;</span><br><span class="line">    &quot;github.com/Sirupsen/logrus&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//启动init进程</span><br><span class="line">func Run(tty bool, command string) &#123;</span><br><span class="line">    parent := container.NewParentProcess(tty, command)</span><br><span class="line">    if err := parent.Run(); err != nil &#123;</span><br><span class="line">        logrus.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    parent.Wait()</span><br><span class="line">    os.Exit(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.那么<code>init</code>函数里面发生了什么呢？</p><p>这里的<code>init</code>函数是在容器内执行的，也就是说代码执行到这里，容器所在的进程其实已经创建出来了，这是本容器执行的第一个进程。</p><p>使用<code>mount</code>先去挂载<code>proc</code>文件系统，以便后面通过<code>ps</code>命令去查看当前容器内进程情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// init.go </span><br><span class="line">package container</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/Sirupsen/logrus&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func RunContainerInitProcess(command string, args []string) error &#123;</span><br><span class="line">    logrus.Infof(&quot;command %s&quot;, command)</span><br><span class="line">    defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV</span><br><span class="line">    syscall.Mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;)</span><br><span class="line">    argv := []string&#123;command&#125;</span><br><span class="line">    if err := syscall.Exec(command, argv, os.Environ()); err != nil &#123;</span><br><span class="line">        logrus.Errorf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>MountFlag</code>意思如下：</p><ul><li>MS_NOEXEC在本文件系统中不允许运行其它程序</li><li>MS_NOSUID在本文件系统中运行程序的时候，不允许<code>set-user-ID</code>或<code>set-group-ID</code></li><li>MS_NODEV这个参数自Linux2.4以来，所有mount的系统都会默认设定的</li></ul><p><strong>本函数最后的syscall.Exec，这个系统调用实现了完成初始化并将用户进程运行起来的操作。</strong>下面解释一下这句话的神奇之处。</p><p>首先，使用<code>Docker</code>创建起来一个容器后，会发现容器内的第一个进程，也就是PID为1的那个进程，是指定的前台进程。但是，根据前面所讲，容器启动后的第一个进程不是用户进程，而是<code>init</code>初始化的进程。这个时候通过<code>ps</code>命令就会发现，容器内的第一进程变成了自己的<code>init</code>，这个和预想的不一样。你可能回想，大不了把第一个<code>init</code>进程给<code>kill</code>掉。但是PID为1的进程是不能被<code>kill</code>掉的，如果该进程被<code>kill</code>掉，我们的容器也就退出了。那么有什么办法？这里execve系统调用就可以大显神威了。</p><p>syscall.Exec这个方法，其实最终调用了Kernel的int execve(const char <em>filename,const </em>const argv[],char *const envp[]);这个系统函数。它的作用是执行当前的filename对应的程序，会覆盖当前进程的镜像、数据和堆栈等信息，包括PID，这些都会将要运行的进程覆盖掉。也就是说，调用这个方法，将用户指定的进程运行起来，把最初的<code>init</code>进程给替换掉，这样当进入到容器内部的时候，就会发现容器内的第一个程序就是我们指定的进程了[command]。这其实也是目前Docker使用的容器引擎<code>runC</code>的实现方式之一。</p><p>6.流程图如图所示:</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/docker/runc.png?raw=true" width="50%" height="50%"></div><br><div align="center">图1：mydocker 启动流程</div><p>7.下面编译运行一下。</p><blockquote></blockquote><p>#使用 go build，在mydocker目录下进行编译</p><blockquote></blockquote><p>#使用 <code>./mydocker run -it /bin/sh</code> 命令，其中 <code>-it</code> 表示想要以交互的形式运行容器， <code>/bin/bash</code> 为指定容器的第一个进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/home/meichaofan/peek-a-boo/src/mydocker# ./mydocker run -it /bin/sh</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;init come on&quot;,&quot;time&quot;:&quot;2019-04-24T21:09:35-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/sh&quot;,&quot;time&quot;:&quot;2019-04-24T21:09:35-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/sh&quot;,&quot;time&quot;:&quot;2019-04-24T21:09:35-07:00&quot;&#125;</span><br><span class="line"># ps aux</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0   4508   756 pts/0    S    21:09   0:00 /bin/sh</span><br><span class="line">root          5  0.0  0.1  39104  3188 pts/0    R+   21:09   0:00 ps aux</span><br></pre></td></tr></table></figure></p><p>在容器运行 <code>ps -aux</code> 时，可以发现 <code>/bin/sh</code> 进程是容器内的第一个进程，PID=1。而 <code>ps -aux</code> 是PID为1的进程创建出来的。</p><blockquote></blockquote><p>这里的 <code>/bin/sh</code> 是一个会在前台一直运行的进程。如果指定一个运行就退出的进程会是什么效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/home/meichaofan/peek-a-boo/src/mydocker# ./mydocker run -it /bin/ls</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;init come on&quot;,&quot;time&quot;:&quot;2019-04-24T21:19:05-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/ls&quot;,&quot;time&quot;:&quot;2019-04-24T21:19:05-07:00&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;command /bin/ls&quot;,&quot;time&quot;:&quot;2019-04-24T21:19:05-07:00&quot;&#125;</span><br><span class="line">container  main_command.go  main.go  mydocker  README.md  run.go</span><br></pre></td></tr></table></figure></p><p>由于没有<code>chroot</code>，所以目前的系统文件是继承宿主主机的系统文件，运行了一下 <code>ls</code> 命令，当容器启动起来以后，打印出了当前目录内容，然后便退出了，这个结果和Docker要求容器必须有一个一直在前台运行的进程的要求是一致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现&lt;code&gt;run&lt;/code&gt;命令&lt;/p&gt;
&lt;p&gt;构建一个简单版本的&lt;code&gt;run&lt;/code&gt;命令，类似于&lt;code&gt;docker run -it [command]&lt;/code&gt;，为了了解&lt;code&gt;Docker&lt;/code&gt;启动容器的原理，该简单版本的实现参
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="runC" scheme="https://meichaofan.github.io/tags/runC/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关软件和命令</title>
    <link href="https://meichaofan.github.io/2019/04/23/about-linux-software/"/>
    <id>https://meichaofan.github.io/2019/04/23/about-linux-software/</id>
    <published>2019-04-23T06:50:43.000Z</published>
    <updated>2019-04-23T06:52:29.206Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要介绍Linux相关软件安装和日常使用命令</p><hr><ul><li><a href="/2019/04/23/httpie-a-http-client/">HTTPie - 一款http客户端工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里主要介绍Linux相关软件安装和日常使用命令&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2019/04/23/httpie-a-http-client/&quot;&gt;HTTPie - 一款http客户端工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="https://meichaofan.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTPie - 一款http客户端</title>
    <link href="https://meichaofan.github.io/2019/04/23/httpie-a-http-client/"/>
    <id>https://meichaofan.github.io/2019/04/23/httpie-a-http-client/</id>
    <published>2019-04-23T06:22:03.000Z</published>
    <updated>2019-04-23T06:48:20.589Z</updated>
    
    <content type="html"><![CDATA[<p>一款http客户端</p><hr><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>具表达力和直观语法</li><li>格式化的及彩色化的终端输出</li><li>内置JSON支持</li><li>表单和文件上传</li><li>HTTPS、代理和认证</li><li>任意请求数据</li><li>自定义头部</li><li>持久化会话</li><li>类似于wget的下载</li><li>支持Python2.7 和 3.x</li></ul><h3 id="在Linux下安装Httpie"><a href="#在Linux下安装Httpie" class="headerlink" title="在Linux下安装Httpie"></a>在Linux下安装Httpie</h3><ol><li><p>Debian/Ubuntu系统，使用<code>apt-get</code>或<code>apt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install httpie</span><br></pre></td></tr></table></figure></li><li><p>RHEL/CentOs系统，使用<code>yum</code>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install httpie</span><br></pre></td></tr></table></figure></li></ol><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li><p>如何使用HTTPie请求URL？<br>httpie的基本用法是将URL作为参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~$ http 2daygeek.com</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">CF-RAY: 4cbdc9a7b85322a0-LAX</span><br><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 23 Apr 2019 06:30:15 GMT</span><br><span class="line">Expires: Tue, 23 Apr 2019 07:30:15 GMT</span><br><span class="line">Location: https://2daygeek.com/</span><br><span class="line">Server: cloudflare</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure></li><li><p>如何使用HTTPie下载文件<br>带 <code>--download</code> 参数，用来下载文件，类似于wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~$ http --download https://www.2daygeek.com/wp-content/uploads/2019/04/Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">CF-Cache-Status: HIT</span><br><span class="line">CF-RAY: 4cbdcfbafb53540e-LAX</span><br><span class="line">Cache-Control: public, max-age=7200</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 32066</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Date: Tue, 23 Apr 2019 06:34:23 GMT</span><br><span class="line">Expect-CT: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot;</span><br><span class="line">Expires: Tue, 23 Apr 2019 08:34:23 GMT</span><br><span class="line">Last-Modified: Mon, 08 Apr 2019 04:54:25 GMT</span><br><span class="line">Server: cloudflare</span><br><span class="line">Set-Cookie: __cfduid=dee8965dcfafc633c5463965e0c40522d1556001263; expires=Wed, 22-Apr-20 06:34:23 GMT; path=/; domain=.2daygeek.com; HttpOnly; Secure</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line"></span><br><span class="line">Downloading 31.31 kB to &quot;Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png&quot;</span><br><span class="line">Done. 31.31 kB in 0.55747s (56.17 kB/s)</span><br><span class="line">meichaofan@ubuntu1:~$ ls</span><br><span class="line">Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png  package  peek-a-boo</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>-o</code> 参数用不同的名称保存输出文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~$ http --download https://www.2daygeek.com/wp-content/uploads/2019/04/Anbox-Easy-Way-To-Run-Android-Apps-On-Linux.png -o Anbox-1.png</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">CF-Cache-Status: HIT</span><br><span class="line">CF-RAY: 4cbdd1493c0e5047-LAX</span><br><span class="line">Cache-Control: public, max-age=7200</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 32066</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Date: Tue, 23 Apr 2019 06:35:27 GMT</span><br><span class="line">Expect-CT: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot;</span><br><span class="line">Expires: Tue, 23 Apr 2019 08:35:27 GMT</span><br><span class="line">Last-Modified: Mon, 08 Apr 2019 04:54:25 GMT</span><br><span class="line">Server: cloudflare</span><br><span class="line">Set-Cookie: __cfduid=d4ac029dc64db0797db8e607d6a8568341556001327; expires=Wed, 22-Apr-20 06:35:27 GMT; path=/; domain=.2daygeek.com; HttpOnly; Secure</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line"></span><br><span class="line">Downloading 31.31 kB to &quot;Anbox-1.png&quot;</span><br><span class="line">Done. 31.31 kB in 0.28450s (110.07 kB/s)</span><br><span class="line">meichaofan@ubuntu1:~$ ls</span><br><span class="line">Anbox-1.png  package  peek-a-boo</span><br></pre></td></tr></table></figure></li><li><p>如何使用 HTTPie 恢复部分下载？<br>可以使用 <code>-c</code> 参数的HTTPie继续下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http --download --continue https://speed.hetzner.de/100MB.bin -o 100MB.bin</span><br></pre></td></tr></table></figure></li><li><p>如何使用 HTTPie 上传文件？<br>你可以通过使用带有小于号 <code>&lt;</code> 的 HTTPie 命令上传文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http https://transfer.sh &lt; Anbox-1.png</span><br></pre></td></tr></table></figure></li><li><p>如何使用带有重定向符号 <code>&gt;</code> 下载文件？<br>你可以使用带有重定向 <code>&gt;</code> 符号的 HTTPie 命令下载文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ http https://www.2daygeek.com/wp-content/uploads/2019/03/How-To-Install-And-Enable-Flatpak-Support-On-Linux-1.png &gt; Flatpak.png</span><br><span class="line">$ ls -ltrh Flatpak.png</span><br><span class="line">-rw-r--r-- 1 root root 47K Apr  9 01:44 Flatpak.png</span><br></pre></td></tr></table></figure></li><li><p>发送一个 HTTP GET 请求？<br>您可以在请求中发送 HTTP GET 方法。GET 方法会使用给定的 URI，从给定服务器检索信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http GET httpie.org</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">CF-RAY: 4c4a83a3f90dcbe6-SIN</span><br><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 09 Apr 2019 06:44:44 GMT</span><br><span class="line">Expires: Tue, 09 Apr 2019 07:44:44 GMT</span><br><span class="line">Location: https://httpie.org/</span><br><span class="line">Server: cloudflare</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure></li><li><p>提交表单<br>使用以下格式提交表单。POST 请求用于向服务器发送数据，例如客户信息、文件上传等。要使用 HTML 表单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http -f POST Ubuntu18.2daygeek.com hello=&apos;World&apos;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 3138</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 09 Apr 2019 06:48:12 GMT</span><br><span class="line">ETag: &quot;2aa6-5844bf1b047fc-gzip&quot;</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Last-Modified: Sun, 17 Mar 2019 15:29:55 GMT</span><br><span class="line">Server: Apache/2.4.29 (Ubuntu)</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure><p>运行下面的指令以查看正在发送的请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http -v Ubuntu18.2daygeek.com</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: ubuntu18.2daygeek.com</span><br><span class="line">User-Agent: HTTPie/0.9.8</span><br><span class="line">hello=World</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 3138</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 09 Apr 2019 06:48:30 GMT</span><br><span class="line">ETag: &quot;2aa6-5844bf1b047fc-gzip&quot;</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Last-Modified: Sun, 17 Mar 2019 15:29:55 GMT</span><br><span class="line">Server: Apache/2.4.29 (Ubuntu)</span><br><span class="line">Vary: Accept-Encoding</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一款http客户端&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;主要特点&quot;&gt;&lt;a href=&quot;#主要特点&quot; class=&quot;headerlink&quot; title=&quot;主要特点&quot;&gt;&lt;/a&gt;主要特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;具表达力和直观语法&lt;/li&gt;
&lt;li&gt;格式化的及彩色化的终端输出&lt;/
      
    
    </summary>
    
    
      <category term="linux" scheme="https://meichaofan.github.io/tags/linux/"/>
    
      <category term="http" scheme="https://meichaofan.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>介绍urfave/cli 一款构建命令行app的go包</title>
    <link href="https://meichaofan.github.io/2019/04/22/introducing-urfave-cli/"/>
    <id>https://meichaofan.github.io/2019/04/22/introducing-urfave-cli/</id>
    <published>2019-04-22T14:53:29.000Z</published>
    <updated>2019-04-24T15:22:54.724Z</updated>
    
    <content type="html"><![CDATA[<p>一个简单，快速构建基于命令行应用的工具包<br><a href="https://github.com/urfave/cli" target="_blank" rel="noopener">https://github.com/urfave/cli</a></p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/urfave/cli</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.Cli的哲学之一是API应该有趣和充满惊喜，所以cli应用程序可以做到在<code>main()</code>函数里只有一行代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    err := cli.NewApp().Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.1.运行并输出一些默认信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   one - A new cli application</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   one [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.0.0</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">     help, h  Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --help, -h     show help</span><br><span class="line">   --version, -v  print the version</span><br></pre></td></tr></table></figure></p><p>2.设置执行动作，和输出一些帮助文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line">    app.Name = &quot;boom&quot;</span><br><span class="line">    app.Usage = &quot;make an explosive entrance&quot;</span><br><span class="line">    app.Action = func(c *cli.Context) error &#123;</span><br><span class="line">        fmt.Println(&quot;boom! I say!&quot;)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := app.Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.1.编译并运行 go build . &amp;&amp; ./main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/two$ go run main.go</span><br><span class="line">boom! I say!</span><br></pre></td></tr></table></figure></p><p>2.2.运行 ./main -h , 可以看到，显示有相关文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/two$ ./main -h</span><br><span class="line">NAME:</span><br><span class="line">   boom - make an explosive entrance</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   main [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   0.0.0</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">     help, h  Shows a list of commands or help for one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --help, -h     show help</span><br><span class="line">   --version, -v  print the version</span><br></pre></td></tr></table></figure></p><p>3.支持参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">    app.Action = func(ctx *cli.Context) error &#123;</span><br><span class="line">        fmt.Printf(&quot;Hello %q\n&quot;, ctx.Args().Get(0))</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := app.Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.1.输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/three$ ./main huanhuan</span><br><span class="line">Hello &quot;huanhuan&quot;</span><br></pre></td></tr></table></figure></p><p>4.支持标识位 flags<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;github.com/urfave/cli&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">    app.Flags = []cli.Flag&#123;</span><br><span class="line">        cli.StringFlag&#123;</span><br><span class="line">            Name:  &quot;lang&quot;,</span><br><span class="line">            Value: &quot;english&quot;,</span><br><span class="line">            Usage: &quot;language for the greeting&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.Action = func(ctx *cli.Context) error &#123;</span><br><span class="line"></span><br><span class="line">        name := &quot;huanhuan&quot;</span><br><span class="line">        if ctx.NArg() &gt; 0 &#123;</span><br><span class="line">            name = ctx.Args().Get(0)</span><br><span class="line">            fmt.Printf(&quot;there have %d args&quot;,len(ctx.Args()))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ctx.String(&quot;lang&quot;) == &quot;spanish&quot; &#123;</span><br><span class="line">            fmt.Println(&quot;Hala&quot;, name)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Println(&quot;Hello&quot;, name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := app.Run(os.Args)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.1.注：Flag和argumens要分清楚 ./main –lang spanish aa bb cc ，其中有3个参数，1个标识<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu1:~/peek-a-bow/src/cli/four$ ./main --lang spanish aa bb cc</span><br><span class="line">there have 3 args</span><br><span class="line">Hala aa</span><br></pre></td></tr></table></figure></p><p>5.还可以将flag值注入到变量中，通过变量来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;log&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com/urfave/cli&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  var language string</span><br><span class="line"></span><br><span class="line">  app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">  app.Flags = []cli.Flag &#123;</span><br><span class="line">    cli.StringFlag&#123;</span><br><span class="line">      Name:        &quot;lang&quot;,</span><br><span class="line">      Value:       &quot;english&quot;,</span><br><span class="line">      Usage:       &quot;language for the greeting&quot;,</span><br><span class="line">      Destination: &amp;language,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.Action = func(c *cli.Context) error &#123;</span><br><span class="line">    name := &quot;someone&quot;</span><br><span class="line">    if c.NArg() &gt; 0 &#123;</span><br><span class="line">      name = c.Args()[0]</span><br><span class="line">    &#125;</span><br><span class="line">    if language == &quot;spanish&quot; &#123;</span><br><span class="line">      fmt.Println(&quot;Hola&quot;, name)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fmt.Println(&quot;Hello&quot;, name)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err := app.Run(os.Args)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.指定flag的值，这些值的占位符用后引号表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;log&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com/urfave/cli&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  app := cli.NewApp()</span><br><span class="line"></span><br><span class="line">  app.Flags = []cli.Flag&#123;</span><br><span class="line">    cli.StringFlag&#123;</span><br><span class="line">      Name:  &quot;config, c&quot;,</span><br><span class="line">      Usage: &quot;Load configuration from `FILE`&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err := app.Run(os.Args)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.1.我们将会在帮助中看到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--config FILE, -c FILE   Load configuration from FILE</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个简单，快速构建基于命令行应用的工具包&lt;br&gt;&lt;a href=&quot;https://github.com/urfave/cli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/urfave/cli&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
      
    
    </summary>
    
    
      <category term="cli" scheme="https://meichaofan.github.io/tags/cli/"/>
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>linix之间几种文件传输方式</title>
    <link href="https://meichaofan.github.io/2019/04/22/tranfer-in-linux/"/>
    <id>https://meichaofan.github.io/2019/04/22/tranfer-in-linux/</id>
    <published>2019-04-22T10:43:23.000Z</published>
    <updated>2019-04-22T11:26:03.134Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要在类UNIX主机间，互传文件，下面几个命令可以排上用场了</p><hr><ol><li><p>rsync</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz user@src_host:/path/to/file ./ --delete</span><br></pre></td></tr></table></figure></li><li><p>scp</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们需要在类UNIX主机间，互传文件，下面几个命令可以排上用场了&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;rsync&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ubuntu</title>
    <link href="https://meichaofan.github.io/2019/04/22/about-ubuntu/"/>
    <id>https://meichaofan.github.io/2019/04/22/about-ubuntu/</id>
    <published>2019-04-22T10:19:32.000Z</published>
    <updated>2019-04-28T17:52:12.414Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于Ubuntu系统运维的</p><hr><ul><li><a href="/2019/04/22/change-ip-on-ubuntu/">ubuntu系统修改网卡ip</a></li><li><a href="/2019/04/29/ubuntu-change-runlevel/">ubuntu系统修改默认运行级别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是关于Ubuntu系统运维的&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2019/04/22/change-ip-on-ubuntu/&quot;&gt;ubuntu系统修改网卡ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2019/04/29/ubuntu-chan
      
    
    </summary>
    
    
      <category term="linux" scheme="https://meichaofan.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://meichaofan.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu系统修改网卡ip</title>
    <link href="https://meichaofan.github.io/2019/04/22/change-ip-on-ubuntu/"/>
    <id>https://meichaofan.github.io/2019/04/22/change-ip-on-ubuntu/</id>
    <published>2019-04-22T09:49:25.000Z</published>
    <updated>2019-04-22T09:53:26.881Z</updated>
    
    <content type="html"><![CDATA[<p>需求：将ubuntu系统<code>ens33</code>网卡ip修改为<code>192.168.244.140</code></p><hr><p>1.编辑<code>/etc/network/interfaces</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu:~$ cat /etc/network/interfaces</span><br><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 新增内容</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">address 192.168.244.140</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.244.2</span><br></pre></td></tr></table></figure><p>2.重启网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需求：将ubuntu系统&lt;code&gt;ens33&lt;/code&gt;网卡ip修改为&lt;code&gt;192.168.244.140&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.编辑&lt;code&gt;/etc/network/interfaces&lt;/code&gt;文件&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="linux" scheme="https://meichaofan.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://meichaofan.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>利用docker搭建samba目录共享</title>
    <link href="https://meichaofan.github.io/2019/04/22/docker-run-samba/"/>
    <id>https://meichaofan.github.io/2019/04/22/docker-run-samba/</id>
    <published>2019-04-21T17:20:04.000Z</published>
    <updated>2019-04-22T10:16:42.747Z</updated>
    
    <content type="html"><![CDATA[<p>1.下载samba镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dperson/samba</span><br></pre></td></tr></table></figure></p><p>2.启动镜像，具体配置看文档，但重要的配置是一下的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name samba \</span><br><span class="line">-it -p 139:139 -p 445:445 \</span><br><span class="line">-v /home/meichaofan:/home/meichaofan \</span><br><span class="line">-v /etc/passwd:/etc/passwd \</span><br><span class="line">-v /etc/group:/etc/group \</span><br><span class="line">-d dperson/samba \</span><br><span class="line">-u &quot;meichaofan;huanhuan0921&quot; \</span><br><span class="line">-s &quot;meichaofan home;/home/meichaofan;yes;no;no;all;none&quot;</span><br></pre></td></tr></table></figure></p><p>3.替换samba的启动用户，与权限相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it samba sed -i &apos;s/force user = smbuser/force user = meichaofan/g&apos; /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></p><p>3.替换samba的启动组，与权限相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it samba sed -i &apos;s/force group = users/force group = meichaofan/g&apos; /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></p><p>4.重启samba<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart samba</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.下载samba镜像&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;co
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="samba" scheme="https://meichaofan.github.io/tags/samba/"/>
    
  </entry>
  
  <entry>
    <title>Docker 存储驱动之 overlay</title>
    <link href="https://meichaofan.github.io/2019/04/21/docker-overlay/"/>
    <id>https://meichaofan.github.io/2019/04/21/docker-overlay/</id>
    <published>2019-04-20T18:10:34.000Z</published>
    <updated>2019-04-20T18:15:02.549Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="overlayFs" scheme="https://meichaofan.github.io/tags/overlayFs/"/>
    
  </entry>
  
  <entry>
    <title>Docker 存储驱动之 overlay2</title>
    <link href="https://meichaofan.github.io/2019/04/21/docker-overlay2/"/>
    <id>https://meichaofan.github.io/2019/04/21/docker-overlay2/</id>
    <published>2019-04-20T17:05:59.000Z</published>
    <updated>2019-04-20T18:10:22.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="overlay2中镜像和容器的磁盘结构"><a href="#overlay2中镜像和容器的磁盘结构" class="headerlink" title="overlay2中镜像和容器的磁盘结构"></a>overlay2中镜像和容器的磁盘结构</h3><p>docker pull ubuntu:14.04下载了包含4层的镜像，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# docker pull ubuntu:14.04</span><br><span class="line">14.04: Pulling from library/ubuntu</span><br><span class="line">e082d4499130: Pull complete </span><br><span class="line">371450624c9e: Pull complete </span><br><span class="line">c8a555b3a57c: Pull complete </span><br><span class="line">1456d810d42e: Pull complete </span><br><span class="line">Digest: sha256:6612de24437f6f01d6a2988ed9a36b3603df06e8d2c0493678f3ee696bc4bb2d</span><br><span class="line">Status: Downloaded newer image for ubuntu:14.04</span><br></pre></td></tr></table></figure></p><p>可以在/var/lib/docker/overlay2中看到，有5个目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www overlay2]# ll -h</span><br><span class="line">total 28K</span><br><span class="line">drwx------ 4 root root 4.0K Apr 21 00:32 0734cd8060d194cf3db93162b421e4f245151920f0b9acda5313ec9f671bc5cc</span><br><span class="line">drwx------ 3 root root 4.0K Apr 21 00:32 153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3</span><br><span class="line">drwx------ 4 root root 4.0K Apr 21 00:32 658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3</span><br><span class="line">drwx------ 4 root root 4.0K Apr 21 00:32 9ff7c96e688b25a7353c83904d791eae357c2e16315ecbe602009678965ce761</span><br><span class="line">drwx------ 2 root root 4.0K Apr 21 00:33 l</span><br></pre></td></tr></table></figure></p><h3 id="l目录的内容"><a href="#l目录的内容" class="headerlink" title="l目录的内容"></a><strong>l</strong>目录的内容</h3><p>其中<strong>l</strong>目录中包含了很多软连接，使用短名称指向了其它层。短名称用于避免mount参数时达到页面大小的限制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www overlay2]# ll l/</span><br><span class="line">total 24</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 2AQ2F7X67IL4TATXIIYO62CM67 -&gt; ../153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 HMOMCX3OAMM4K6KUZORQ7NTIG4 -&gt; ../9ff7c96e688b25a7353c83904d791eae357c2e16315ecbe602009678965ce761/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 JZPHZPG7ZLX7GTKCFVHQZDEF43 -&gt; ../658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3/diff</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 OJ5PMEVISSBQ4X4N2U66YEE6IH -&gt; ../0734cd8060d194cf3db93162b421e4f245151920f0b9acda5313ec9f671bc5cc/diff</span><br></pre></td></tr></table></figure></p><h3 id="mount-查看容器-镜像的层次关系"><a href="#mount-查看容器-镜像的层次关系" class="headerlink" title="mount 查看容器/镜像的层次关系"></a>mount 查看容器/镜像的层次关系</h3><p><strong>现在起一个容器，它会在rootfs层上，加上init层（环境相关）和容器层（读写）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure></p><p>查看mount相关信息，可以看出层级关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mount -l | grep overlay2</span><br><span class="line">/dev/vda1 on /var/lib/docker/overlay2 type ext3 (rw,relatime,data=ordered)</span><br><span class="line">overlay on /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/MXQORLOJXLIRFVZ3R26TNWWURM:/var/lib/docker/overlay2/l/HMOMCX3OAMM4K6KUZORQ7NTIG4:/var/lib/docker/overlay2/l/OJ5PMEVISSBQ4X4N2U66YEE6IH:/var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43:/var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67,upperdir=/var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/diff,workdir=/var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/work)</span><br></pre></td></tr></table></figure></p><p>整理mount信息,如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">merged:</span><br><span class="line">    /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/merged (联合挂载到此目录下)</span><br><span class="line"></span><br><span class="line">workdir:</span><br><span class="line">    /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/work </span><br><span class="line"></span><br><span class="line">upperdir:</span><br><span class="line">    /var/lib/docker/overlay2/bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15/diff (第六层 rw)</span><br><span class="line"></span><br><span class="line">lowerdir:</span><br><span class="line">    /var/lib/docker/overlay2/l/MXQORLOJXLIRFVZ3R26TNWWURM (第5层 init层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/HMOMCX3OAMM4K6KUZORQ7NTIG4 (第四层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/OJ5PMEVISSBQ4X4N2U66YEE6IH (第三层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43 (第二层 ro)</span><br><span class="line">    /var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67 (rootfs 第一层 ro)</span><br></pre></td></tr></table></figure></p><h3 id="各个rootfs层文件内容介绍"><a href="#各个rootfs层文件内容介绍" class="headerlink" title="各个rootfs层文件内容介绍"></a>各个rootfs层文件内容介绍</h3><p>查看rootfs第一层的目录信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 /var/lib/docker/overlay2/l/2AQ2F7X67IL4TATXIIYO62CM67 -&gt; ../153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/diff</span><br><span class="line"></span><br><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 21 root root 4096 Apr 21 00:32 diff</span><br><span class="line">-rw-r--r--  1 root root   26 Apr 21 00:32 link</span><br></pre></td></tr></table></figure></p><p>可以看到，最低层只有两个文件，一个是diff，存放当前层的文件和目录，link则和<code>l</code>目录的软链接向对应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/diff</span><br><span class="line">total 76</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:46 bin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 boot</span><br><span class="line">drwxr-xr-x  3 root root 4096 Mar  5 12:45 dev</span><br><span class="line">drwxr-xr-x 61 root root 4096 Mar  5 12:46 etc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 home</span><br><span class="line">drwxr-xr-x 12 root root 4096 Mar  5 12:46 lib</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 lib64</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 media</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 mnt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 opt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 proc</span><br><span class="line">drwx------  2 root root 4096 Mar  5 12:46 root</span><br><span class="line">drwxr-xr-x  7 root root 4096 Mar  5 12:46 run</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:46 sbin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar  5 12:45 srv</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar 13  2014 sys</span><br><span class="line">drwxrwxrwt  2 root root 4096 Mar  5 12:46 tmp</span><br><span class="line">drwxr-xr-x 10 root root 4096 Mar  5 12:45 usr</span><br><span class="line">drwxr-xr-x 11 root root 4096 Mar  5 12:46 var</span><br><span class="line"></span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/153f0c95b638414d41bb07b9d45243a0219719e468dd9dcb097b80f837b4d8b3/link </span><br><span class="line">2AQ2F7X67IL4TATXIIYO62CM67</span><br></pre></td></tr></table></figure></p><p>查看rootfs第二层信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43</span><br><span class="line">lrwxrwxrwx 1 root root 72 Apr 21 00:32 /var/lib/docker/overlay2/l/JZPHZPG7ZLX7GTKCFVHQZDEF43 -&gt; ../658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3/diff</span><br><span class="line">[root@www ~]# ll /var/lib/docker/overlay2/658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x 6 root root 4096 Apr 21 00:32 diff</span><br><span class="line">-rw-r--r-- 1 root root   26 Apr 21 00:32 link</span><br><span class="line">-rw-r--r-- 1 root root   28 Apr 21 00:32 lower</span><br><span class="line">drwx------ 2 root root 4096 Apr 21 00:32 work</span><br></pre></td></tr></table></figure></p><p>第二层有四个文件，diff 和 link如上所序一样。lower文件的内容是当前层下面的rootfs的软连接名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 第二层rootfs的lower内容</span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/658b3e84761843f58ecaf82e1f987bf32d498b7bd54a9cf40bf6bf635fff8ac3/lower </span><br><span class="line">l/2AQ2F7X67IL4TATXIIYO62CM67</span><br><span class="line"></span><br><span class="line">#第三层rootfs的lower内容</span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/0734cd8060d194cf3db93162b421e4f245151920f0b9acda5313ec9f671bc5cc/lower </span><br><span class="line">l/JZPHZPG7ZLX7GTKCFVHQZDEF43:l/2AQ2F7X67IL4TATXIIYO62CM67</span><br><span class="line"></span><br><span class="line">#第四层rootfs的lower内容</span><br><span class="line">[root@www ~]# cat /var/lib/docker/overlay2/9ff7c96e688b25a7353c83904d791eae357c2e16315ecbe602009678965ce761/lower </span><br><span class="line">l/OJ5PMEVISSBQ4X4N2U66YEE6IH:l/JZPHZPG7ZLX7GTKCFVHQZDEF43:l/2AQ2F7X67IL4TATXIIYO62CM67</span><br></pre></td></tr></table></figure></p><p>最顶层，也就是upperdir层，看一下它的文件目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15]# ls</span><br><span class="line">diff  link  lower  merged  work</span><br></pre></td></tr></table></figure></p><p>upperdir是容器层，是可读写的。在容器中所有修改文件操作最后都在upperdir的<code>diff</code>目录体现，并合并到<code>merged</code>目录下。<code>merged</code>目录是联合后挂载的目录，也是容器的文件系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 假如我docker run -it ubuntu:14.04 /bin/bash 启动了一个容器，然后再其/(根目录)下创建一个Test目录,并在/root目录下新建了一个aa文件，并删除了/bin/ss文件。我们现在看一下upperdir的`diff`目录</span><br><span class="line"></span><br><span class="line">[root@www bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15]# tree diff/</span><br><span class="line">diff/</span><br><span class="line">├── bin</span><br><span class="line">│   └── ss</span><br><span class="line">├── root</span><br><span class="line">│   └── aa</span><br><span class="line">└── Test</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br><span class="line"></span><br><span class="line"># 在看一个merged目录，它是叠加后一个完整的文件系统目录结构</span><br><span class="line">[root@www bda1eaf86f4c4a500aac2418bc45956531e81de6fff829b67452174c891f5f15]# ls merged/</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  Test  tmp  usr  var</span><br></pre></td></tr></table></figure></p><h3 id="OverlayFS-constructs"><a href="#OverlayFS-constructs" class="headerlink" title="OverlayFS constructs"></a>OverlayFS constructs</h3><p>OverlayFS将单个Linux主机上的两个目录合并成一个目录。这些目录被称为层，统一过程被称为联合挂载。OverlayFS底层目录称为lowerdir， 高层目录称为upperdir。合并统一视图称为merged。当需要修改一个文件时，使用CoW将文件从只读的Lower复制到可写的Upper进行修改，结果也保存在Upper层。在Docker中，底下的只读层就是image，可写层就是Container</p><p>下图分层图，镜像层是lowdir，容器层是upperdir，统一的视图层是merged层</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/docker/overlay_constructs.jpg?raw=true" width="50%" height="50%"></div><br><div align="center">OverlayFs constructs</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;overlay2中镜像和容器的磁盘结构&quot;&gt;&lt;a href=&quot;#overlay2中镜像和容器的磁盘结构&quot; class=&quot;headerlink&quot; title=&quot;overlay2中镜像和容器的磁盘结构&quot;&gt;&lt;/a&gt;overlay2中镜像和容器的磁盘结构&lt;/h3&gt;&lt;p&gt;do
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="overlay2" scheme="https://meichaofan.github.io/tags/overlay2/"/>
    
  </entry>
  
  <entry>
    <title>安装Docker CE</title>
    <link href="https://meichaofan.github.io/2019/04/20/install-docker/"/>
    <id>https://meichaofan.github.io/2019/04/20/install-docker/</id>
    <published>2019-04-20T13:41:10.000Z</published>
    <updated>2019-04-20T14:22:15.464Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官网安装文档</a></p><h3 id="卸载老版本"><a href="#卸载老版本" class="headerlink" title="卸载老版本"></a>卸载老版本</h3><p>老版本的Docker，以前叫做<code>docker</code>,<code>docker.io</code>和<code>docker-engine</code>，如果系统里安装了它们，就先卸载掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></p><h3 id="支持的存储系统"><a href="#支持的存储系统" class="headerlink" title="支持的存储系统"></a>支持的存储系统</h3><p>Docker CE在Ubuntu上支持<code>overlay2</code>，<code>aufs</code>,和<code>btrfs</code>文件系统。在Linux内核4.0或更高的内核版本上，默认使用<code>overlay2</code>文件系统，它的性能能高于<code>aufs</code>。如果非要使用<code>aufs</code>，请见<a href>配置Docker CE使用aufs文件系统</a>。</p><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><h4 id="1-使用apt-repository"><a href="#1-使用apt-repository" class="headerlink" title="1.使用apt repository"></a>1.使用apt repository</h4><p><strong>添加仓库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 更新 `apt`</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 安装一些必要的软件</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line"></span><br><span class="line"># 下载Docker官方GPG key</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># 检验指纹 `9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">    </span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br><span class="line"></span><br><span class="line"># 添加仓库</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></p><p><strong>安装Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 默认安装最新版本</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"># 可以安装指定版本</span><br><span class="line"># 1.查看可用版本</span><br><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"># 2.安装指定版本</span><br><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure></p><h4 id="2-使用deb包安装"><a href="#2-使用deb包安装" class="headerlink" title="2.使用deb包安装"></a>2.使用deb包安装</h4><p>1.去 <a href="https://download.docker.com/linux/ubuntu/dists/" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu/dists/</a> 网站，选择合适的<code>.deb</code>文件<br>2.安装<code>.deb</code>包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i /path/to/package.deb</span><br></pre></td></tr></table></figure></p><h4 id="3-使用shell脚本安装"><a href="#3-使用shell脚本安装" class="headerlink" title="3.使用shell脚本安装"></a>3.使用shell脚本安装</h4><ol><li>脚本在 get.docker.com</li><li>不建议在生产环境直接使用脚本安装docker</li><li>安装步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line">&lt;output truncated&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="添加非root用户到docker组"><a href="#添加非root用户到docker组" class="headerlink" title="添加非root用户到docker组"></a>添加非root用户到docker组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker your-user</span><br></pre></td></tr></table></figure><h3 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h3><p>1.卸载Docker CE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure></p><p>2.镜像、数据卷、容器和一些自定义的配置文件不会自动删除，需要手动删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网安装文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;卸载老版本&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker运维相关</title>
    <link href="https://meichaofan.github.io/2019/04/20/about-use-docker/"/>
    <id>https://meichaofan.github.io/2019/04/20/about-use-docker/</id>
    <published>2019-04-20T13:34:52.000Z</published>
    <updated>2019-04-20T17:05:45.759Z</updated>
    
    <content type="html"><![CDATA[<p>记录Docker在日常学习和工作中的相关积累</p><hr><ul><li><p>Docker运维</p><ul><li>安装Docker</li></ul></li><li><p>Image相关</p></li><li><p>Unionfs<br> *overlay2</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录Docker在日常学习和工作中的相关积累&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker运维&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装Docker&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Image相关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unionfs&lt;br&gt; *
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="DevOps" scheme="https://meichaofan.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写docker</title>
    <link href="https://meichaofan.github.io/2019/04/20/write-docker-self/"/>
    <id>https://meichaofan.github.io/2019/04/20/write-docker-self/</id>
    <published>2019-04-20T10:47:51.000Z</published>
    <updated>2019-04-24T15:27:37.762Z</updated>
    
    <content type="html"><![CDATA[<p>Docker目前是后端服务中最火的技术之一，读这本书《自己动手写docker》，对自己来说，主要是从原理上熟悉docker，顺便复习go语言</p><hr><ul><li><p>容器技术的发展</p><ul><li>docker VS 虚拟机</li></ul></li><li><p>基础技术</p><ul><li>docker namespace<ul><li>UTS</li><li>USER</li></ul></li><li>docker cgroup</li><li>aufs</li></ul></li><li><p>构建容器</p><ul><li><a href="/2019/04/24/write-docker-run/">构建实现run命令的容器</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker目前是后端服务中最火的技术之一，读这本书《自己动手写docker》，对自己来说，主要是从原理上熟悉docker，顺便复习go语言&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容器技术的发展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker VS 虚拟机&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>深入理解容器镜像</title>
    <link href="https://meichaofan.github.io/2019/04/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/"/>
    <id>https://meichaofan.github.io/2019/04/18/深入理解容器镜像/</id>
    <published>2019-04-17T17:53:05.000Z</published>
    <updated>2019-04-17T19:17:05.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Namespace和Cgroups"><a href="#Namespace和Cgroups" class="headerlink" title="Namespace和Cgroups"></a>Namespace和Cgroups</h2><p>正如前面所讲，“容器的本质只是一个特殊的进程”。主要是利用Namespace和Cgroup的特性。正如前面所讲，Namespace的作用是“隔离”，它让应用程序只能看到Namespace内的“世界”；而Cgroups的作用是“限制”，它限制“世界”使用某些资源。经过这么一折腾，进程就被“装”在了一个与世隔绝的房间里，而这些房间就是Paas项目赖以生存的应用“沙盒”。</p><h2 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h2><p>可是，还有一个问题不知道你有没有仔细思考过：<strong>这个房间四周虽然有了墙，但是如果容器进程低头一看地面，又是怎样一副景象呢？</strong></p><p>可能你立即想到了,这一定是一个Mount Namespace的问题：容器里的应用进程，理应当看到了一份完全独立的文件系统，这样它就可以在自己容器目录(/tmp)下进行操作，而完全不受宿主主机以及其他容器的影响。</p><p>那么，真实情况是这样吗？</p><p>“左耳朵耗子”叔在多年前写的一篇<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">关于 Docker 基础知识的博客</a>里，曾经介绍过一段小程序。这段小程序的作用是，在创建子进程时开启指定的 Namespace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/mount.h&gt; </span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">  &quot;/bin/bash&quot;,</span><br><span class="line">  NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;  </span><br><span class="line">  printf(&quot;Container - inside the container!\n&quot;);</span><br><span class="line">  execv(container_args[0], container_args);</span><br><span class="line">  printf(&quot;Something&apos;s wrong!\n&quot;);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Parent - start a container!\n&quot;);</span><br><span class="line">  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , NULL);</span><br><span class="line">  waitpid(container_pid, NULL, 0);</span><br><span class="line">  printf(&quot;Parent - container stopped!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是：在main函数中，通过clone()系统调用创建一个新的子进程 container_main，并且声明要为它启用Mount Namespace（即：CLONE_NEWNS标志）</p><p>而这个子进程执行的，是一个“/bin/bash”程序，也就是一个 shell。所以这个 shell 就运行在了 Mount Namespace 的隔离环境中。</p><p>编译运行这个程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make ns</span><br><span class="line">$ ./ns</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br></pre></td></tr></table></figure></p><p>这样，我们就进入了这个“容器”当中。可是，如果在“容器”里执行一下 ls 指令的话，我们就会发现一个有趣的现象： /tmp 目录下的内容跟宿主机的内容是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /tmp</span><br><span class="line"># 你会看到好多宿主机的文件</span><br></pre></td></tr></table></figure><p>也就是说：</p><blockquote><p>即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。</p></blockquote><p>这是怎么回事呢？</p><p>其实这并不难理解：Mount Namespace修改的，是容器进程对“挂载点”的认知。但是这就意味着，只有在“挂载点”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器进程挂载点是直接继承宿主主机的各个挂载点。</p><p>这时，你可能已经想到了一个解决办法：创建新进程时，除了声明要启用 Mount Namespace 之外，我们还可以告诉容器进程，有哪些目录需要重新挂载，就比如这个 /tmp 目录。于是，我们在容器进程执行前可以添加一步重新挂载 /tmp 目录的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Container - inside the container!\n&quot;);</span><br><span class="line">  // 如果你的机器的根目录的挂载类型是 shared，那必须先重新挂载根目录</span><br><span class="line">  // mount(&quot;&quot;, &quot;/&quot;, NULL, MS_PRIVATE, &quot;&quot;);</span><br><span class="line">  mount(&quot;none&quot;, &quot;/tmp&quot;, &quot;tmpfs&quot;, 0, &quot;&quot;);</span><br><span class="line">  execv(container_args[0], container_args);</span><br><span class="line">  printf(&quot;Something&apos;s wrong!\n&quot;);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在修改后的代码里，我在容器进程启动之前，加上了一句 mount(“none”, “/tmp”, “tmpfs”, 0, “”) 语句。就这样，我告诉了容器以 tmpfs（内存盘）格式，重新挂载了 /tmp 目录。</p><p>这段修改后的代码，编译执行后的结果又如何呢？我们可以试验一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o ns ns.c</span><br><span class="line">$ ./ns</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container - inside the container!</span><br><span class="line">$ ls /tmp</span><br></pre></td></tr></table></figure><p>可以看到，这次 /tmp 变成了一个空目录，这意味着重新挂载生效了。我们可以用 mount -l 检查一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mount -l | grep tmpfs</span><br><span class="line">none on /tmp type tmpfs (rw,relatime)</span><br></pre></td></tr></table></figure><p>可以看到，容器里的 /tmp 目录是以 tmpfs 方式单独挂载的。</p><p>更重要的是，因为我们创建的新进程启用了 Mount Namespace，所以这次重新挂载的操作，只在容器进程的 Mount Namespace 中有效。如果在宿主机上用 mount -l 来检查一下这个挂载，你会发现它是不存在的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机上</span><br><span class="line">$ mount -l | grep tmpfs</span><br></pre></td></tr></table></figure><p>这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</p><p>可是，作为一个普通用户，我们希望的是一个更友好的情况：每当创建一个新容器时，我希望容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统。怎么才能做到这一点呢？</p><p>不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p><p>为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls /“ 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。</p><p>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</p><p>所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br><span class="line">bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var</span><br></pre></td></tr></table></figure><p>而你进入容器之后执行的 /bin/bash，就是 /bin 目录下的可执行文件，与宿主机的 /bin/bash 完全不同。</p><p>现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p><ul><li>启用 Linux Namespace 配置；</li><li>设置指定的 Cgroups 参数；</li><li>切换进程的根目录（Change Root）。</li></ul><p>这样，一个完整的容器就诞生了。不过，Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。这两个系统调用虽然功能类似，但是也有细微的区别，这一部分小知识就交给你课后去探索了。</p><h2 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h2><p>另外，需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p><p>所以说，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。<br>那么，对于容器来说，这个操作系统的“灵魂”又在哪里呢？<br>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核。</p><p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</p><p>这也是容器相比于虚拟机的主要缺陷之一：毕竟后者不仅有模拟出来的硬件机器充当沙盒，而且每个沙盒里还运行着一个完整的 Guest OS 给应用随便折腾。</p><p>不过，正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性。</p><p>什么是容器的“一致性”呢？</p><p>我在专栏的第一篇文章《小鲸鱼大事记（一）：初出茅庐》中曾经提到过：由于云端与本地服务器环境不同，应用的打包过程，一直是使用 PaaS 时最“痛苦”的一个步骤。</p><p>但有了容器之后，更准确地说，有了容器镜像（即 rootfs）之后，这个问题被非常优雅地解决了。</p><p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</p><p>事实上，对于大多数开发者而言，他们对应用依赖的理解，一直局限在编程语言层面。比如 Golang 的 Godeps.json。但实际上，一个一直以来很容易被忽视的事实是，对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”。</p><p>有了容器镜像“打包操作系统”的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器所谓的一致性：无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。</p><p><strong>这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。</strong></p><p>不过，这时你可能已经发现了另一个非常棘手的问题：难道我每开发一个应用，或者升级一下现有的应用，都要重复制作一次 rootfs 吗？</p><p>比如，我现在用 Ubuntu 操作系统的 ISO 做了一个 rootfs，然后又在里面安装了 Java 环境，用来部署我的 Java 应用。那么，我的另一个同事在发布他的 Java 应用时，显然希望能够直接使用我安装过 Java 环境的 rootfs，而不是重复这个流程。</p><p>一种比较直观的解决办法是，我在制作 rootfs 的时候，每做一步“有意义”的操作，就保存一个 rootfs 出来，这样其他同事就可以按需求去用他需要的 rootfs 了。</p><p>但是，这个解决办法并不具备推广性。原因在于，一旦你的同事们修改了这个 rootfs，新旧两个 rootfs 之间就没有任何关系了。这样做的结果就是极度的碎片化。</p><p>那么，既然这些修改都基于一个旧的 rootfs，我们能不能以增量的方式去做这些修改呢？这样做的好处是，所有人都只需要维护相对于 base rootfs 修改的增量内容，而不是每次修改都制造一个“fork”。</p><p>答案当然是肯定的。</p><p>这也正是为何，Docker 公司在实现 Docker 镜像时并没有沿用以前制作 rootfs 的标准流程，而是做了一个小小的创新：</p><blockquote><p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p></blockquote><p>当然，这个想法不是凭空臆造出来的，而是用到了一种叫作联合文件系统（Union File System）的能力。Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│  ├── a</span><br><span class="line">│  └── x</span><br><span class="line">└── B</span><br><span class="line">  ├── b</span><br><span class="line">  └── x</span><br></pre></td></tr></table></figure><p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir C</span><br><span class="line">$ mount -t aufs -o dirs=./A:./B none ./C</span><br></pre></td></tr></table></figure></p><p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./C</span><br><span class="line">./C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br></pre></td></tr></table></figure></p><p>可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。这，就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。</p><p>那么在Docker中如何使用这种Union File System的呢？</p><p>我的环境是 Ubuntu 16.04 和 Docker CE 18.05，这对组合默认使用的是 AuFS 这个联合文件系统的实现。你可以通过 docker info 命令，查看到这个信息。<br>AuFS 的全称是 Another UnionFS，后改名为 Alternative UnionFS，再后来干脆改名叫作 Advance UnionFS。</p><p>对于 AuFS 来说，它最关键的目录结构在 /var/lib/docker 路径下的 diff 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/diff/&lt;layer_id&gt;</span><br></pre></td></tr></table></figure></p><p>现在，我们启动一个容器，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:latest sleep 3600</span><br></pre></td></tr></table></figure></p><p>这时候，Docker 就会从 Docker Hub 上拉取一个 Ubuntu 镜像到本地。</p><p>这个所谓的“镜像”，实际上就是一个 Ubuntu 操作系统的 rootfs，它的内容是 Ubuntu 操作系统的所有文件和目录。不过，与之前我们讲述的 rootfs 稍微不同的是，Docker 镜像使用的 rootfs，往往由多个“层”组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect ubuntu:latest</span><br><span class="line">...</span><br><span class="line">     &quot;RootFS&quot;: &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">      &quot;Layers&quot;: [</span><br><span class="line">        &quot;sha256:f49017d4d5ce9c0f544c...&quot;,</span><br><span class="line">        &quot;sha256:8f2b771487e9d6354080...&quot;,</span><br><span class="line">        &quot;sha256:ccd4d61916aaa2159429...&quot;,</span><br><span class="line">        &quot;sha256:c01d74f99de40e097c73...&quot;,</span><br><span class="line">        &quot;sha256:268a067217b5fe78e000...&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个 Ubuntu 镜像，实际上由五个层组成。这五个层就是五个增量 rootfs，每一层都是 Ubuntu 操作系统文件与目录的一部分；而在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上（等价于前面例子里的“/C”目录）。这个挂载点就是 /var/lib/docker/aufs/mnt/，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e</span><br></pre></td></tr></table></figure><p>不出意外的，这个目录里面正是一个完整的 Ubuntu 操作系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fcfa2a2f5c89dc21ee30e166be823ceaeba15dce645b3e</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>那么，前面提到的五个镜像层，又是如何被联合挂载成这样一个完整的 Ubuntu 文件系统的呢？<br>这个信息记录在 AuFS 的系统目录 /sys/fs/aufs 下面。<br>首先，通过查看 AuFS 的挂载信息，我们可以找到这个目录对应的 AuFS 的内部 ID（也叫：si）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/mounts| grep aufs</span><br><span class="line">none /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc... aufs rw,relatime,si=972c6d361e6b32ba,dio,dirperm1 0 0</span><br></pre></td></tr></table></figure><p>即，si=972c6d361e6b32ba。<br>然后使用这个 ID，你就可以在 /sys/fs/aufs 下查看被联合挂载在一起的各个层的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*</span><br><span class="line">/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...=rw</span><br><span class="line">/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...-init=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/32e8e20064858c0f2...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/2b8858809bce62e62...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/20707dce8efc0d267...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/72b0744e06247c7d0...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/a524a729adadedb90...=ro+wh</span><br></pre></td></tr></table></figure><p>从这些信息里，我们可以看到，镜像的层都放置在 /var/lib/docker/aufs/diff 目录下，然后被联合挂载在 /var/lib/docker/aufs/mnt 里面。<br>而且，从这个结构可以看出来，这个容器的 rootfs 由如下图所示的三部分组成：</p><p><strong>这里有一个图</strong></p><p>第一部分，只读层。<br>它是这个容器的 rootfs 最下面的五层，对应的正是 ubuntu:latest 镜像的五层。可以看到，它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout，至于什么是 whiteout，我下面马上会讲到）。<br>这时，我们可以分别查看一下这些层的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker/aufs/diff/72b0744e06247c7d0...</span><br><span class="line">etc sbin usr var</span><br><span class="line">$ ls /var/lib/docker/aufs/diff/32e8e20064858c0f2...</span><br><span class="line">run</span><br><span class="line">$ ls /var/lib/docker/aufs/diff/a524a729adadedb900...</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>可以看到，这些层，都以增量的方式分别包含了 Ubuntu 操作系统的一部分。</p><p>第二部分，可读写层。</p><p>它是这个容器的 rootfs 最上面的一层（6e3be5d2ecccae7cc），它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。<br>可是，你有没有想到这样一个问题：如果我现在要做的，是删除只读层里的一个文件呢？<br>为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。<br>比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。我喜欢把 whiteout 形象地翻译为：“白障”。<br>所以，最上面这个可读写层的作用，就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。</p><p>第三部分，Init 层。</p><p>它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。<br>需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。<br>可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。<br>所以，Docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 docker commit 只会提交可读写层，所以是不包含这些内容的。<br>最终，这 7 个层都被联合挂载到 /var/lib/docker/aufs/mnt 目录下，表现为一个完整的 Ubuntu 操作系统供容器使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在今天的分享中，我着重介绍了 Linux 容器文件系统的实现方式。而这种机制，正是我们经常提到的容器镜像，也叫作：rootfs。它只是一个操作系统的所有文件和目录，并不包含内核，最多也就几百兆。而相比之下，传统虚拟机的镜像大多是一个磁盘的“快照”，磁盘有多大，镜像就至少有多大。</p><p>通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。当然，这个功能的实现还必须感谢 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。</p><p>而在 rootfs 的基础上，Docker 公司创新性地提出了使用多个增量 rootfs 联合挂载一个完整 rootfs 的方案，这就是容器镜像中“层”的概念。</p><p>通过“分层镜像”的设计，以 Docker 镜像为核心，来自不同公司、不同团队的技术人员被紧密地联系在了一起。而且，由于容器镜像的操作是增量式的，这样每次镜像拉取、推送的内容，比原本多个完整的操作系统的大小要小得多；而共享层的存在，可以使得所有这些容器镜像需要的总空间，也比每个镜像的总和要小。这样就使得基于容器镜像的团队协作，要比基于动则几个 GB 的虚拟机磁盘镜像的协作要敏捷得多。<br>更重要的是，一旦这个镜像被发布，那么你在全世界的任何一个地方下载这个镜像，得到的内容都完全一致，可以完全复现这个镜像制作者当初的完整环境。这，就是容器技术“强一致性”的重要体现。</p><p>而这种价值正是支撑 Docker 公司在 2014~2016 年间迅猛发展的核心动力。容器镜像的发明，不仅打通了“开发 - 测试 - 部署”流程的每一个环节，更重要的是：</p><blockquote><p>容器镜像将会成为未来软件的主流发布方式。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Namespace和Cgroups&quot;&gt;&lt;a href=&quot;#Namespace和Cgroups&quot; class=&quot;headerlink&quot; title=&quot;Namespace和Cgroups&quot;&gt;&lt;/a&gt;Namespace和Cgroups&lt;/h2&gt;&lt;p&gt;正如前面所讲，“容器
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="image" scheme="https://meichaofan.github.io/tags/image/"/>
    
  </entry>
  
</feed>
