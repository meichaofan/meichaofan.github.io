<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>huany</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meichaofan.github.io/"/>
  <updated>2019-08-29T11:47:11.000Z</updated>
  <id>https://meichaofan.github.io/</id>
  
  <author>
    <name>meichaofan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用kubeadm安装k8s</title>
    <link href="https://meichaofan.github.io/2019/08/26/install-k8s/"/>
    <id>https://meichaofan.github.io/2019/08/26/install-k8s/</id>
    <published>2019-08-26T12:41:43.000Z</published>
    <updated>2019-08-29T11:47:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="主机配置和角色分配"><a href="#主机配置和角色分配" class="headerlink" title="主机配置和角色分配"></a>主机配置和角色分配</h3><table><thead><tr><th>ip</th><th>host</th><th>角色</th><th>配置</th></tr></thead><tbody><tr><td>192.168.136.130</td><td>master.huany.com</td><td>master</td><td>CentOS 7.6</td></tr><tr><td>192.168.136.131</td><td>node1.huany.com</td><td>node1</td><td>CentOS 7.6</td></tr><tr><td>192.168.136.132</td><td>node2.huany.com</td><td>node2</td><td>CentOS 7.6</td></tr></tbody></table><h2 id="预先设置"><a href="#预先设置" class="headerlink" title="预先设置"></a>预先设置</h2><h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><ul><li>临时关闭，运行：<code>swapoff -a</code>，下次启动还有</li><li>到/etc/fstab中永久删除或关闭swap分区，使用 # 注释掉即可。</li></ul><h3 id="关闭和清理ufw"><a href="#关闭和清理ufw" class="headerlink" title="关闭和清理ufw"></a>关闭和清理ufw</h3><p>下面的命令将清除现有的所有防火墙规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -F</span><br></pre></td></tr></table></figure></p><h3 id="设置cgroups"><a href="#设置cgroups" class="headerlink" title="设置cgroups"></a>设置cgroups</h3><p>确保kubelet使用的cgroup driver与 Docker的一致。要么使用下面的方法更新 Docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>要么，设置kubernetes的cgroup driver，如：kubelet 的 –cgroup-driver 标志设置为与 Docker 一样(e.g. cgroupfs)。</p><h2 id="安装master节点"><a href="#安装master节点" class="headerlink" title="安装master节点"></a>安装master节点</h2><h3 id="修改内核配置"><a href="#修改内核配置" class="headerlink" title="修改内核配置"></a>修改内核配置</h3><ul><li><p>编辑 /etc/sysctl.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class="line">vm.swappiness = 0</span><br><span class="line">net.ipv4.neigh.default.gc_stale_time = 120</span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.arp_announce = 2</span><br><span class="line">net.ipv4.conf.lo.arp_announce = 2</span><br><span class="line">net.ipv4.conf.all.arp_announce = 2</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65023</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 400000</span><br><span class="line">net.ipv4.tcp_max_orphans = 60000</span><br><span class="line">net.ipv4.tcp_synack_retries = 3</span><br><span class="line">net.core.somaxconn = 10000</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">vm.swappiness = 0</span><br></pre></td></tr></table></figure></li><li><p>然后执行<code>sysctl -p</code>使修改生效</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -p</span><br></pre></td></tr></table></figure><h3 id="安装docker环境"><a href="#安装docker环境" class="headerlink" title="安装docker环境"></a>安装docker环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. SET UP THE REPOSITORY</span><br><span class="line"></span><br><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">2. INSTALL DOCKER ENGINE - COMMUNITY</span><br><span class="line"></span><br><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br><span class="line"></span><br><span class="line">安装18.06.0.ce-3版本</span><br><span class="line">sudo yum install docker-ce-18.06.0.ce-3.e17 docker-ce-cli-18.06.0.ce-3.el7 containerd.io</span><br><span class="line"></span><br><span class="line">3. RUN DOCKER</span><br><span class="line"></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="安装配置kubeadm"><a href="#安装配置kubeadm" class="headerlink" title="安装配置kubeadm"></a>安装配置kubeadm</h3><ul><li>配置阿里云的kubernetes镜像仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ yum makecache fast</span><br></pre></td></tr></table></figure><ul><li>安装kubeadm cni 等工具</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubernetes-cni kubelet kubeadm kubectl --skip-broken</span><br><span class="line">systemctl start kubelet.service</span><br><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure><p><strong>默认情况下这里的kubeadm kubectl kubelet默认安装的都是最新版本</strong></p><ul><li>配置CNI网络配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/cni/net.d/ -p</span><br><span class="line">$ cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;isGateway&quot;: true,</span><br><span class="line">    &quot;ipMasq&quot;: true,</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">            &#123;&quot;dst&quot;: &quot;0.0.0.0/0&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;loopback&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>配置kubeadm的配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: MasterConfiguration</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">#kubernetesVersion: &quot;stable&quot;</span><br><span class="line">kubernetesVersion: &quot;v1.15.3&quot;</span><br><span class="line">apiServerCertSANs: []</span><br><span class="line">#imageRepository: crproxy.trafficmanager.net:6000/google_containers</span><br><span class="line">#imageRepository: mirrorgooglecontainers</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">#imageRepository: &quot;&quot;</span><br><span class="line">controllerManagerExtraArgs:</span><br><span class="line">  horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;</span><br><span class="line">  horizontal-pod-autoscaler-sync-period: &quot;10s&quot;</span><br><span class="line">  node-monitor-grace-period: &quot;10s&quot;</span><br><span class="line">  feature-gates: &quot;AllAlpha=true&quot;</span><br><span class="line">  enable-dynamic-provisioning: &quot;true&quot;</span><br><span class="line">apiServerExtraArgs:</span><br><span class="line">  runtime-config: &quot;api/all=true&quot;</span><br><span class="line">  feature-gates: &quot;AllAlpha=true&quot;</span><br><span class="line">  #feature-gates: &quot;CoreDNS=true&quot;</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: &quot;10.244.0.0/16&quot;</span><br></pre></td></tr></table></figure><ul><li>拉取镜像</li></ul><p>脚本如下，如果需要其它的容器镜像可以照此增加即可，可以将版本号修改为自己需要的。</p><ul><li>注意：kubernetes每个版本依赖的版本不同，下面适用1.15.3。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==================================================&quot;</span><br><span class="line">echo &quot;Pulling Docker Images from registry.aliyuncs.com...&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-apiserver:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-apiserver:v1.15.3 k8s.gcr.io/kube-apiserver:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-controller-manager:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-controller-manager:v1.15.3 k8s.gcr.io/kube-controller-manager:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-scheduler:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.15.3 </span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-scheduler:v1.15.3 k8s.gcr.io/kube-scheduler:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;kube-proxy:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3 k8s.gcr.io/kube-proxy:v1.15.3</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;k8s-dns-kube-dns:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/coredns:1.3.1</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;etcd:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/etcd:3.3.10</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/etcd:3.3.10 k8s.gcr.io/etcd:3.3.10</span><br><span class="line"></span><br><span class="line">echo &quot;==&gt;pause:&quot;</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br><span class="line"></span><br><span class="line">echo finished.</span><br><span class="line">echo &quot;you are so lucy&quot;</span><br></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --config kubeadm.yml --pod-network-cidr 10.244.0.0/16 -ignore-preflight-errors all</span><br></pre></td></tr></table></figure><p>执行成功后可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.136.130:6443 --token 32ozhx.8xneb9rzjukjc3au \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:00c3d4e272d3736c0edcfcdda38f255c9fb75118a7d640a3e98542829f4bb3ec</span><br></pre></td></tr></table></figure><ul><li>切换到普通用户执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><ul><li>查看节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME               STATUS   ROLES    AGE    VERSION</span><br><span class="line">master.huany.com   NotReady    master   2d3h   v1.15.3</span><br></pre></td></tr></table></figure><p>如果重启或者kubeadm reset 将清理掉cni配置，需要重新配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/cni/net.d/ -p</span><br><span class="line">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;isGateway&quot;: true,</span><br><span class="line">    &quot;ipMasq&quot;: true,</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">            &#123;&quot;dst&quot;: &quot;0.0.0.0/0&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;loopback&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>查看节点情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME               STATUS   ROLES    AGE    VERSION</span><br><span class="line">master.huany.com   Ready    master   2d3h   v1.15.3</span><br></pre></td></tr></table></figure><h2 id="在node节点上安装"><a href="#在node节点上安装" class="headerlink" title="在node节点上安装"></a>在node节点上安装</h2><p>同上，修改Linux内核，安装docker，安装kubeadm </p><ul><li><p>加入到集群中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.136.130:6443 --token 32ozhx.8xneb9rzjukjc3au \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:00c3d4e272d3736c0edcfcdda38f255c9fb75118a7d640a3e98542829f4bb3ec</span><br></pre></td></tr></table></figure></li><li><p>配置cni网络</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/cni/net.d/ -p</span><br><span class="line">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;isGateway&quot;: true,</span><br><span class="line">    &quot;ipMasq&quot;: true,</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">        &quot;routes&quot;: [</span><br><span class="line">            &#123;&quot;dst&quot;: &quot;0.0.0.0/0&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;loopback&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="在master上查看节点情况："><a href="#在master上查看节点情况：" class="headerlink" title="在master上查看节点情况："></a>在master上查看节点情况：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[meichaofan@master keights]$ kubectl get nodes</span><br><span class="line">NAME               STATUS   ROLES    AGE    VERSION</span><br><span class="line">master.huany.com   Ready    master   2d3h   v1.15.3</span><br><span class="line">node1.huany.com    Ready    &lt;none&gt;   2d3h   v1.15.3</span><br><span class="line">node2.huany.com    Ready    &lt;none&gt;   2d3h   v1.15.3</span><br></pre></td></tr></table></figure><ul><li>在master附属flannel网络</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li>查看运行的服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[meichaofan@master keights]$ kubectl get pods -n kube-system</span><br><span class="line">NAME                                       READY   STATUS             RESTARTS   AGE</span><br><span class="line">coredns-5c98db65d4-mc25l                   1/1     Running            17         7h18m</span><br><span class="line">coredns-5c98db65d4-p7mtp                   1/1     Running            16         7h19m</span><br><span class="line">etcd-master.huany.com                      1/1     Running            2          2d3h</span><br><span class="line">kube-apiserver-master.huany.com            1/1     Running            2          2d3h</span><br><span class="line">kube-controller-manager-master.huany.com   0/1     CrashLoopBackOff   22         2d3h</span><br><span class="line">kube-flannel-ds-8l7jc                      1/1     Running            0          2d3h</span><br><span class="line">kube-flannel-ds-l952q                      1/1     Running            2          2d3h</span><br><span class="line">kube-flannel-ds-qmfgk                      1/1     Running            0          2d3h</span><br><span class="line">kube-proxy-b2r8g                           1/1     Running            3          2d3h</span><br><span class="line">kube-proxy-ccdr4                           1/1     Running            0          2d3h</span><br><span class="line">kube-proxy-klp8f                           1/1     Running            0          2d3h</span><br><span class="line">kube-scheduler-master.huany.com            1/1     Running            17         2d3</span><br></pre></td></tr></table></figure><h3 id="在node上拉取pause、kubeproxy容器，并转换tag"><a href="#在node上拉取pause、kubeproxy容器，并转换tag" class="headerlink" title="在node上拉取pause、kubeproxy容器，并转换tag"></a>在node上拉取pause、kubeproxy容器，并转换tag</h3><ul><li>node1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pause</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.1</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br><span class="line"></span><br><span class="line"># kube-proxy</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3</span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/kube-proxy:v1.15.3 k8s.gcr.io/kube-proxy:v1.15.3</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;h3 id=&quot;主机配置和角色分配&quot;&gt;&lt;a href=&quot;#主机配置和角色分配&quot; class=&quot;headerlink&quot; title=&quot;主机配置和角色
      
    
    </summary>
    
    
      <category term="docker" scheme="https://meichaofan.github.io/tags/docker/"/>
    
      <category term="k8s" scheme="https://meichaofan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>linux下json解析神器 - jq</title>
    <link href="https://meichaofan.github.io/2019/08/02/linux-json-format/"/>
    <id>https://meichaofan.github.io/2019/08/02/linux-json-format/</id>
    <published>2019-08-02T15:42:12.000Z</published>
    <updated>2019-08-02T15:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">jq - commandline JSON processor [version 1.6]</span><br><span class="line"></span><br><span class="line">Usage:  jq [options] &lt;jq filter&gt; [file...]</span><br><span class="line">    jq [options] --args &lt;jq filter&gt; [strings...]</span><br><span class="line">    jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]</span><br><span class="line"></span><br><span class="line">jq is a tool for processing JSON inputs, applying the given filter to</span><br><span class="line">its JSON text inputs and producing the filter&apos;s results as JSON on</span><br><span class="line">standard output.</span><br><span class="line"></span><br><span class="line">The simplest filter is ., which copies jq&apos;s input to its output</span><br><span class="line">unmodified (except for formatting, but note that IEEE754 is used</span><br><span class="line">for number representation internally, with all that that implies).</span><br><span class="line"></span><br><span class="line">For more advanced filters see the jq(1) manpage (&quot;man jq&quot;)</span><br><span class="line">and/or https://stedolan.github.io/jq</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">    $ echo &apos;&#123;&quot;foo&quot;: 0&#125;&apos; | jq .</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;foo&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">For a listing of options, use jq --help.</span><br></pre></td></tr></table></figure><h3 id="jf"><a href="#jf" class="headerlink" title="jf"></a>jf</h3><p>改写成 shell 脚本执行模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">argsCount=$#</span><br><span class="line">if [ $argsCount -ne 1 ];then</span><br><span class="line">    echo &quot;Usage : jf json_str&quot;</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">jsonStr=$1</span><br><span class="line"></span><br><span class="line">echo $&#123;jsonStr&#125; | /usr/local/bin/jq .</span><br></pre></td></tr></table></figure></p><p>执行方法是：<code>jf &#39;{&quot;name&quot;:&quot;meichaofan&quot;}&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jq&quot;&gt;&lt;a href=&quot;#jq&quot; class=&quot;headerlink&quot; title=&quot;jq&quot;&gt;&lt;/a&gt;jq&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设定printf在终端输出字体的颜色</title>
    <link href="https://meichaofan.github.io/2019/08/01/printf-console-color/"/>
    <id>https://meichaofan.github.io/2019/08/01/printf-console-color/</id>
    <published>2019-08-01T14:27:36.000Z</published>
    <updated>2019-08-01T14:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>终端字符的颜色是用转义序列进行控制，是文本模式下的系统显示功能，和具体的语言无关。转义序列是以 ESC 开头,可以用 \033 完成相同的工作（ESC 的 ASCII 码用十进制表示就是 27， = 用八进制表示的 33）。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\033[显示方式；前景色；背景色m</span><br></pre></td></tr></table></figure><p>1) 显示方式：0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、5（闪烁）、25（非闪烁）、7（反显）、27（非反显）</p><p>2) 前景色：30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋红）、36（青色）、37（白色）</p><p>3) 背景色：40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋红）、46（青色）、47（白色）</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1）默认颜色：\033[0m，也是关闭所有属性<br>　<br>2）绿色：\033[1;32;40m<br>　<br>3）红色：\033[1;31;40m</p><p>4）printf( “\033[1;31;40m 输出红色字符 \033[0m” )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终端字符的颜色是用转义序列进行控制，是文本模式下的系统显示功能，和具体的语言无关。转义序列是以 ESC 开头,可以用 \033 完成相同的工作（ESC 的 ASCII 码用十进制表示就是 27， = 用八进制表示的 33）。&lt;/p&gt;
&lt;h3 id=&quot;格式&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="printf" scheme="https://meichaofan.github.io/tags/printf/"/>
    
  </entry>
  
  <entry>
    <title>clion建立多级工作目录</title>
    <link href="https://meichaofan.github.io/2019/07/31/clion-create-multi-project/"/>
    <id>https://meichaofan.github.io/2019/07/31/clion-create-multi-project/</id>
    <published>2019-07-31T15:42:39.000Z</published>
    <updated>2019-07-31T15:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前对Clion不熟悉，每次写项目都在主目录下，导致一个主目录只能写一个main函数，下面学习如何在CLion建立多级工程目录</p><hr><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>在主工作目录下，有一个CMakeList.txt文件，内容如下：</p><p><img src="http://image.huany.top/hexo/c/clion-main-cmakelist.png" alt></p><p>其中，<code>ADD_SUBDIRECTORY(function-point)</code>，这个是代表包含子目录的意思。</p><p>对于子目录<code>function-point</code>,也必须有一个CMakeList.txt文件，指定子目录中的可执行文件。</p><p><img src="http://image.huany.top/hexo/c/clion-sub-makelist.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前对Clion不熟悉，每次写项目都在主目录下，导致一个主目录只能写一个main函数，下面学习如何在CLion建立多级工程目录&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;操作：&quot;&gt;&lt;a href=&quot;#操作：&quot; class=&quot;headerlink&quot; title=&quot;操作：&quot;&gt;&lt;/a&gt;操
      
    
    </summary>
    
    
      <category term="c" scheme="https://meichaofan.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer - 3.1 - 数组中重复的数字</title>
    <link href="https://meichaofan.github.io/2019/07/26/sword-finger-offer-3-1/"/>
    <id>https://meichaofan.github.io/2019/07/26/sword-finger-offer-3-1/</id>
    <published>2019-07-26T15:10:17.000Z</published>
    <updated>2019-07-28T15:26:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个长度为n的数组里的所有数字都是0~n-1的范围内。数组中某些数字都是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3.</p><hr><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们注意到数组中的数字都在0~n-1的范围内。如果这个数组中没有重复的数字，那么当数字排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">n个数， 0~n-1之间，找出有重复的数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum1</span><span class="params">(numbers []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(numbers)</span><br><span class="line">    sort.Ints(numbers)</span><br><span class="line">    <span class="keyword">for</span> i &lt; length<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">//fmt.Printf("i: %d\n", i)</span></span><br><span class="line">        <span class="keyword">if</span> numbers[i] == numbers[i+<span class="number">1</span>] &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, numbers[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; length<span class="number">-1</span> &amp;&amp; numbers[i] == numbers[i+<span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.借助map(hashtable)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum2</span><span class="params">(numbers []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">    tmp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(numbers); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> count, ok := tmp[numbers[i]]; ok &#123;</span><br><span class="line">            tmp[numbers[i]] = count + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[numbers[i]] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">1</span> &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//巧妙3：数组内自排序，时间复杂度0(n) , 空间复杂度是 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum3</span><span class="params">(numbers []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(numbers)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">        <span class="keyword">for</span> i != numbers[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == numbers[numbers[i]] &amp;&amp; i != numbers[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i]</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[i], numbers[numbers[i]] = numbers[numbers[i]], numbers[i]</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ret1 := getDuplicateNum1(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ret1)</span><br><span class="line"></span><br><span class="line">    numbers = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ret2 := getDuplicateNum2(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ret2)</span><br><span class="line"></span><br><span class="line">    numbers = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ret3 := getDuplicateNum3(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ret3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个长度为n的数组里的所有数字都是0~n-1的范围内。数组中某些数字都是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go sync.Once</title>
    <link href="https://meichaofan.github.io/2019/07/26/go-sync-Once/"/>
    <id>https://meichaofan.github.io/2019/07/26/go-sync-Once/</id>
    <published>2019-07-25T16:30:27.000Z</published>
    <updated>2019-07-25T16:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>sync.Once</code> 可以实现单例模式，确保<code>sync.Once.Do(f func())</code>只会被执行一次，可以初始化某个实例单例。</p><p>sync.Once表示只执行一次的函数。要做到这一点，就需要以下两点要求：</p><ul><li>计数器，统计函数执行的次数</li><li>线程安全，保障在多G情况下，函数仍然只执行一次，比如锁。即对计时器的修改是线性安全的。</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>下面是sync.Once源码，源码不长，但值得分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package sync</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync/atomic&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Once is an object that will perform exactly one action.</span><br><span class="line">type Once struct &#123;</span><br><span class="line">    m    Mutex</span><br><span class="line">    done uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (o *Once) Do(f func()) &#123;</span><br><span class="line">    if atomic.LoadUint32(&amp;o.done) == 1 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // Slow-path.</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    defer o.m.Unlock()</span><br><span class="line">    if o.done == 0 &#123;</span><br><span class="line">        defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Once结构体证明了之前的猜想，果然有两个变量。</strong></p><p>Do方法相对简单，但是也是也可以学习的地方。</p><ul><li>1.原子操作判断o.done是否为1，若为1，表示f已经执行过，直接返回</li><li>2.加锁，保证互斥访问</li><li>3.若o.done为0，表示f未执行，执行f函数，对o.done原子赋值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;sync.Once&lt;/code&gt; 可以实现单例模式，确保&lt;code&gt;sync.Once.Do(f func())&lt;/code&gt;只会被执行一次，可以初始化某个实例单例。&lt;/p&gt;
&lt;p&gt;sync.Once表示只执行一次的函数。要做到这一点，就需要以下两点要求：&lt;/p
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>c 函数指针</title>
    <link href="https://meichaofan.github.io/2019/07/26/c-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://meichaofan.github.io/2019/07/26/c-函数指针/</id>
    <published>2019-07-25T16:10:42.000Z</published>
    <updated>2019-07-25T16:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先，先不要把指向函数的指针认为太难了，它和普通的指针区别不是很大，只是定义形式上有所区别。</p><p>比如，对于一个指向整形的普通指针，定义形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br></pre></td></tr></table></figure><p>在定义中，指针变量的名称是p，符号<code>*</code>说明了p是一个指针，int说明这个指针指向的是整形变量。</p><p>那么，如果我们定义一个指向函数的指针，假设变量名称为p，比如它指向这样的一个函数，这个函数需要两个整数参数，其返回值也是整形参数，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)(int int);</span><br></pre></td></tr></table></figure><p>对于这个定义分解一下，其中，p是变量的名称，符号<code>*</code>说明了p是一个指针，由于这个指针指向的是一个函数，所以在定义中必须体现函数的输入输出参数信息，那么最前面的int指的就是函数的返回值为int类型，后面的(int,int)则定义了该函数需要两个整形的输入参数。另外，必须将<code>*</code>与<code>p</code>用括号写成<code>(*p)</code>的形式，否则，由于括号的优先级大于<code>*</code>的优先级，去掉括号的话就成为另外一种意思了。</p><p>这样对比着理解，指向函数的指针，似乎与普通指针区别也不是太大。</p><h3 id="指向函数指针例子"><a href="#指向函数指针例子" class="headerlink" title="指向函数指针例子"></a>指向函数指针例子</h3><p>下面通过一个例子演示指向函数的指针的使用方法。</p><p>该例子的功能是，对于一个输入的一维数组，定义三个函数findMax、findMin和getAvg，分别实现查找该数组的最大值、最小值及计算该数组的平均值，这三个函数的输入输出参数完全相同。定义一个fun函数，在该函数的参数中，需要一个指针变量作参数，这个指针能够指向上面的三个函数。在主程序中，调用fun函数，根据传入不同的p值实现对输入的一维数组作不同的处理功能。</p><p>下面先看下几部分的实现代码吧。</p><h4 id="findMax、findMin和getAvg代码实现"><a href="#findMax、findMin和getAvg代码实现" class="headerlink" title="findMax、findMin和getAvg代码实现"></a>findMax、findMin和getAvg代码实现</h4><p>这三个函数对一维数组x，分别作求最大值、最小值及平均值的处理，并将其结果返回。C语言代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">double findMax(double *x, int n) &#123;</span><br><span class="line">    double max = x[0];</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (max &lt; x[i]) max = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double findMin(double *x, int n) &#123;</span><br><span class="line">    double min = x[0];</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (min &gt; x[i]) min = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getAvg(double *x, int n) &#123;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个函数比较简单，函数原型完全一样，输入参数为一个指向double的指针x及x的元素个数n，输出参数也就是返回值是一个double型的数值。</p><h4 id="fun函数的代码实现"><a href="#fun函数的代码实现" class="headerlink" title="fun函数的代码实现"></a>fun函数的代码实现</h4><p>该函数输入参数为3个，前两个为指向double的指针x及x的元素个数n，第三个为一个指向函数的指针类型，这个指针能够指向上面的三个函数。C语言代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double fun(double *x, int n, double (*p)(double *, int)) &#123;</span><br><span class="line">    return p(x, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，在主程序中可以调用该函数，只要输入不同的p值，就可以对输入的一维数组作不同的处理运算。</p><h4 id="主程序测试代码"><a href="#主程序测试代码" class="headerlink" title="主程序测试代码"></a>主程序测试代码</h4><p>主程序测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void mian(void)</span><br><span class="line">&#123;</span><br><span class="line">    double x[5] = &#123;1.1, 3.4, 4.5, 1.3, 5.6&#125;;</span><br><span class="line">    fun(x, 5, findMax);</span><br><span class="line">    fun(x, 5, findMin);</span><br><span class="line">    fun(x, 5, getAvg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笨方法学C例子"><a href="#笨方法学C例子" class="headerlink" title="笨方法学C例子"></a>笨方法学C例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void die(const char *message) &#123;</span><br><span class="line">    if (errno) &#123;</span><br><span class="line">        perror(message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Error : %s\n&quot;, message);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef int (*compare_cb)(int a, int b);</span><br><span class="line"></span><br><span class="line">int *bubble_sort(int *numbers, int count, compare_cb cmp) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    int *target = malloc(count * sizeof(int));</span><br><span class="line"></span><br><span class="line">    if (!target) die(&quot;Memory error.&quot;);</span><br><span class="line"></span><br><span class="line">    memcpy(target, numbers, count * sizeof(int));</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        for (j = 0; j &lt; count - 1; ++j) &#123;</span><br><span class="line">            if (cmp(target[j], target[j + 1]) &gt; 0) &#123;</span><br><span class="line">                temp = target[j + 1];</span><br><span class="line">                target[j + 1] = target[j];</span><br><span class="line">                target[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sorted_order(int a, int b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int reverse_order(int a, int b) &#123;</span><br><span class="line">    return b - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int strange_order(int a, int b) &#123;</span><br><span class="line">    if (a == 0 || b == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_sorting(int *numbers, int count, compare_cb cmp) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int *sorted = bubble_sort(numbers, count, cmp);</span><br><span class="line">    if (!sorted) die(&quot;Failed to sort as request.&quot;);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, sorted[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    free(sorted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if (argc &lt; 2) die(&quot;Usage: ext 4 3 1 5 6&quot;);</span><br><span class="line">    int count = argc - 1;</span><br><span class="line">    int i = 0;</span><br><span class="line">    char **inputs = argv + 1;</span><br><span class="line"></span><br><span class="line">    int *numbers = malloc(count * sizeof(int));</span><br><span class="line">    if (!numbers) die(&quot;Memory error.&quot;);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        numbers[i] = atoi(inputs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test_sorting(numbers, count, sorted_order);</span><br><span class="line">    test_sorting(numbers, count, reverse_order);</span><br><span class="line">    test_sorting(numbers, count, strange_order);</span><br><span class="line"></span><br><span class="line">    free(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;首先，先不要把指向函数的指针认为太难了，它和普通的指针区别不是很大，只是定义形式上有所区别。&lt;/p&gt;
&lt;p&gt;比如，对于一个指
      
    
    </summary>
    
    
      <category term="c" scheme="https://meichaofan.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>go waitgroup</title>
    <link href="https://meichaofan.github.io/2019/07/22/go-waitgroup/"/>
    <id>https://meichaofan.github.io/2019/07/22/go-waitgroup/</id>
    <published>2019-07-22T15:22:39.000Z</published>
    <updated>2019-07-22T15:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>WaitGroup是Go应用开发过程中经常使用的并发控制技术。</p><p>WaitGroup，可理解为Wait-Groutine-Group，即等待一组goroutine结束。比如某个goroutine需要等待其他几个goroutine全部完成，那么使用WaitGroup可以轻松实现。</p><p>下面程序展示了一个goroutine等待另外两个goroutine结束的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(2) //设置计数器，数值即为goroutine的个数</span><br><span class="line">    go func() &#123;</span><br><span class="line">        //Do some work</span><br><span class="line">        time.Sleep(1*time.Second)</span><br><span class="line"></span><br><span class="line">        fmt.Println(&quot;Goroutine 1 finished!&quot;)</span><br><span class="line">        wg.Done() //goroutine执行结束后将计数器减1</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        //Do some work</span><br><span class="line">        time.Sleep(2*time.Second)</span><br><span class="line"></span><br><span class="line">        fmt.Println(&quot;Goroutine 2 finished!&quot;)</span><br><span class="line">        wg.Done() //goroutine执行结束后将计数器减1</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait() //主goroutine阻塞等待计数器变为0</span><br><span class="line">    fmt.Printf(&quot;All Goroutine finished!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说，上面程序中wg内部维护了一个计数器：</p><ul><li>1.启动goroutine前将计数器通过Add(2)将计数器设置为待启动的goroutine个数。</li><li>2.启动goroutine后，使用Wait()方法阻塞自己，等待计数器变为0。 </li><li>3.每个goroutine执行结束通过Done()方法将计数器减1。</li><li>4.计数器变为0后，阻塞的goroutine被唤醒。</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是Unix系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。</p><p>可简单理解为信号量为一个数值：</p><ul><li>当信号量&gt;0时，表示资源可用，获取信号量时系统自动将信号量减1；</li><li>当信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒；</li></ul><p>WaitGroup视线中也使用了信号量</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>源码包中<code>src/sync/waitgroup.go:WaitGroup</code>定义了其数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type WaitGroup struct &#123;</span><br><span class="line">    state1 [3]uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state1是个长度为3的数组，其中包含了state和一个信号量，而state实际上是两个计数器：</p><ul><li>counter：当前还未执行结束的goroutine计数器</li><li>waiter count：等待goroutine-group结束的goroutine数量，即有多少个等候者</li><li>semaphore：信号量</li></ul><p>考虑到字节是否对齐，三者出现的位置不同，为简单起见，依照字节已对齐情况下，三者在内存中的位置如下所示：</p><p><img src="http://image.huany.top/hexo/go/wg-01-layout.png" alt></p><p>WaitGroup对外提供了3个接口：</p><ul><li>Add(delta int): 将delta值加到counter中</li><li>Wait()： waiter递增1，并阻塞等待信号量semaphore</li><li>Done()： counter递减1，当counter=0时按照waiter数值释放相应次数信号量</li></ul><p>下面分别介绍这三个函数的实现细节。</p><h4 id="Add-delta-int"><a href="#Add-delta-int" class="headerlink" title="Add(delta int)"></a>Add(delta int)</h4><p>Add()做了两件事，一是把delta值累加到counter中，因为delta可以为负值，也就是说counter有可能变成0或负值，所以第二件事就是当counter值变为0时，跟据waiter数值释放等量的信号量，把等待的goroutine全部唤醒，如果counter变为负值，则panic.</p><p>Add()伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Add(delta int) &#123;</span><br><span class="line">    statep, semap := wg.state() //获取state和semaphore地址指针</span><br><span class="line"></span><br><span class="line">    state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32) //把delta左移32位累加到state，即累加到counter中</span><br><span class="line">    v := int32(state &gt;&gt; 32) //获取counter值</span><br><span class="line">    w := uint32(state)      //获取waiter值</span><br><span class="line"></span><br><span class="line">    if v &lt; 0 &#123;              //经过累加后counter值变为负值，panic</span><br><span class="line">        panic(&quot;sync: negative WaitGroup counter&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //经过累加后，此时，counter &gt;= 0</span><br><span class="line">    //如果counter为正，说明不需要释放信号量，直接退出</span><br><span class="line">    //如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出</span><br><span class="line">    if v &gt; 0 || w == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），</span><br><span class="line">    //先把counter置为0，再释放waiter个数的信号量</span><br><span class="line">    *statep = 0</span><br><span class="line">    for ; w != 0; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, false) //释放信号量，执行一次释放一个，唤醒一个等待者</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h4><p>Wait()方法也做了两件事，一是累加waiter, 二是阻塞等待信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Wait() &#123;</span><br><span class="line">    statep, semap := wg.state() //获取state和semaphore地址指针</span><br><span class="line">    for &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep) //获取state值</span><br><span class="line">        v := int32(state &gt;&gt; 32)            //获取counter值</span><br><span class="line">        w := uint32(state)                 //获取waiter值</span><br><span class="line">        if v == 0 &#123;                        //如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试</span><br><span class="line">        if atomic.CompareAndSwapUint64(statep, state, state+1) &#123;</span><br><span class="line">            runtime_Semacquire(semap) //累加成功后，等待信号量唤醒自己</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了CAS算法保证有多个goroutine同时执行Wait()时也能正确累加waiter。</p><h4 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h4><p>Done()只做一件事，即把counter减1，我们知道Add()可以接受负值，所以Done实际上只是调用了Add(-1)。</p><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (wg *WaitGroup) Done() &#123;</span><br><span class="line">    wg.Add(-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done()的执行逻辑就转到了Add()，实际上也正是最后一个完成的goroutine把等待者唤醒的。</p><h3 id="编程Tips"><a href="#编程Tips" class="headerlink" title="编程Tips"></a>编程Tips</h3><ul><li>Add() 操作必须早于Wait，否则会panic</li><li>Add()设置的值必须与实际等待的goroutine个数一致，否则会panic</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;WaitGroup是Go应用开发过程中经常使用的并发控制技术。&lt;/p&gt;
&lt;p&gt;WaitGroup，可理解为Wait-Groutine-Gro
      
    
    </summary>
    
    
      <category term="Go" scheme="https://meichaofan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>c语言 - 字符数组和字符串</title>
    <link href="https://meichaofan.github.io/2019/07/20/c-char-array/"/>
    <id>https://meichaofan.github.io/2019/07/20/c-char-array/</id>
    <published>2019-07-19T16:56:02.000Z</published>
    <updated>2019-07-19T16:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符数组定义"><a href="#字符数组定义" class="headerlink" title="字符数组定义"></a>字符数组定义</h4><p>用来存放字符的数组成为字符数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[20] = &#123;&apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;r&apos;, &apos;a&apos;,&apos;m&apos;&#125;; //给部分数组元素赋值</span><br><span class="line">char b[] = &#123;&apos;c&apos;, &apos; &apos;, &apos;p&apos;, &apos;r&apos;, &apos;o&apos;, &apos;g&apos;, &apos;r&apos;, &apos;a&apos;,&apos;m&apos;&#125;; //对全体元素赋值可以省去长度</span><br></pre></td></tr></table></figure><p>字符数组实际上是一些列字符的集合，也就是字符串（string）。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。</p><h4 id="字符数组和字符串赋值"><a href="#字符数组和字符串赋值" class="headerlink" title="字符数组和字符串赋值"></a>字符数组和字符串赋值</h4><p>C语言规定，可以将字符串直接赋值给字符数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[30] = &#123;&quot;c.biancheng.net&quot;&#125;;</span><br><span class="line">char str[30] = &quot;c.biancheng.net&quot;; //这种形式更加简洁，实际开发中常用</span><br></pre></td></tr></table></figure><p>数组第0个元素为 ‘c’，第1个元素为 ‘.’，第2个元素为 ‘b’，后面的元素以此类推。也可以不指定数组长度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &#123;&quot;c.biancheng.net&quot;&#125;;</span><br><span class="line">char str[] = &quot;c.biancheng.net&quot;; //这种形式更加简洁，实际开发中常用</span><br></pre></td></tr></table></figure><p>在C语言中，字符串总是以<code>&#39;\0&#39;</code>作为串的结束符。上面的两个字符串，编译器已经在末尾自动添加了<code>&#39;\0&#39;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\0&apos;是ASCII码表中的第0个字符，用NUL表示，称为空字符。该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，它在C语言中仅作为字符串的结束标志。</span><br></pre></td></tr></table></figure><p><code>puts</code>和<code>printf</code>函数在输出字符串时会逐个扫描字符，直到遇见<code>\0</code>才结束输出。请看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    char str1[30] = &quot;http://c.biancheng.net&quot;;</span><br><span class="line">    char str2[] = &quot;C Language&quot;;</span><br><span class="line">    char str3[30] = &quot;You are a good\0 boy!&quot;;</span><br><span class="line">    printf(&quot;str1: %s\n&quot;, str1);</span><br><span class="line">    printf(&quot;str2: %s\n&quot;, str2);</span><br><span class="line">    printf(&quot;str3: %s\n&quot;, str3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1: http://c.biancheng.net</span><br><span class="line">str2: C Language</span><br><span class="line">str3: You are a good</span><br></pre></td></tr></table></figure><p>str1 和 str2 很好理解，编译器会在字符串最后自动添加 ‘\0’，并且数组足够大，所以会输出整个字符串。对于 str3，由于字符串中间存在 ‘\0’，printf() 扫描到这里就认为字符串结束了，所以不会输出后面的内容。</p><h4 id="字符数组和字符串区别"><a href="#字符数组和字符串区别" class="headerlink" title="字符数组和字符串区别"></a>字符数组和字符串区别</h4><p>需要注意的是，用字符串给字符数组赋值时由于要添加结束符 ‘\0’，数组的长度要比字符串的长度（字符串长度不包括 ‘\0’）大1。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &quot;C program&quot;;</span><br></pre></td></tr></table></figure><p>该数组在内存中实际存放情况为：</p><p><img src="http://image.huany.top/hexo/c/sfdsgfsge.png" alt></p><p><strong>字符串长度为 9，数组长度为 10。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;字符数组定义&quot;&gt;&lt;a href=&quot;#字符数组定义&quot; class=&quot;headerlink&quot; title=&quot;字符数组定义&quot;&gt;&lt;/a&gt;字符数组定义&lt;/h4&gt;&lt;p&gt;用来存放字符的数组成为字符数组，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
    
      <category term="C" scheme="https://meichaofan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>php array</title>
    <link href="https://meichaofan.github.io/2019/07/13/php-array/"/>
    <id>https://meichaofan.github.io/2019/07/13/php-array/</id>
    <published>2019-07-12T17:44:35.000Z</published>
    <updated>2019-07-12T17:45:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>PHP数组的低层实现为散列表（HashTable,也称作：哈希表）。除了我们熟悉的PHP用户空间的Array类型之外，内核中也随处用到了散列表，比如函数，类，常量，已include文件的索引表，全局符号表等都用HashTable存储。</p><p>散列表是根据关键码值(Key value)而直接进行访问的数据结构，它的key - value之间存在一个映射函数，可以根据key通过映射函数直接索引到对应的value值，它不以关键字的比较为基本操作，<strong>采用直接寻址技术</strong>（就是说，它是直接通过key映射到内存地址上去的），从而加快查找速度，在理想情况下，无须任何比较就可以找到待查关键字，查找的期望时间为O(1)。</p><h3 id="1-数组结构"><a href="#1-数组结构" class="headerlink" title="1.数组结构"></a>1.数组结构</h3><p>存放记录的数组称作散列表，这个数组用来存储value。而value具体在数组中的存储位置，由映射函数根据key计算确定，映射函数可以采用取模的方式，key可以通过一些譬如“times 33”的算法得到一个整形值，然后与数组总大小取模得到在散列表中的存储位置。这是一个普通散列表的实现，PHP散列表的实现整体也是这个思路。<br>下面是PHP中HashTable的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bucket：散列表中存储的元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">    zval              val; <span class="comment">//存储的具体value，这里嵌入了一个zval，而不是一个指针</span></span><br><span class="line">    zend_ulong        h;   <span class="comment">//key根据times 33计算得到的哈希值，或者是数值索引编号</span></span><br><span class="line">    zend_string      *key; <span class="comment">//存储元素的key</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashTable结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                    zend_uchar    flags,</span><br><span class="line">                    zend_uchar    nApplyCount,</span><br><span class="line">                    zend_uchar    nIteratorsCount,</span><br><span class="line">                    zend_uchar    reserve)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableMask; <span class="comment">//哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize)</span></span><br><span class="line">    Bucket           *arData;     <span class="comment">//存储元素数组，指向第一个Bucket</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumUsed;   <span class="comment">//已用Bucket数</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumOfElements; <span class="comment">//哈希表有效元素数</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableSize;     <span class="comment">//哈希表总大小，为2的n次方</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement; <span class="comment">//下一个可用的数值索引,如:arr[] = 1;arr["a"] = 2;arr[] = 3;  则nNextFreeElement = 2;</span></span><br><span class="line">    <span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HashTable有两个非常相近的值：nNumUsed、nNumOfElements，nNumOfElements表示哈希表已有的元素数，nNumUsed表示已用的桶数？<strong>这两个值有什么不一样吗？</strong><br>实际上，它们有不同的含义，当将一个元素从哈希表删除时，并不会将对应的Bucket移除，而是将Bucket存储的zval修改为IS_UNDEF ， 只有扩容时发现nNumOfElements与nNumUsed相差达到一定数量（这个数量是 ht-&gt;nNumUsed - ht-&gt;nNumOfElements &gt; (ht-&gt;nNumOfElements &gt;&gt; 5)）时才会将已删除的元素全部移除，重新构建哈希表。所以nNumUsed &gt;= nNumOfElements</p><p>HashTable中另外一个非常重要的值arData，这个值指向存储元素数组的第一个Bucket,插入元素时按照顺序 <strong>依次插</strong>入 数组。 PHP数组的有序性正是通过arData保证的，这是第一个与普通散列表实现不同的地方。</p><p>既然arData并不是按key映射的散列表，那么映射函数是如何将key与arData中的value建立映射关系的呢？</p><p>实际上这个散列表也在arData中，比较特别的是散列表在ht-&gt;arData内存之前，分配内存时这个散列表与Bucket数组一起分配，arData向后移动到了Bucket数组的起始位置，并不是申请内存的起始位置，这样散列表可以由arData指针向前移动访问到，即arData[-1]、arData[-2]、arData[-3]……散列表的结构是uint32_t，它保存的是value在Bucket数组中的位置。</p><p>所以，整体来看HashTable主要依赖arData实现元素的存储、索引。插入一个元素时先将元素按先后顺序插入Bucket数组，位置是idx，再根据key的哈希值映射到散列表中的某个位置nIndex，将idx存入这个位置；查找时先在散列表中映射到nIndex，得到value在Bucket数组的位置idx，再从Bucket数组中取出元素。（&hearts;）</p><p>比如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$arr[<span class="string">"a"</span>] = <span class="number">1</span>;</span><br><span class="line">$arr[<span class="string">"b"</span>] = <span class="number">2</span>;</span><br><span class="line">$arr[<span class="string">"c"</span>] = <span class="number">3</span>;</span><br><span class="line">$arr[<span class="string">"d"</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>($arr[<span class="string">"c"</span>]);</span><br></pre></td></tr></table></figure></p><p>对应的HashTable如下图所示。<br><img src="http://image.huany.top/hexo/php/php-array-hashtable.png" alt></p><h3 id="2-映射函数"><a href="#2-映射函数" class="headerlink" title="2.映射函数"></a>2.映射函数</h3><p>映射函数是散列表的关键部分，它将key与value建立映射关系，一般映射函数可以将key的hash值与Bucket数组取模得到，即 key-&gt;h % ht-&gt;nTableSize,但是PHP并不是这么做的：</p><blockquote><p>nIndex = key-&gt;h | ht-&gt;nTableMask;</p></blockquote><p>显然位运算比取模运算更快。<br>nTableMask为nTableSize的负数，即: nTableMask = -nTableSize。因为nTableSize等于2^n，所以ntableMask二进制右侧全部为0，也就保证了nIndex落在数组索引的范围之内(|nIndex|&lt;=nTableSize).</p><pre><code>11111111 11111111 11111111 11111000   -811111111 11111111 11111111 11110000   -1611111111 11111111 11111111 11100000   -3211111111 11111111 11111111 11000000   -6411111111 11111111 11111111 10000000   -128</code></pre><h3 id="3-哈希碰撞"><a href="#3-哈希碰撞" class="headerlink" title="3.哈希碰撞"></a>3.哈希碰撞</h3><p>哈希碰撞是指不同的key可能计算得到相同的哈希值(数值索引的哈希值直接就是数值本身)，但是这些值又需要插入同一个散列表。一般解决方法是将Bucket串成链表，查找时遍历链表比较key。</p><p>PHP的实现也是如此，只是将链表的指针指向转化为了数值指向，即：指向冲突元素的指针并没有直接存在Bucket中，而是保存到了value的zval中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>     var_flags;</span><br><span class="line">        <span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain（哈希冲突链） */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当出现冲突时将原value的位置保存到新value的zval.u2.next中，然后将新插入的value的位置更新到散列表，也就是后面冲突的value始终插入header。所以查找过程类似：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zend_ulong h = zend_string_hash_val(key);</span><br><span class="line"><span class="keyword">uint32_t</span> idx = ht-&gt;arHash[h &amp; ht-&gt;nTableMask];</span><br><span class="line"><span class="keyword">while</span> (idx != INVALID_IDX) &#123;</span><br><span class="line">    Bucket *b = &amp;ht-&gt;arData[idx];</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;h == h &amp;&amp; zend_string_equals(b-&gt;key, key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    idx = Z_NEXT(b-&gt;val); <span class="comment">//移到下一个冲突的value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><h3 id="4-插入、查找、删除"><a href="#4-插入、查找、删除" class="headerlink" title="4.插入、查找、删除"></a>4.插入、查找、删除</h3><p>这几个基本操作比较简单，不再赘述，定位到元素所在Bucket位置后的操作类似单链表的插入、删除、查找。</p><h3 id="5-扩容"><a href="#5-扩容" class="headerlink" title="5.扩容"></a>5.扩容</h3><p>散列表可存储的value数是固定的，当空间不够用时就要进行扩容了。</p><p>PHP散列表的大小为2^n，插入时如果容量不够则首先检查已删除元素所占比例，如果达到阈值(ht-&gt;nNumUsed - ht-&gt;nNumOfElements &gt; (ht-&gt;nNumOfElements &gt;&gt; 5)，则将已删除元素移除，重建索引，如果未到阈值则进行扩容操作，扩大为当前大小的2倍，将当前Bucket数组复制到新的空间，然后重建索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zend_hash.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> ZEND_FASTCALL <span class="title">zend_hash_do_resize</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; <span class="number">5</span>)) &#123;</span><br><span class="line">        <span class="comment">//只有到一定阈值才进行rehash操作</span></span><br><span class="line">        zend_hash_rehash(ht); <span class="comment">//重建索引数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123;</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">void</span> *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class="line">        <span class="comment">//扩大为2倍，加法要比乘法快，小的优化点无处不在...</span></span><br><span class="line">        <span class="keyword">uint32_t</span> nSize = ht-&gt;nTableSize + ht-&gt;nTableSize;</span><br><span class="line">        Bucket *old_buckets = ht-&gt;arData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新分配arData空间，大小为:(sizeof(Bucket) + sizeof(uint32_t)) * nSize</span></span><br><span class="line">        new_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ...);</span><br><span class="line">        ht-&gt;nTableSize = nSize;</span><br><span class="line">        ht-&gt;nTableMask = -ht-&gt;nTableSize;</span><br><span class="line">        <span class="comment">//将arData指针偏移到Bucket数组起始位置</span></span><br><span class="line">        HT_SET_DATA_ADDR(ht, new_data);</span><br><span class="line">        <span class="comment">//将旧的Bucket数组拷到新空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(ht-&gt;arData, old_buckets, <span class="keyword">sizeof</span>(Bucket) * ht-&gt;nNumUsed);</span><br><span class="line">        <span class="comment">//释放旧空间</span></span><br><span class="line">        pefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重建索引数组：散列表</span></span><br><span class="line">        zend_hash_rehash(ht);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HT_SET_DATA_ADDR(ht, ptr) do &#123; \</span></span><br><span class="line">        (ht)-&gt;arData = (Bucket*)(((<span class="keyword">char</span>*)(ptr)) + HT_HASH_SIZE((ht)-&gt;nTableMask)); \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="6-重建散列表"><a href="#6-重建散列表" class="headerlink" title="6.重建散列表"></a>6.重建散列表</h3><p>当删除元素达到一定数量或扩容后都需要重建散列表，因为value在Bucket位置移动了或哈希数组nTableSize变化了导致key与value的映射关系改变，重建过程实际就是遍历Bucket数组中的value，然后重新计算映射值更新到散列表，除了更新散列表之外，这里还有一个重要的处理：移除已删除的value，开始的时候我们说过，删除value时只是将value的type设置为IS_UNDEF，并没有实际从Bucket数组中删除，如果这些value一直存在那么将浪费很多空间，所以这里会把它们移除，操作的方式也比较简单：将后面未删除的value依次前移，具体过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zend_hash.c</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> ZEND_FASTCALL <span class="title">zend_hash_rehash</span><span class="params">(HashTable *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bucket *p;</span><br><span class="line">    <span class="keyword">uint32_t</span> nIndex, i;</span><br><span class="line">    ...</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    p = ht-&gt;arData;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;nNumUsed == ht-&gt;nNumOfElements) &#123; <span class="comment">//没有已删除的直接遍历Bucket数组重新插入索引数组即可</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            nIndex = p-&gt;h | ht-&gt;nTableMask;</span><br><span class="line">            Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">            HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (++i &lt; ht-&gt;nNumUsed);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (UNEXPECTED(Z_TYPE(p-&gt;val) == IS_UNDEF)) &#123;</span><br><span class="line">                <span class="comment">//有已删除元素则将后面的value依次前移，压实Bucket数组</span></span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">while</span> (++i &lt; ht-&gt;nNumUsed) &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                    <span class="keyword">if</span> (EXPECTED(Z_TYPE_INFO(p-&gt;val) != IS_UNDEF)) &#123;</span><br><span class="line">                        ZVAL_COPY_VALUE(&amp;q-&gt;val, &amp;p-&gt;val);</span><br><span class="line">                        q-&gt;h = p-&gt;h;</span><br><span class="line">                        nIndex = q-&gt;h | ht-&gt;nTableMask;</span><br><span class="line">                        q-&gt;key = p-&gt;key;</span><br><span class="line">                        Z_NEXT(q-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">                        HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j);</span><br><span class="line">                        <span class="keyword">if</span> (UNEXPECTED(ht-&gt;nInternalPointer == i)) &#123;</span><br><span class="line">                            ht-&gt;nInternalPointer = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                ht-&gt;nNumUsed = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            nIndex = p-&gt;h | ht-&gt;nTableMask;</span><br><span class="line">            Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">            HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i &lt; ht-&gt;nNumUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;PHP数组的低层实现为散列表（HashTable,也称作：哈希表）。除了我们熟悉的PHP用户空间的Array类型之外，内核中也随处用到了散列
      
    
    </summary>
    
    
      <category term="php" scheme="https://meichaofan.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php7新特性</title>
    <link href="https://meichaofan.github.io/2019/07/10/php7-new-feature/"/>
    <id>https://meichaofan.github.io/2019/07/10/php7-new-feature/</id>
    <published>2019-07-10T00:36:05.000Z</published>
    <updated>2019-07-10T00:37:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP7新特性"><a href="#PHP7新特性" class="headerlink" title="PHP7新特性"></a>PHP7新特性</h3><h4 id="太空船操作符-lt-gt"><a href="#太空船操作符-lt-gt" class="headerlink" title="太空船操作符 &lt;=&gt;"></a>太空船操作符 &lt;=&gt;</h4><ul><li>太空船操作符用于比较两个表达式</li></ul><p>例如，当$a小于、等于或大于$b时，它分别返回-1、0或1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1&lt;=&gt;1; //0</span><br><span class="line">echo 1&lt;=&gt;2; //-1</span><br><span class="line">echo 2&lt;=&gt;1; //1</span><br></pre></td></tr></table></figure><h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><ul><li>declare(strict_types=1); // strict_types=1表示开启严格模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare(strict_types=1); //必须在脚本开始出声明</span><br><span class="line">function add(int ...$arg): int</span><br><span class="line">&#123;</span><br><span class="line">    return array_sum($arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="null合并操作符"><a href="#null合并操作符" class="headerlink" title="null合并操作符"></a>null合并操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$page = isset($_GET(&apos;page&apos;)) ? $_GET[&apos;page&apos;]:0；</span><br><span class="line">改成</span><br><span class="line">$page = $_GET(&apos;page&apos;) ?? 0;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，这里是<code>isset($val)</code></p><h4 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h4><ul><li>不可以修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;ANIMAL&apos;, [&apos;dog&apos;, &apos;cat&apos;, &apos;bird&apos;]);</span><br></pre></td></tr></table></figure><h4 id="NameSpace批量导入"><a href="#NameSpace批量导入" class="headerlink" title="NameSpace批量导入"></a>NameSpace批量导入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Space\&#123;ClassA,ClassB,ClassC as C&#125;;</span><br></pre></td></tr></table></figure><h4 id="try…catch-捕获-error"><a href="#try…catch-捕获-error" class="headerlink" title="try…catch 捕获 error"></a>try…catch 捕获 error</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    undefinedfunc();</span><br><span class="line">&#125; catch (Error $e) &#123;</span><br><span class="line">    var_dump($e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也可以</span><br><span class="line">set_exception_handler(</span><br><span class="line">    function ($e) &#123;</span><br><span class="line">        var_dump($e);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">undefinedfunc();</span><br></pre></td></tr></table></figure><p>PHP7返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Error#1 (8) &#123;</span><br><span class="line">  protected $message =&gt;</span><br><span class="line">  string(42) &quot;Call to undefined function undefinedfunc()&quot;</span><br><span class="line">  private $string =&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  protected $code =&gt;</span><br><span class="line">  int(0)</span><br><span class="line">  protected $file =&gt;</span><br><span class="line">  string(41) &quot;/home/meichaofan/PHP7/capter02/inedx2.php&quot;</span><br><span class="line">  protected $line =&gt;</span><br><span class="line">  int(4)</span><br><span class="line">  private $trace =&gt;</span><br><span class="line">  array(0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  private $previous =&gt;</span><br><span class="line">  NULL</span><br><span class="line">  public $xdebug_message =&gt;</span><br><span class="line">  string(199) &quot;</span><br><span class="line">Error: Call to undefined function undefinedfunc() in /home/meichaofan/PHP7/capter02/inedx2.php on line 4</span><br><span class="line"></span><br><span class="line">Call Stack:</span><br><span class="line">    0.0001     387432   1. &#123;main&#125;() /home/meichaofan/PHP7/capter02/inedx2.php:0</span><br><span class="line">&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Closure-call"><a href="#Closure-call" class="headerlink" title="Closure::call"></a>Closure::call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    private $num = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$f = function () &#123;</span><br><span class="line">    return $this-&gt;num + 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">echo $f-&gt;call(new Test());</span><br></pre></td></tr></table></figure><h4 id="intdiv-函数"><a href="#intdiv-函数" class="headerlink" title="intdiv 函数"></a>intdiv 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo intdiv(10,3); //整除 == 3</span><br></pre></td></tr></table></figure><h4 id="list-的方括号写法"><a href="#list-的方括号写法" class="headerlink" title="list 的方括号写法"></a>list 的方括号写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">之前</span><br><span class="line">$arr = [1,2,3];</span><br><span class="line">list($a,$b,$c) = $arr;</span><br><span class="line">现在可以这么写</span><br><span class="line">$arr = [1,2,3];</span><br><span class="line">[$a,$b,$c] = $arr;</span><br></pre></td></tr></table></figure><h4 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树(AST)"></a>抽象语法树(AST)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($a)[&apos;b&apos;] = 1;</span><br><span class="line">PHP5 会报错</span><br><span class="line">PHP7 因为AST，不会报错</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PHP7新特性&quot;&gt;&lt;a href=&quot;#PHP7新特性&quot; class=&quot;headerlink&quot; title=&quot;PHP7新特性&quot;&gt;&lt;/a&gt;PHP7新特性&lt;/h3&gt;&lt;h4 id=&quot;太空船操作符-lt-gt&quot;&gt;&lt;a href=&quot;#太空船操作符-lt-gt&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://meichaofan.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>go mutex</title>
    <link href="https://meichaofan.github.io/2019/07/07/go-mutex/"/>
    <id>https://meichaofan.github.io/2019/07/07/go-mutex/</id>
    <published>2019-07-07T04:19:57.000Z</published>
    <updated>2019-07-12T01:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。</p><p>Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几种状态。另外，我们也想探究一下Mutex重复解锁引起panic的原因。</p><h3 id="2-Mutex数据结构"><a href="#2-Mutex数据结构" class="headerlink" title="2.Mutex数据结构"></a>2.Mutex数据结构</h3><h4 id="2-1-Mutex结构体"><a href="#2-1-Mutex结构体" class="headerlink" title="2.1 Mutex结构体"></a>2.1 Mutex结构体</h4><p>源码包<code>src/sync/mutex.go:Mutex</code>定义了互斥锁的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Mutex struct&#123;</span><br><span class="line">    state int32</span><br><span class="line">    sema  uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Mutex.state 表示互斥锁的状态，比如是否被锁定等。</li><li>Mutex.sema 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。</li></ul><p>我们看到Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。</p><p>下图展示Mutex的内存布局：</p><p><img src="http://image.huany.top/hexo/go/mutex-01-structure.png" alt></p><ul><li>Locked：表示该Mutex是否已被锁定，0：没有锁定 1：已经锁定</li><li>Woken：表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中</li><li>Starving：表示该Mutex是否处于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程阻塞超过了1ms。</li><li>Waiter：表示阻塞等待锁的协程个数，协程解锁根据次值来判断是否需要释放信号量。</li></ul><p>协程之间抢锁实际上是抢给Locked赋值的权利，能给Locked域置1，就说明抢锁成功。抢不到的话就阻塞等待Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。</p><p>Woken和Starving主要用于控制协程间的抢锁过程。</p><h4 id="2-2-Mutex方法"><a href="#2-2-Mutex方法" class="headerlink" title="2.2 Mutex方法"></a>2.2 Mutex方法</h4><p>Mutex对外提供两个方法。</p><ul><li>Lock()：加锁方法</li><li>UnLock()：解锁方法</li></ul><p>下面我们分析一下锁和解锁的过程，加锁分成功和失败两种情况，成功的话直接获取锁，失败后当前协程被阻塞，同样，解锁时跟据是否有阻塞协程也有两种处理。</p><h3 id="3-加解锁过程"><a href="#3-加解锁过程" class="headerlink" title="3.加解锁过程"></a>3.加解锁过程</h3><h4 id="3-1-简单加锁"><a href="#3-1-简单加锁" class="headerlink" title="3.1 简单加锁"></a>3.1 简单加锁</h4><p>假设当前只有一个协程在加锁，没有其它协程干扰，那么过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-02-lock_without_block.png" alt></p><p>加锁过程会去判断Locked标志位是否为0，如果是0则把Locked位置1，代表加锁成功。从上图可见，加锁成功后，只有Locked位置1，其他状态位没有变化。</p><h4 id="3-2-加锁被阻塞"><a href="#3-2-加锁被阻塞" class="headerlink" title="3.2 加锁被阻塞"></a>3.2 加锁被阻塞</h4><p>假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-03-lock_with_block.png" alt></p><p>从上图可看到，当协程B对一个已被占用的锁再次加锁时，Waiter计数器增加了1，此时协程B将被阻塞，直到Locked值变为0后才会被唤醒。</p><h4 id="3-3-简单解锁"><a href="#3-3-简单解锁" class="headerlink" title="3.3 简单解锁"></a>3.3 简单解锁</h4><p>假定解锁时，没有其它协程阻塞，此时解锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-04-unlock_without_waiter.png" alt></p><p>由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把Locked位置为0即可，不需要释放信号量。</p><h4 id="3-4-解锁并唤醒协程"><a href="#3-4-解锁并唤醒协程" class="headerlink" title="3.4 解锁并唤醒协程"></a>3.4 解锁并唤醒协程</h4><p>假定解锁时，有1个或多个协程阻塞，此时解锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-05-unlock_with_waiter.png" alt></p><p>协程A解锁过程分为两个步骤，一个把Locked位置0，而是查看Waiter&gt;0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程B把Locked位置1，于是协程B获得锁。</p><h3 id="4-自旋过程"><a href="#4-自旋过程" class="headerlink" title="4. 自旋过程"></a>4. 自旋过程</h3><p>加锁时，如果当前Locked位为1，说明该锁当前由其它协程所持有，尝试加锁的协议并不是马上转入阻塞，而是会持续探测Locked位是否变为0，这个过程即为自旋过程。</p><p>自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次被阻塞。</p><p>自旋的好处是，当加锁失败时不必立即转入阻塞。有一定机会获取到锁，这样可以避免协程的切换。</p><h4 id="4-1-什么是自旋"><a href="#4-1-什么是自旋" class="headerlink" title="4.1 什么是自旋"></a>4.1 什么是自旋</h4><p>自旋对应于CPU的”PAUSE”指令，CPU对该指令什么都不做，相当于CPU空转，对程序而言相当于sleep了一小段时间，时间非常短，当前实现是30个时钟周期。</p><p>自旋过程中会持续探测Locked是否变为0，连续两次探测间隔就是执行这些PAUSE指令，它不同于sleep，不需要将协程转为睡眠状态。</p><h4 id="4-1-自旋条件"><a href="#4-1-自旋条件" class="headerlink" title="4.1 自旋条件"></a>4.1 自旋条件</h4><p>加锁时程序会自动判断是否可以自旋，无限制的自旋将会给CPU带来巨大压力，所以判断是否可以自旋就很重要了。</p><p>自旋必须满足以下所有条件</p><ul><li>自旋次数要足够小，通常为4，即自旋最多4次</li><li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁</li><li>协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋</li><li>协程调度机制中的可运行队列必须为空，否则会延迟协程调度</li></ul><p>可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。</p><h4 id="4-2-自旋的优势"><a href="#4-2-自旋的优势" class="headerlink" title="4.2 自旋的优势"></a>4.2 自旋的优势</h4><p>自旋的优势是更充分的利用CPU，尽量避免协程切换。因为当前申请加锁的协程拥有CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。</p><h4 id="4-3-自旋的问题"><a href="#4-3-自旋的问题" class="headerlink" title="4.3 自旋的问题"></a>4.3 自旋的问题</h4><p>如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态。</p><p>为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。</p><h3 id="5-Mutex-模式"><a href="#5-Mutex-模式" class="headerlink" title="5.Ｍutex 模式"></a>5.Ｍutex 模式</h3><p>前面分析加锁和解锁过程中只关注了Waiter和Locked位的变化，现在我们看一下Starving位的作用。</p><p>每个Mutex都有两个模式，称为Normal和Starving。下面分别说明这两个模式。</p><h4 id="4-1-normal模式"><a href="#4-1-normal模式" class="headerlink" title="4.1 normal模式"></a>4.1 normal模式</h4><p>默认情况下，Mutex的模式为normal。</p><p>该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。</p><h4 id="4-2-starvation模式"><a href="#4-2-starvation模式" class="headerlink" title="4.2 starvation模式"></a>4.2 starvation模式</h4><p>自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞。</p><p>处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1。</p><h3 id="5-Woken状态"><a href="#5-Woken状态" class="headerlink" title="5. Woken状态"></a>5. Woken状态</h3><p>Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。</p><h3 id="6-为什么重复解锁要panic"><a href="#6-为什么重复解锁要panic" class="headerlink" title="6.为什么重复解锁要panic"></a>6.为什么重复解锁要panic</h3><p>可能你会想，为什么Go不能实现得更健壮些，多次执行Unlock()也不要panic？</p><p>仔细想想Unlock的逻辑就可以理解，这实际上很难做到。Unlock过程分为将Locked置为0，然后判断Waiter值，如果值&gt;0，则释放信号量。</p><p>如果多次Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。</p><h3 id="7-编程Tips"><a href="#7-编程Tips" class="headerlink" title="7. 编程Tips"></a>7. 编程Tips</h3><h4 id="7-1-使用defer避免死锁"><a href="#7-1-使用defer避免死锁" class="headerlink" title="7.1 使用defer避免死锁"></a>7.1 使用defer避免死锁</h4><p>加锁后立即使用defer对其解锁，可以有效的避免死锁。</p><h5 id="7-2-加锁和解锁应该成对出现"><a href="#7-2-加锁和解锁应该成对出现" class="headerlink" title="7.2 加锁和解锁应该成对出现"></a>7.2 加锁和解锁应该成对出现</h5><p>加锁和解锁最好出现在同一个层次的代码块中，比如一个函数。</p><p>重复解锁会引起panic，应该避免这种操作的可能性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go range</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-range/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-range/</id>
    <published>2019-07-06T07:22:37.000Z</published>
    <updated>2019-07-06T07:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map和channel等，实际使用频率非常高。</p><p>探索range的实现机制是很有意思的事情，这可能会改变你使用range的习惯。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一：切片遍历"><a href="#2-1-题目一：切片遍历" class="headerlink" title="2.1 题目一：切片遍历"></a>2.1 题目一：切片遍历</h4><p>下面函数通过遍历切片，打印切片的下标和元素值，请问性能上有没有可优化的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func RangeSlice(slice []int)&#123;</span><br><span class="line">    for index,value := range slice &#123;</span><br><span class="line">        _,_ := index,value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>函数中使用<code>for-range</code>对切片进行遍历，获取切片的下标和元素值，这里忽略函数的实际意义。</p><p>参考答案：</p><p>遍历过程中，每次迭代会对index和value进行赋值，如果数据量大或者value类型为string时，对value的赋值操作可能是多余的，可以在for-range中忽略value值，使用slice[index]引用value值。</p><h4 id="2-2-题目二：Map遍历"><a href="#2-2-题目二：Map遍历" class="headerlink" title="2.2 题目二：Map遍历"></a>2.2 题目二：Map遍历</h4><p>下面函数通过遍历Map，打印Map的key和value，请问性能上有没有可以优化的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func RangeMap(myMap map[int]string) &#123;</span><br><span class="line">    for key, _ := range myMap &#123;</span><br><span class="line">        _, _ = key, myMap[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>函数中使用for-range对map进行遍历，获取map的key值，并根据key值获取value值，这里忽略函数的实际意义。</p><p>参考答案：</p><p>函数中for-range语句中值获取key值，然后根据key值获取value值，虽然看似减少了一次赋值，但通过key值查找value值的性能可能高于赋值消耗。能否优化取决于map所存储数据结构特征、结合实际情况进行判断。</p><h4 id="2-3-题目三：动态遍历"><a href="#2-3-题目三：动态遍历" class="headerlink" title="2.3 题目三：动态遍历"></a>2.3 题目三：动态遍历</h4><p>请问如下程序是否能正常结束？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    v := []int&#123;1, 2, 3&#125;</span><br><span class="line">    for i:= range v &#123;</span><br><span class="line">        v = append(v, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>main()函数中定义一个切片v，通过range遍历v，遍历过程中不断向v中添加新的元素。</p><p>参考答案：</p><p>能够正常结束。循环内改变切片的长度，不影响循环次数，循环次效在循环开始前就已经确定了。</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><p>对于for-range语句的实现，可以从编译器源码中找到答案。</p><p>编译器源码 <code>gofrontend/go/statements.cc/For_range_statement::do_lower()</code> 方法中有如下注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Arrange to do a loop appropriate for the type.  We will produce</span><br><span class="line">//   for INIT ; COND ; POST &#123;</span><br><span class="line">//           ITER_INIT</span><br><span class="line">//           INDEX = INDEX_TEMP</span><br><span class="line">//           VALUE = VALUE_TEMP // If there is a value</span><br><span class="line">//           original statements</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>可见range实际上是一个C风格的循环结构。range支持数组、数组指针、切片、map和channel类型，对于不同类型有些细节上的差异。</p><h4 id="3-1-range-for-slice"><a href="#3-1-range-for-slice" class="headerlink" title="3.1 range for slice"></a>3.1 range for slice</h4><p>下面的注释解释了遍历slice的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   for_temp := range</span><br><span class="line">//   len_temp := len(for_temp)</span><br><span class="line">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">//           value_temp = for_temp[index_temp]</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>遍历slice前会先获以slice的长度len_temp作为循环次数，循环体中，每次循环会先获取元素值，如果for-range中接收index和value的话，则会对index和value进行一次赋值。</p><p>由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是没办法遍历到的。</p><p>另外，数组与数组指针的遍历过程与slice基本一致，不再赘述。</p><h4 id="3-2-range-for-map"><a href="#3-2-range-for-map" class="headerlink" title="3.2 range for map"></a>3.2 range for map</h4><p>下面的注释解释了遍历map的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   var hiter map_iteration_struct</span><br><span class="line">//   for mapiterinit(type, range, &amp;hiter); hiter.key != nil; mapiternext(&amp;hiter) &#123;</span><br><span class="line">//           index_temp = *hiter.key</span><br><span class="line">//           value_temp = *hiter.val</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>遍历map时没有指定循环次数，循环体与遍历slice类似。由于map底层实现与slice不同，map底层使用hash表实现，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。</p><h4 id="3-3-range-for-channel"><a href="#3-3-range-for-channel" class="headerlink" title="3.3 range for channel"></a>3.3 range for channel</h4><p>遍历channel是最特殊的，这是由channel的实现机制决定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   for &#123;</span><br><span class="line">//           index_temp, ok_temp = &lt;-range</span><br><span class="line">//           if !ok_temp &#123;</span><br><span class="line">//                   break</span><br><span class="line">//           &#125;</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>channel遍历是依次从channel中读取数据,读取前是不知道里面有多少个元素的。如果channel中没有元素，则会阻塞等待，如果channel已被关闭，则会解除阻塞并退出循环。</p><p><strong>注</strong></p><ul><li>上述注释中index_temp实际上描述是有误的，应该为value_temp，因为index对于channel是没有意义的。</li><li>使用for-range遍历channel时只能获取一个返回值。</li></ul><h3 id="4-编程Tips"><a href="#4-编程Tips" class="headerlink" title="4.编程Tips"></a>4.编程Tips</h3><ul><li>遍历过程中可以视情况放弃接收index或value，可以在一定程度上提升性能</li><li>遍历channel时，避免channel没有数据，可能会阻塞</li><li>尽量避免遍历过程中修改原数据</li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>for-range的实现实际上是C风格的for循环</li><li>使用index、value接收range返回值会发生一次数据拷贝。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map和channel等，实际使用频率非常高。&lt;/
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go select</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-select/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-select/</id>
    <published>2019-07-06T05:14:12.000Z</published>
    <updated>2019-07-06T06:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready（即是否可读或可写），使用起来非常方便。</p><p>本章试图根据源码总结其实现原理，从而发现一些使用误区或解释一些不太常见的现象。</p><h3 id="2-热身环节"><a href="#2-热身环节" class="headerlink" title="2. 热身环节"></a>2. 热身环节</h3><h4 id="2-1-题目1"><a href="#2-1-题目1" class="headerlink" title="2.1 题目1"></a>2.1 题目1</h4><p>下面的程序输出是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        chan1 &lt;- 1</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        chan2 &lt;- 1</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，分别向两个channel中写入一个数据就进入睡眠。select语句两个case分别检测chan1和chan2是否可读，如果都不可读则执行default语句。</p><p>参考答案：</p><p>select中各个case执行顺序是随机的，如果某个case中的channel已经ready，则执行相应的语句并退出select流程，如果所有case中的channel都未ready，则执行default中语句然后退出select流程。另外，由于启动的协程和select语句并不能保证执行顺序，所以也有可能select执行时协程还未向channel中写入数据，所以select直接执行default语句并退出，所以，以下三种输出都有可能：</p><p>可能的输出一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chan1 ready.</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><p>可能的输出二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chan2 ready</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><p>可能的输出三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><h4 id="2-2-题目2"><a href="#2-2-题目2" class="headerlink" title="2.2 题目2"></a>2.2 题目2</h4><p>下面的程序执行到select时会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    writeFlag := false</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if writeFlag &#123;</span><br><span class="line">                chan1 &lt;- 1</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if writeFlag &#123;</span><br><span class="line">                chan2 &lt;- 1</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程会判断一个bool类型的变量，writeFlag来决定是否要向channel中写入数据，由于writeFlag永远是false，所以实际上协程什么也没做。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</p><p>参考答案：</p><p>select会按照随机的顺序检测各case语句中cahnnel是否ready，如果某个case中的channel已经ready则执行相应的case语句然后退出select流程，如果所有的channel都未ready且没有default的话，则会阻塞等待各个channel。所以上述程序会一直阻塞。</p><h4 id="2-3-题目3"><a href="#2-3-题目3" class="headerlink" title="2.3 题目3"></a>2.3 题目3</h4><p>下面程序有什么问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        close(chan1)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        close(chan2)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程分别关闭两个channel。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</p><p>参考答案：</p><p>select会按照随机的顺序检测各case语句中channel是否ready，考虑到已关闭的channel也是可读的，所以上述程序中select不会阻塞，具体执行哪个case语句具是随机的。</p><h4 id="2-4-题目4"><a href="#2-4-题目4" class="headerlink" title="2.4 题目4"></a>2.4 题目4</h4><p>下面程序会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中只有一个空的select语句。</p><p>参考答案：</p><p>对于空的select语句，程序会阻塞，准确的说是当前协程会被阻塞，同时Golang自带死锁检测机制，当发现当前协程再也没有机会被唤醒时，则会panic。所以上述程序会panic。</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3.实现原理"></a>3.实现原理</h3><p>Golang实现了select时，定义了一个数据结构表示每个case语句（含default，default实际上是一种特殊的case），select执行过程类比成一个函数，函数输入case数组，输出选中的case，然后程序流转到选中的case块。</p><h4 id="3-1-case数据结构"><a href="#3-1-case数据结构" class="headerlink" title="3.1 case数据结构"></a>3.1 case数据结构</h4><p>源码包<code>src/runtime/select.go:scase</code>定义了表示case语句的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type scase struct &#123;</span><br><span class="line">    c       *hchan      // chan</span><br><span class="line">    kind    uint16</span><br><span class="line">    elem    unsafe.Pointer  // data element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scase.c 为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。scase.kind表示该case的类型，分为读channel、写channel和default，三种类型分别由常量定义：</p><ul><li>caseRecv：case语句中尝试读取scase.c中的数据；</li><li>caseSend：case语句中尝试向scase.c中写入数据</li><li>caseDefault：default语句</li></ul><p>scase.elem 表示缓冲区地址，根据scase.kind的不同，有不同用途：</p><ul><li>scase.kind == caseRecv：scase.elem表示读出channel的数据存放地址；</li><li>scase.kind == caseSend：scase.elem表示将要写入channel的数据存放地址；</li></ul><h4 id="3-2-select实现逻辑"><a href="#3-2-select实现逻辑" class="headerlink" title="3.2 select实现逻辑"></a>3.2 select实现逻辑</h4><p>源码包<code>src/runtime/select.go:selectgo()</code>定义了select选择case的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase,order0 *uint16,ncases int)(int,bool)</span><br></pre></td></tr></table></figure><p>函数参数：</p><ul><li>cas为scase数组的首地址，selectgo()就是从这些scase中找出一个返回。</li><li>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder<ul><li>pollorder：每次selectgo执行都会把scase序列打乱，以达到随机检测case的目的。</li><li>lockorder：所有case语句中channel序列，以达到去重防止对channel加锁时重复加锁的目的</li></ul></li><li>ncase表示scase数据的长度</li></ul><p>函数返回值：</p><ul><li>1.int：选中case的编号，这个case编号和代码一致</li><li>2.bool：是否成功从channel中读取了数据，如果选中的case是从channel中读数据，则该返回值表示是否读取成功。</li></ul><p>selectgo实现的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase,order *uint16,ncase int) (int,bool)&#123;</span><br><span class="line">    //1.锁定scase语句中所有的channel</span><br><span class="line">    //2.按照随机顺序检测scase中的channel是否ready</span><br><span class="line">    //  2.1 如果case可读，则读取channel中数据，解锁所有的channel,然后返回(case index,true)</span><br><span class="line">    //  2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index,false)</span><br><span class="line">    //  2.3 所有case都未ready,则解锁所有的channel，然后返回(default index,false)</span><br><span class="line">    //3.所有case都未ready，且没有default语句</span><br><span class="line">    //  3.1将当前协程加入到所有channel的等待队列</span><br><span class="line">    //  3.2当前协程转入阻塞，等待被唤醒</span><br><span class="line">    //4.唤醒后返回channel对应case index</span><br><span class="line">    //  4.1 如果是读操作，解锁所有的channel，然后返回(case index,true)</span><br><span class="line">    //  4.2 如果是写操作，解锁所有的channel，然后返回(case index,false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别说明：</p><p>对于读channel的case来说，如<code>case elem,ok := &lt;- chan1：</code>，如果channel有可能被其它协程关闭的情况下，一定要检测是否读取成功，因为close的channel也有可能返回，此时ok==false。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>select语句中除default外，每个case操作一个channel，要么读要么写</li><li>select语句中除default外，各case执行顺序是随机的</li><li>select语句中如果没有default语句，则会阻塞等待任一case</li><li>select语句中读操作要判断是否成功读取，关闭的channel也可以读取。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready（即是否可读或可
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go defer</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-defer/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-defer/</id>
    <published>2019-07-06T02:25:32.000Z</published>
    <updated>2019-07-06T05:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前，再把延迟函数取出并执行。</p><p>为了方便描述，我们把创建defer的函数称为主函数，defer语句后面的函数称为延迟函数。</p><p>延迟函数可能有输入参数，这些参数可能来源于定义defer的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为，这些场景下，如果不了解defer的规则很容易出错。</p><p>其实官方说明的defer的三个原则很清楚，本节试图汇总defer的使用场景并做简单说明。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><p>下面函数输出结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncParameter() &#123;</span><br><span class="line">    var aInt = 1</span><br><span class="line"></span><br><span class="line">    defer fmt.Println(aInt)</span><br><span class="line"></span><br><span class="line">    aInt = 2</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目说明：</p><p>函数deferFuncParameter()定义一个整型变量并初始化为1，然后使用defer语句打印出变量值，最后修改变量值为2.</p><p>参考答案：</p><p>输出1。延迟函数fmt.Println(aInt)的参数在defer语句出现时就已经确定了，所以无论后面如何修改aInt变量都不会影响延迟函数。</p><h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><p>下面程序输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printArray(array *[3]int) &#123;</span><br><span class="line">    for i := range array &#123;</span><br><span class="line">        fmt.Println(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func deferFuncParameter() &#123;</span><br><span class="line">    var aArray = [3]int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">    defer printArray(&amp;aArray)</span><br><span class="line"></span><br><span class="line">    aArray[0] = 10</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    deferFuncParameter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>函数deferFuncParameter()定义一个数组，通过defer延迟函数printArray()的调用，最后修改数组第一个元素。printArray()函数接受数组的指针并把数组全部打印出来。</p><p>参考答案：</p><p>输出10、2、3三个值。延迟函数printArray()的参数在defer语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在return语句之前，所以对数组的最终修改值会被打印出来。</p><h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>下面函数输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncReturn() (result int) &#123;</span><br><span class="line">    i := 1</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       result++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>函数拥有一个具名返回值result，函数内部声明一个变量i，defer指定一个延迟函数，最后返回变量i。延迟函数中递增result。</p><p>参考答案：</p><p>函数输出2。函数的return语句并不是原子的，实际执行分为设置返回值–&gt;ret，defer语句实际执行在返回前，即拥有defer的函数返回过程是：设置返回值–&gt;执行defer–&gt;ret。所以return语句先把result设置为i的值，即1，defer语句中又把result递增1，所以最终返回2。</p><h3 id="3-defer规则"><a href="#3-defer规则" class="headerlink" title="3. defer规则"></a>3. defer规则</h3><p>Golang官方博客里总结了defer的行为规则，只有三条，我们围绕这三条进行说明。</p><h4 id="3-1-规则一：延迟函数的参数在defer语句出现时就已经确定下来了"><a href="#3-1-规则一：延迟函数的参数在defer语句出现时就已经确定下来了" class="headerlink" title="3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了"></a>3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了</h4><p>官方给出了一个例子，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a()&#123;</span><br><span class="line">    i := 0 </span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer语句中的fmt.Println()参数i值在defer出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响fmt.Println()函数的执行，仍然打印”0”。</p><p>注意：对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，defer后面的语句对变量的修改可能会影响延迟函数。</p><h4 id="3-2-规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行"><a href="#3-2-规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行" class="headerlink" title="3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行"></a>3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行</h4><p>这个规则很好理解，定义defer类似于入栈操作，执行defer类似于出栈操作。</p><p>设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再跟据A资源申请B资源，跟据B资源申请C资源，即申请顺序是:A–&gt;B–&gt;C，释放时往往又要反向进行。这就是把deffer设计成LIFO(Last In First Out)的原因。</p><p>每申请到一个用完需要释放的资源时，立即定义一个defer来释放资源是个很好的习惯。</p><h4 id="3-3-规则三：延迟函数可能操作主函数的具名返回值"><a href="#3-3-规则三：延迟函数可能操作主函数的具名返回值" class="headerlink" title="3.3 规则三：延迟函数可能操作主函数的具名返回值"></a>3.3 规则三：延迟函数可能操作主函数的具名返回值</h4><p>定义defer的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer所作用的函数，即延迟函数可能会影响到返回值。</p><p>若要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回的就足够了。</p><h6 id="3-1-函数返回过程"><a href="#3-1-函数返回过程" class="headerlink" title="3.1 函数返回过程"></a>3.1 函数返回过程</h6><p>有一个事实必须要了解，关键字<code>return</code>不是一个原子操作，实际上<code>return</code>只代理汇编指令<code>ret</code>，即将跳转程序执行。比如语句<code>return i</code>，实际上分两步进行，即将<code>i</code>存入栈中作为返回值，然后执行跳转，而defer的执行时机正是<strong>跳转前</strong>，所示说defer执行时还是有机会操作返回值的。</p><p>举个实际的例子进行说明这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncReturn() (result int) &#123;</span><br><span class="line">    i := 1</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       result++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的return语句可以拆分成下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = i</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>而延迟函数的执行正是在return之前，即加入defer后执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = i</span><br><span class="line">result ++ </span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>所以上面函数实际返回i++值。</p><p>关于主函数有不同的返回方式，但返回机制就如上机介绍所说，只要把return语句拆开都可以很好的理解，下面分别举例说明</p><h5 id="3-1-1-主函数拥有匿名返回值，返回字面值"><a href="#3-1-1-主函数拥有匿名返回值，返回字面值" class="headerlink" title="3.1.1 主函数拥有匿名返回值，返回字面值"></a>3.1.1 主函数拥有匿名返回值，返回字面值</h5><p>一个主函数拥有一个匿名的返回值，返回时使用字面值，比如返回”1”、”2”、”Hello”这样的值，这种情况下defer语句是无法操作返回值的。</p><p>一个返回字面值的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() int &#123;</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的return语句，直接把1写入栈中作为返回值，延迟函数无法操作该返回值，所以就无法影响返回值。</p><h5 id="3-3-2-主函数拥有匿名返回值，返回变量"><a href="#3-3-2-主函数拥有匿名返回值，返回变量" class="headerlink" title="3.3.2 主函数拥有匿名返回值，返回变量"></a>3.3.2 主函数拥有匿名返回值，返回变量</h5><p>一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下defer语句可以引用到返回值，但不会改变返回值。</p><p>一个返回本地变量的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() int &#123;</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，返回一个局部变量，同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量为”anony”，上面的返回语句可以拆分成以下过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anony = i</span><br><span class="line">i++</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>由于i是整型，会将值拷贝给anony，所以defer语句中修改i值，对函数返回值不造成影响。</p><h5 id="3-3-3-主函数拥有具名返回值"><a href="#3-3-3-主函数拥有具名返回值" class="headerlink" title="3.3.3 主函数拥有具名返回值"></a>3.3.3 主函数拥有具名返回值</h5><p>主函声明语句中带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。如果defer语句操作该返回值，可能会改变返回结果。</p><p>一个影响函返回值的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func foo() (ret int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        ret++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数拆解出来，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = 0</span><br><span class="line">ret++</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>函数真正返回前，在defer中对返回值做了+1操作，所以函数最终返回1。</p><h3 id="4-defer实现原理"><a href="#4-defer实现原理" class="headerlink" title="4. defer实现原理"></a>4. defer实现原理</h3><p>本节我们尝试了解一些defer的实现机制。</p><h4 id="4-1-defer数据结构"><a href="#4-1-defer数据结构" class="headerlink" title="4.1 defer数据结构"></a>4.1 defer数据结构</h4><p>源码包<code>src/src/runtime/runtime2.go:_defer</code>定义了defer的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type _defer struct &#123;</span><br><span class="line">    sp      uintptr   //函数栈指针</span><br><span class="line">    pc      uintptr   //程序计数器</span><br><span class="line">    fn      *funcval  //函数地址</span><br><span class="line">    link    *_defer   //指向自身结构的指针，用于链接多个defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道defer后面一定要接一个函数的，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等等。</p><p>与函数不同的一点是它含有一个指针，可用于指向另一个defer，每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer插入到单链表表头，每次执行defer时就从单链表表头取出一个defer执行。</p><p>下图展示多个defer被链接的过程：</p><p><img src="http://image.huany.top/hexo/go/defer.jpg" alt></p><p>从上图可以看到，新声明的defer总是添加到链表头部。函数返回前执行defer则是从链表首部依次取出执行。</p><p>一个goroutine可能连续调用多个函数，defer添加过程跟上述流程一致，进入函数时添加defer，离开函数时取出defer，所有即便调用多个函数，也总能保证defer是按照LIFO方式执行 的。</p><h4 id="4-2-defer的创建和执行"><a href="#4-2-defer的创建和执行" class="headerlink" title="4.2 defer的创建和执行"></a>4.2 defer的创建和执行</h4><p>源码包<code>src/runtine/panic.go</code>定义了两个方法分别用于创建defer和执行defer。</p><ul><li>deferproc()：在声明defer处调用，其将defer函数存入goroutine的链表中；</li><li>deferreturn()：在return指令，准确的将是在ret指令前调用，其将defer从goroutine链表中取出并执行。</li></ul><p>可以简单的这么理解，在编译阶段，声明defer出插入了deferproc()，在函数return前插入了deferreturn()。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>defer定义的延迟函数参数在defer语句出来时就已经确定下来了</li><li>defer定义顺序与执行顺序相反</li><li>return不是原子操作，执行过程是：保存返回值（若有） –&gt; 执行defer –&gt; 执行return跳转</li><li>申请资源后立即使用defer关闭资源是好习惯</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前，再把延迟函数取出并执行。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go iota</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-iota/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-iota/</id>
    <published>2019-07-05T16:29:29.000Z</published>
    <updated>2019-07-05T16:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>我们知道iota常用于const表达式中，我们还知道其值是从零开始的，const声明块中每增加一行iota值自增1。</p><p>使用iota可以简化常量定义，但其规则必须要牢牢掌握，否则在我们阅读别人源码时可能会造成误解或障碍。本节我们尝试全面的总结其使用场景，另外花一小部分时间看一下其实现原理，从原理上把握可以更深刻的记忆这些规则。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><p>下面常量定义源于GO源码，下面每个常量的值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Priority int</span><br><span class="line">const (</span><br><span class="line">    LOG_EMERG Priority = iota</span><br><span class="line">    LOG_ALERT</span><br><span class="line">    LOG_CRIT</span><br><span class="line">    LOG_ERR</span><br><span class="line">    LOG_WARNING</span><br><span class="line">    LOG_NOTICE</span><br><span class="line">    LOG_INFO</span><br><span class="line">    LOG_DEBUG</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>上面代码源于日志模块，定义了一组代表日志级别的常量，常量类型为Priority，实际为int类型。</p><p>参考答案：</p><p>iota初始值为0，也即LOG_EMERG值为0，下面每个常量递增1。</p><h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><p>下面代码取自Go源码，请问每个常量值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    mutexLocked = 1 &lt;&lt; iota // mutex is locked</span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexStarving</span><br><span class="line">    mutexWaiterShift = iota</span><br><span class="line">    starvationThresholdNs = 1e6</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>以上代码取自Go互斥锁Mutex的实现，用于指示各种状态位的地址偏移。</p><p>参考答案：</p><p>mutexLocked == 1；mutexWoken == 2；mutexStarving == 4；mutexWaiterShift == 3；starvationThresholdNs == 1000000。</p><h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>请问每个常量值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1</span><br><span class="line">    bit1, mask1</span><br><span class="line">    _, _</span><br><span class="line">    bit3, mask3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>以上代码取自Go官方文档。</p><p>参考答案：</p><p>bit0 == 1， mask0 == 0， bit1 == 2， mask1 == 1， bit3 == 8， mask3 == 7</p><h3 id="3-规则"><a href="#3-规则" class="headerlink" title="3.规则"></a>3.规则</h3><p>很多书上或博客描述的规则是这样的： </p><ol><li>iota在const关键字出现时被重置为0 </li><li>const声明块中每新增一行iota值自增1</li></ol><p>我曾经也这么理解，看过编译器代码后发现，其实规则只有一条：</p><ul><li><strong>iota代表了const声明块的行索引（下标从0开始）</strong></li></ul><p>这样理解更贴近编译器实现逻辑，也更准确。除此之外，const声明还有个特点，即第一个常量必须指定一个表达式，后续的常量如果没有表达式，则继承上面的表达式。</p><p>下面再来根据这个规则看下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1   //const声明第0行，即iota==0</span><br><span class="line">    bit1, mask1                            //const声明第1行，即iota==1, 表达式继承上面的语句</span><br><span class="line">    _, _                                   //const声明第2行，即iota==2</span><br><span class="line">    bit3, mask3                            //const声明第3行，即iota==3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>第0行的表达式展开即bit0, mask0 = 1 &lt;&lt; 0, 1&lt;&lt;0 - 1，所以bit0 == 1，mask0 == 0；</li><li>第1行没有指定表达式继承第一行，即bit1, mask1 = 1 &lt;&lt; 1, 1&lt;&lt;1 - 1，所以bit1 == 2，mask1 == 1；</li><li>第2行没有定义常量</li><li>第3行没有指定表达式继承第一行，即bit3, mask3 = 1 &lt;&lt; 3, 1&lt;&lt;3 - 1，所以bit0 == 8，mask0 == 7；</li></ul><h3 id="4-编译原理"><a href="#4-编译原理" class="headerlink" title="4.编译原理"></a>4.编译原理</h3><p>const块中每一行在GO中使用spec数据结构描述，spec声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// A ValueSpec node represents a constant or variable declaration</span><br><span class="line">// (ConstSpec or VarSpec production).</span><br><span class="line">//</span><br><span class="line">ValueSpec struct &#123;</span><br><span class="line">    Doc     *CommentGroup // associated documentation; or nil</span><br><span class="line">    Names   []*Ident      // value names (len(Names) &gt; 0)</span><br><span class="line">    Type    Expr          // value type; or nil</span><br><span class="line">    Values  []Expr        // initial values; or nil</span><br><span class="line">    Comment *CommentGroup // line comments; or nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只关注ValueSpec.Names， 这个切片中保存了一行中定义的常量，如果一行定义N个常量，那么ValueSpec.Names切片长度即为N。</p><p>const块实际上是spec类型的切片，用于表示const中的多行。</p><p>所以编译期间构造常量时的伪算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for iota, spec := range ValueSpecs &#123;</span><br><span class="line">    for i, name := range spec.Names &#123;</span><br><span class="line">        obj := NewConst(name, iota...) //此处将iota传入，用于构造常量</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;我们知道iota常用于const表达式中，我们还知道其值是从零开始的，const声明块中每增加一行iota值自增1。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go channel 低层源码剖析</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-channel/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-channel/</id>
    <published>2019-07-05T16:00:48.000Z</published>
    <updated>2019-07-05T16:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>channel是Golang在语言层面提供的goroutine间通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统方法来解决。</p><p>本章，从源码角度分析channel的实现机制，实际上这部分源码非常简单易读。</p><h3 id="chan数据结构"><a href="#chan数据结构" class="headerlink" title="chan数据结构"></a>chan数据结构</h3><p><code>src/runtine/chan.go:hchan</code>定义了channel的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">    qcount   uint           // 当前队列中剩余元素个数</span><br><span class="line">    dataqsiz uint           // 环形队列长度，即可以存放的元素个数</span><br><span class="line">    buf      unsafe.Pointer // 环形队列指针</span><br><span class="line">    elemsize uint16         // 每个元素的大小</span><br><span class="line">    closed   uint32         // 标识关闭状态</span><br><span class="line">    elemtype *_type // 元素类型</span><br><span class="line">    sendx    uint   // 队列下标，指示元素写入时存放到队列中的位置</span><br><span class="line">    recvx    uint   // 队列下标，指示元素从队列的该位置读出</span><br><span class="line">    recvq    waitq  // 等待读消息的goroutine队列</span><br><span class="line">    sendq    waitq  // 等待写消息的goroutine队列</span><br><span class="line">    lock mutex      // 互斥锁，chan不允许并发读写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。</p><h5 id="2-1-环形队列"><a href="#2-1-环形队列" class="headerlink" title="2.1 环形队列"></a>2.1 环形队列</h5><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。</p><p>下图展示了一个可缓存6个元素的channel示意图：</p><p><img src="http://image.huany.top/hexo/go/chan-01-circle_queue.png" alt></p><ul><li>datasiz 指示了队列长度为6，即可缓存6个元素；</li><li>buf指向队列的内存，队列中还剩余两个元素；</li><li>qcount表示队列中还有两个元素；</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><h4 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h4><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前的goroutine会被阻塞。</p><p>被阻塞的goroutine会被挂在channel的等待队列中；</p><ul><li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li><li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li></ul><p>下图展示了一个没有缓冲区的channel，有几个gouroutine阻塞等待读数据：</p><p><img src="http://image.huany.top/hexo/go/chan-02-wait_queue.png" alt></p><p><strong>注意</strong>，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p><h4 id="2-3-类型信息"><a href="#2-3-类型信息" class="headerlink" title="2.3 类型信息"></a>2.3 类型信息</h4><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p><ul><li>elemtype代表类型，用于数据传递过程中的赋值；</li><li>elemsize代表类型大小，用于在buf中定位元素位置。</li></ul><h4 id="2-4-锁"><a href="#2-4-锁" class="headerlink" title="2.4 锁"></a>2.4 锁</h4><p>一个channel同时仅允许被一个goroutine读写</p><h3 id="3-channel读写"><a href="#3-channel读写" class="headerlink" title="3.channel读写"></a>3.channel读写</h3><h4 id="3-1-创建channel"><a href="#3-1-创建channel" class="headerlink" title="3.1 创建channel"></a>3.1 创建channel</h4><p>创建channel的过程实际上是初始化hchan结构，其中类型信息和缓冲区长度由<code>make</code>语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p><p>创建channel的伪代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan&#123;</span><br><span class="line">    var c *hchan</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = malloc(元素类型*size)</span><br><span class="line">    c.elemsize = 元素类型大小</span><br><span class="line">    c.elemtype = 元素类型</span><br><span class="line">    c.dataqsiz size</span><br><span class="line">    </span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-向channel写数据"><a href="#3-2-向channel写数据" class="headerlink" title="3.2 向channel写数据"></a>3.2 向channel写数据</h4><p>向一个channel中写数据简单过程如下：</p><ul><li>1.如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后把该G唤醒，结束发送过程</li><li>2.如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程；</li><li>3.如果缓冲区没有空余位置，将待发数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒。.</li></ul><p>简单流程图如下：</p><p><img src="http://image.huany.top/hexo/go/chan-03-send_data.png" alt></p><h4 id="3-3-从channel读数据"><a href="#3-3-从channel读数据" class="headerlink" title="3.3 从channel读数据"></a>3.3 从channel读数据</h4><p>从一个channel读数据简单过程如下：</p><ul><li>1.如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li><li>2.如果等待发送队列sendq不为空，缓冲区已满，从缓冲区首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li><li>3.如果缓冲区有数据，则从缓冲区取出数据，结束读取过程；</li><li>4.将当前的goroutine加入recvq，进入睡眠，等待被写goroutine唤醒。</li></ul><p><img src="http://image.huany.top/hexo/go/chan-04-recieve_data.png" alt></p><h4 id="3-4-关闭channel"><a href="#3-4-关闭channel" class="headerlink" title="3.4 关闭channel"></a>3.4 关闭channel</h4><p>关闭channel时会把revq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但是这些G会panic。</p><p>除此之外，panic出现的常见场景还有：</p><ul><li>1.关闭值为nil的channel</li><li>2.关闭已经被关闭的channel</li><li>3.向已经关闭的channel写数据</li></ul><h3 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4.常见用法"></a>4.常见用法</h3><h4 id="4-1-单向channel"><a href="#4-1-单向channel" class="headerlink" title="4.1 单向channel"></a>4.1 单向channel</h4><p>顾名思义，单向channel指只能用于发送或接收数据，实际上也没有单向channel。</p><p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p><ul><li>func readChan(chanName &lt;-chan int)：通过形参限定函数内部只能从channel中读取数据</li><li>func writeChan(chanName chan&lt;- int)：通过形参限定函数内部只能往channel中写数据</li></ul><p>一个简单的示例程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func readChan(chanName &lt;-chan int) &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeChan(chanName chan&lt;- int) &#123;</span><br><span class="line">    chanName &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var mychan = make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来读。</p><h4 id="4-2-select"><a href="#4-2-select" class="headerlink" title="4.2 select"></a>4.2 select</h4><p>使用select可以监控多个channel，比如监控多个channel，当其中某一个channel有数据的话，就从中读出数据。</p><p>一个简单的示例程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func addNumberToChan(chanName chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        chanName &lt;- 1</span><br><span class="line">        time.Sleep(1 * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var chan1 = make(chan int, 10)</span><br><span class="line">    var chan2 = make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    go addNumberToChan(chan1)</span><br><span class="line">    go addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(&quot;Get element from chan1: %d\n&quot;, e)</span><br><span class="line">        case e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(&quot;Get element from chan2: %d\n&quot;, e)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Printf(&quot;No element in chan1 and chan2.\n&quot;)</span><br><span class="line">            time.Sleep(1 * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go run main.go</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element in chan1 and chan2.</span><br></pre></td></tr></table></figure><p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的。</p><p>通过这个示例想说的是：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p><h4 id="4-3-range"><a href="#4-3-range" class="headerlink" title="4.3 range"></a>4.3 range</h4><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func chanRange(chanName chan int) &#123;</span><br><span class="line">    for e := range chanName &#123;</span><br><span class="line">        fmt.Printf(&quot;Get element from chan: %d\n&quot;, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;channel是Golang在语言层面提供的goroutine间通信方式，比Unix管道更易用也更轻便。channel主
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go map原理剖析</title>
    <link href="https://meichaofan.github.io/2019/07/01/go-map/"/>
    <id>https://meichaofan.github.io/2019/07/01/go-map/</id>
    <published>2019-07-01T14:00:04.000Z</published>
    <updated>2019-07-01T15:41:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-map数据结构"><a href="#1-map数据结构" class="headerlink" title="1. map数据结构"></a>1. map数据结构</h3><p>golang的map的使用了哈希表作为低层实现，一个哈希表里可以有多个哈希表节点，也即<strong>bucket</strong>，而每个bucket保存了map中的一个或一组键值对。</p><p>map的数据结构由<code>runtime/map.go:hmap</code>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">    count   int //当前保存的元素个数</span><br><span class="line">    ...</span><br><span class="line">    B       uint8   //指示bucket数组的大小</span><br><span class="line">    ...</span><br><span class="line">    buckets unsafe.Pointer  //bucket数组指针，数组的大小为2^B</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示一个拥有4个bucket的map:</p><p><img src="http://image.huany.top/hexo/go/map-01-struct.png" alt></p><p>本例中，<code>hmap.B=2</code>，而hmap.buckets的长度是2^B为4，元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p><p><code>bucket</code>很多时候会翻译成桶，所谓的<code>哈希桶</code>实际上就是bucket。</p><h3 id="2-bucket数据结构"><a href="#2-bucket数据结构" class="headerlink" title="2. bucket数据结构"></a>2. bucket数据结构</h3><p>bucket数据结构由<code>runtime/map.go:bmap定义</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [8]uint8 //存储哈希值的高8位</span><br><span class="line">    data    byte[1]  //key value数据:key/key/key/.../value/value/value...</span><br><span class="line">    overflow *bmap   //溢出bucket的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket可以存储8个键值对。</p><ul><li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li><li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li><li>overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li></ul><p><strong>注意</strong>：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p><p>下图展示bucket存放8个key-value对：</p><p><img src="http://image.huany.top/hexo/go/map-02-struct_sketch.png" alt></p><h3 id="3-哈希冲突"><a href="#3-哈希冲突" class="headerlink" title="3. 哈希冲突"></a>3. 哈希冲突</h3><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。 由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p><p>下图展示产生冲突后的map：</p><p><img src="http://image.huany.top/hexo/go/map-03-struct_sketch.png" alt></p><p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。</p><h3 id="4-负载因子"><a href="#4-负载因子" class="headerlink" title="4. 负载因子"></a>4. 负载因子</h3><p>负载因子是衡量一个哈希表冲突情况，公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 键数量 / bucket数量</span><br></pre></td></tr></table></figure><p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p><p>哈希表需要将负载因子控制在一个合适的大小，超过阈值需要进行refresh，也即键值对重新组织：</p><ul><li>哈希因子过小，说明空间利用率低</li><li>哈希因子过大，说明冲突严重，存取效率低</li></ul><p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p><h3 id="5-渐进式扩容"><a href="#5-渐进式扩容" class="headerlink" title="5. 渐进式扩容"></a>5. 渐进式扩容</h3><h4 id="5-1-扩容的前提条件"><a href="#5-1-扩容的前提条件" class="headerlink" title="5.1 扩容的前提条件"></a>5.1 扩容的前提条件</h4><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。 触发扩容的条件有二个： 1. 负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。 2. overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</p><h4 id="5-2-增量扩容"><a href="#5-2-增量扩容" class="headerlink" title="5.2 增量扩容"></a>5.2 增量扩容</h4><p>当负载因子过大时，就新建一个buckets，新的buckets长度是原来的2倍，然后旧buckets数据搬迁到新的buckets。 考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p><p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p><p><img src="http://image.huany.top/hexo/go/map-04-struct_sketch.png" alt></p><p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p><p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p><p><img src="http://image.huany.top/hexo/go/map-05-struct_sketch.png" alt></p><p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。 后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p><p>搬迁完成后的示意图如下：</p><p><img src="http://image.huany.top/hexo/go/map-06-struct_sketch.png" alt></p><p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。</p><h4 id="5-3-等量扩容"><a href="#5-3-等量扩容" class="headerlink" title="5.3 等量扩容"></a>5.3 等量扩容</h4><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。 在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p><p><img src="http://image.huany.top/hexo/go/map-07-struct_sketch.png" alt></p><p>上图可见，overflow的buckt中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p><h3 id="6-查找过程"><a href="#6-查找过程" class="headerlink" title="6. 查找过程"></a>6. 查找过程</h3><p>查找过程如下：</p><ol><li>跟据key值算出哈希值 </li><li>取哈希值低位与hmpa.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ol><p><strong>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</strong></p><h3 id="7-插入过程"><a href="#7-插入过程" class="headerlink" title="7. 插入过程"></a>7. 插入过程</h3><p>新员素插入过程如下： </p><ol><li>跟据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值 </li><li>如果没找到将key，将key插入</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-map数据结构&quot;&gt;&lt;a href=&quot;#1-map数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. map数据结构&quot;&gt;&lt;/a&gt;1. map数据结构&lt;/h3&gt;&lt;p&gt;golang的map的使用了哈希表作为低层实现，一个哈希表里可以有多个哈希表节点
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go string低层原理</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-string/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-string/</id>
    <published>2019-06-30T14:19:46.000Z</published>
    <updated>2019-06-30T15:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="string标准概念"><a href="#string标准概念" class="headerlink" title="string标准概念"></a>string标准概念</h3><p>Go标准库<code>builtin</code>给出了所有内置类型的定义。源码位于<code>src/builtin/builtin.go</code>，其中关于string的描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="line">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="line">// not nil. Values of string type are immutable.</span><br><span class="line">type string string</span><br></pre></td></tr></table></figure><p>所以string是8比特字节的集合，通常但不一定是UTF-8编码的文本。</p><p>另外还提到了两点，非常重要：</p><ul><li>string可以为空（长度为0），但不会是nil；</li><li>string对象是不可修改的。</li></ul><h3 id="string-数据结构"><a href="#string-数据结构" class="headerlink" title="string 数据结构"></a>string 数据结构</h3><p>源码包<code>src/runtime/string.go:stringStruct</code>定义了string的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据结构很简单：</p><ul><li>stringStruct.str: 字符串首字母地址；</li><li>stringStruct.len：字符串的长度；</li></ul><p>string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换。这个后面再详细介绍。</p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>如下代码所示，可以声明一个string变量并赋予初值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str string</span><br><span class="line">str = &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>字符串构建过程中先根据字符串构建stringStruct，再转换成string。转换的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func gostringnocopy(str *byte) string &#123; // 跟据字符串地址构建string</span><br><span class="line">    ss := stringStruct&#123;str: unsafe.Pointer(str), len: findnull(str)&#125; // 先构造stringStruct</span><br><span class="line">    s := *(*string)(unsafe.Pointer(&amp;ss))                             // 再将stringStruct转换成string</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string在runtime包中就是stringStruct，对外呈现叫做string。</p><h4 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h4><p>byte切片可以很方便的转换成string，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetStringBySlice(s []byte) string &#123;</span><br><span class="line">    return string(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这种转换需要一次内存拷贝。</p><p>转换过程如下： </p><ol><li>跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；</li><li>构建string（string.str = p；string.len = len；） </li><li>拷贝数据(切片中数据拷贝到新申请的内存空间)</li></ol><p>转换示意图：<br><img src="http://image.huany.top/hexo/go/string-01-slice2string.png" alt></p><h4 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h4><p>string也可以很方便的转成byte切片，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetSliceByString(str string) []byte &#123;</span><br><span class="line">    return []byte(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string转换成byte切片，也需要一次内存拷贝，其过程如下：</p><ul><li>申请切片内存空间</li><li>将string拷贝到切片</li></ul><p>转换示意图：<br><img src="http://image.huany.top/hexo/go/string-02-string2slice.png" alt></p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>字符串可以很方便的拼接，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Str1&quot; + &quot;Str2&quot; + &quot;Str3&quot;</span><br></pre></td></tr></table></figure><p>即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。</p><p>一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。</p><p>字符串拼接伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func concatstrings(a []string) string &#123; // 字符串拼接</span><br><span class="line">    length := 0        // 拼接后总的字符串长度</span><br><span class="line"></span><br><span class="line">    for _, str := range a &#123;</span><br><span class="line">        length += length(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间</span><br><span class="line"></span><br><span class="line">    for _, str := range a &#123;</span><br><span class="line">        copy(b, str)    // string无法修改，只能通过切片修改</span><br><span class="line">        b = b[len(str):]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为string是无法直接修改的，所以这里使用rawstring()方法初始化一个指定大小的string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了string。</p><p>rawstring()源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func rawstring(size int) (s string, b []byte) &#123; // 生成一个新的string，返回的string和切片共享相同的空间</span><br><span class="line">    p := mallocgc(uintptr(size), nil, false)</span><br><span class="line"></span><br><span class="line">    stringStructOf(&amp;s).str = p</span><br><span class="line">    stringStructOf(&amp;s).len = size</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么字符串不允许修改？"><a href="#为什么字符串不允许修改？" class="headerlink" title="为什么字符串不允许修改？"></a>为什么字符串不允许修改？</h4><p>像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。</p><p>因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。</p><h4 id="byte转换成string一定会拷贝内存吗？"><a href="#byte转换成string一定会拷贝内存吗？" class="headerlink" title="[]byte转换成string一定会拷贝内存吗？"></a>[]byte转换成string一定会拷贝内存吗？</h4><p>byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。</p><p>比如，编译器会识别如下临时场景：</p><ul><li>使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；</li><li>字符串拼接，如”&lt;” + “string(b)” + “&gt;”；</li><li>字符串比较：string(b) == “foo”</li></ul><p>因为是临时把byte切片转换成string，也就避免了因byte切片内容改变而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。</p><h4 id="string和-byte如何取舍？"><a href="#string和-byte如何取舍？" class="headerlink" title="string和[]byte如何取舍？"></a>string和[]byte如何取舍？</h4><p>string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要跟据实际应用场景来选择。</p><p>string 擅长的场景：</p><ul><li>需要字符串比较的场景；</li><li>不需要nil字符串的场景；</li></ul><p>[]byte擅长的场景：</p><ul><li>修改字符串的场景，尤其是修改粒度为1个字节</li><li>函数返回值，需要用nil表示含义的场景；</li><li>需要切片操作的场景；</li></ul><p>虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;string标准概念&quot;&gt;&lt;a href=&quot;#string标准概念&quot; class=&quot;headerlink&quot; title=&quot;string标准概念&quot;&gt;&lt;/a&gt;string标准概念&lt;/h3&gt;&lt;p&gt;Go标准库&lt;code&gt;builtin&lt;/code&gt;给出了所有内置类型的定义。
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go slice实现原理</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-slice/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-slice/</id>
    <published>2019-06-30T09:27:15.000Z</published>
    <updated>2019-06-30T13:20:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>Slice又称为动态数组，低层依托于数组实现。可以方便的进行扩容，传递等。实际使用过程中，比数组更灵活。</p><h3 id="2-Slice实现原理"><a href="#2-Slice实现原理" class="headerlink" title="2 Slice实现原理"></a>2 Slice实现原理</h3><p>Slice依托于数组实现，低层数组对用户屏蔽，在低层数组容量不足时可以实现自动重分配并生成新的Slice。</p><h3 id="2-1-Slice的数据结构"><a href="#2-1-Slice的数据结构" class="headerlink" title="2.1 Slice的数据结构"></a>2.1 Slice的数据结构</h3><p>源码包中<code>src/runtime/slice.go</code>定义了Slice的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type slice struct&#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">    cap int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构看，slice其实就是一个结构体，array指针指向低层数组，len表示切片长度，cap表示低层数组容量。</p><h3 id="2-2-使用make创建Slice"><a href="#2-2-使用make创建Slice" class="headerlink" title="2.2 使用make创建Slice"></a>2.2 使用make创建Slice</h3><p>使用<strong>make</strong>关键字创建Slice时，可以同时制定长度和容量，创建时低层会分配一个数组，数组的长度即容量。</p><p>例如，语句 <code>slice:=make([]int,5,10)</code>所创建的slice，结构如下图所示:</p><p><img src="http://image.huany.top/hexo/go/make_slice_01.png" alt></p><p>该Slice的长度为5，可以使用slice[0]~slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。</p><h3 id="2-3-使用数组创建Slice"><a href="#2-3-使用数组创建Slice" class="headerlink" title="2.3 使用数组创建Slice"></a>2.3 使用数组创建Slice</h3><p>使用数组来创建Slice时，Slice将于原数组共用一部分内存。例如，语句<code>slice:=array[5:7]</code>所创建的Slice，结构如下图所示:</p><p><img src="http://image.huany.top/hexo/go/make_slice_02.jpg" alt></p><p>切片从数组array[5]开始，到数组array[7]结束（不含array[7]）,即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5。</p><p>数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。</p><h3 id="2-4-Slice扩容"><a href="#2-4-Slice扩容" class="headerlink" title="2.4 Slice扩容"></a>2.4 Slice扩容</h3><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</p><p>例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如图所示：</p><p><img src="http://image.huany.top/hexo/go/make_slice_03.jpg" alt></p><p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。</p><p>扩容容量的选择遵循以下规则：</p><ul><li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li><li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li></ul><p>使用append()向Slice添加一个元素的实现步骤如下：</p><ol><li>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</li><li>原Slice容量不够，则将Slice先扩容，扩容后得到新Slice</li><li>将新元素追加进新Slice，Slice.len++，返回新的Slice。</li></ol><h3 id="2-5-Slice-Copy"><a href="#2-5-Slice-Copy" class="headerlink" title="2.5 Slice Copy"></a>2.5 Slice Copy</h3><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。也就是说，copy过程中不会发生扩容。</p><h3 id="2-6-特殊切片"><a href="#2-6-特殊切片" class="headerlink" title="2.6 特殊切片"></a>2.6 特殊切片</h3><p>跟据数组或切片生成新的切片一般使用<code>slice := array[start:end]</code>方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p><p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := make([]int, 5, 10)</span><br><span class="line">sliceB := sliceA[0:5]</span><br></pre></td></tr></table></figure><p>根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即<code>slice[start:end:cap]</code>, 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sliceA := make([]int, 5, 10)  //length = 5; capacity = 10</span><br><span class="line">sliceB := sliceA[0:5]         //length = 5; capacity = 10</span><br><span class="line">sliceC := sliceA[0:5:5]       //length = 5; capacity = 5</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><ul><li>每个切片都指向一个底层数组</li><li>每个切片都保存了当前切片的长度、底层数组可用容量</li><li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li><li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li><li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣</li><li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;Slice又称为动态数组，低层依托于数组实现。可以方便的进行扩容，传递等。实际使用过程中，比数组更灵活。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
</feed>
