<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>huany</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meichaofan.github.io/"/>
  <updated>2019-07-07T04:20:24.423Z</updated>
  <id>https://meichaofan.github.io/</id>
  
  <author>
    <name>meichaofan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go mutex</title>
    <link href="https://meichaofan.github.io/2019/07/07/go-mutex/"/>
    <id>https://meichaofan.github.io/2019/07/07/go-mutex/</id>
    <published>2019-07-07T04:19:57.000Z</published>
    <updated>2019-07-07T04:20:24.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。</p><p>Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几种状态。另外，我们也想探究一下Mutex重复解锁引起panic的原因。</p><h3 id="2-Mutex数据结构"><a href="#2-Mutex数据结构" class="headerlink" title="2.Mutex数据结构"></a>2.Mutex数据结构</h3><h4 id="2-1-Mutex结构体"><a href="#2-1-Mutex结构体" class="headerlink" title="2.1 Mutex结构体"></a>2.1 Mutex结构体</h4><p>源码包<code>src/sync/mutex.go:Mutex</code>定义了互斥锁的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Mutex struct&#123;</span><br><span class="line">    state int32</span><br><span class="line">    sema  uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Mutex.state 表示互斥锁的状态，比如是否被锁定等。</li><li>Mutex.sema 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。</li></ul><p>我们看到Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。</p><p>下图展示Mutex的内存布局：</p><p><img src="http://image.huany.top/hexo/go/mutex-01-structure.png" alt></p><ul><li>Locked：表示该Mutex是否已被锁定，0：没有锁定 1：已经锁定</li><li>Woken：表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中</li><li>Starving：表示该Mutex是否处于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程阻塞超过了1ms。</li><li>Waiter：表示阻塞等待锁的协程个数，协程解锁根据次值来判断是否需要释放信号量。</li></ul><p>协程之间抢锁实际上是抢给Lockeed赋值的权利，能给Locked域置1，就说明抢锁成功。抢不到的话就阻塞等待Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。</p><p>Woken和Starving主要用于控制协程间的抢锁过程。</p><h4 id="2-2-Mutex方法"><a href="#2-2-Mutex方法" class="headerlink" title="2.2 Mutex方法"></a>2.2 Mutex方法</h4><p>Mutex对外提供两个方法。</p><ul><li>Lock()：加锁方法</li><li>UnLock()：解锁方法</li></ul><p>下面我们分析一下锁和解锁的过程，加锁分成功和失败两种情况，成功的话直接获取锁，失败后当前协程被阻塞，同样，解锁时跟据是否有阻塞协程也有两种处理。</p><h3 id="3-加解锁过程"><a href="#3-加解锁过程" class="headerlink" title="3.加解锁过程"></a>3.加解锁过程</h3><h4 id="3-1-简单加锁"><a href="#3-1-简单加锁" class="headerlink" title="3.1 简单加锁"></a>3.1 简单加锁</h4><p>假设当前只有一个协程在加锁，没有其它协程干扰，那么过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-02-lock_without_block.png" alt></p><p>加锁过程会去判断Locked标志位是否为0，如果是0则把Locked位置1，代表加锁成功。从上图可见，加锁成功后，只有Locked位置1，其他状态位没有变化。</p><h4 id="3-2-加锁被阻塞"><a href="#3-2-加锁被阻塞" class="headerlink" title="3.2 加锁被阻塞"></a>3.2 加锁被阻塞</h4><p>假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-03-lock_with_block.png" alt></p><p>从上图可看到，当协程B对一个已被占用的锁再次加锁时，Waiter计数器增加了1，此时协程B将被阻塞，直到Locked值变为0后才会被唤醒。</p><h4 id="3-3-简单解锁"><a href="#3-3-简单解锁" class="headerlink" title="3.3 简单解锁"></a>3.3 简单解锁</h4><p>假定解锁时，没有其它协程阻塞，此时解锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-04-unlock_without_waiter.png" alt></p><p>由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把Locked位置为0即可，不需要释放信号量。</p><h4 id="3-4-解锁并唤醒协程"><a href="#3-4-解锁并唤醒协程" class="headerlink" title="3.4 解锁并唤醒协程"></a>3.4 解锁并唤醒协程</h4><p>假定解锁时，有1个或多个协程阻塞，此时解锁过程如下图所示：</p><p><img src="http://image.huany.top/hexo/go/mutex-05-unlock_with_waiter.png" alt></p><p>协程A解锁过程分为两个步骤，一个把Locked位置0，而是查看Waiter&gt;0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程B把Locked位置1，于是协程B获得锁。</p><h3 id="4-自旋过程"><a href="#4-自旋过程" class="headerlink" title="4. 自旋过程"></a>4. 自旋过程</h3><p>加锁时，如果当前Locked位为1，说明该锁当前由其它协程所持有，尝试加锁的协议并不是马上转入阻塞，而是会持续探测Locked位是否变为0，这个过程即为自旋过程。</p><p>自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次被阻塞。</p><p>自旋的好处是，当加锁失败时不必立即转入阻塞。有一定机会获取到锁，这样可以避免协程的切换。</p><h4 id="4-1-什么是自旋"><a href="#4-1-什么是自旋" class="headerlink" title="4.1 什么是自旋"></a>4.1 什么是自旋</h4><p>自旋对应于CPU的”PAUSE”指令，CPU对该指令什么都不做，相当于CPU空转，对程序而言相当于sleep了一小段时间，时间非常短，当前实现是30个时钟周期。</p><p>自旋过程中会持续探测Locked是否变为0，连续两次探测间隔就是执行这些PAUSE指令，它不同于sleep，不需要将协程转为睡眠状态。</p><h4 id="4-1-自旋条件"><a href="#4-1-自旋条件" class="headerlink" title="4.1 自旋条件"></a>4.1 自旋条件</h4><p>加锁时程序会自动判断是否可以自旋，无限制的自旋将会给CPU带来巨大压力，所以判断是否可以自旋就很重要了。</p><p>自旋必须满足以下所有条件</p><ul><li>自旋次数要足够小，通常为4，即自旋最多4次</li><li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁</li><li>协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋</li><li>协程调度机制中的可运行队列必须为空，否则会延迟协程调度</li></ul><p>可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。</p><h4 id="4-2-自旋的优势"><a href="#4-2-自旋的优势" class="headerlink" title="4.2 自旋的优势"></a>4.2 自旋的优势</h4><p>自旋的优势是更充分的利用CPU，尽量避免协程切换。因为当前申请加锁的协程拥有CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。</p><h4 id="4-3-自旋的问题"><a href="#4-3-自旋的问题" class="headerlink" title="4.3 自旋的问题"></a>4.3 自旋的问题</h4><p>如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态。</p><p>为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。</p><h3 id="5-Mutex-模式"><a href="#5-Mutex-模式" class="headerlink" title="5.Ｍutex 模式"></a>5.Ｍutex 模式</h3><p>前面分析加锁和解锁过程中只关注了Waiter和Locked位的变化，现在我们看一下Starving位的作用。</p><p>每个Mutex都有两个模式，称为Normal和Starving。下面分别说明这两个模式。</p><h4 id="4-1-normal模式"><a href="#4-1-normal模式" class="headerlink" title="4.1 normal模式"></a>4.1 normal模式</h4><p>默认情况下，Mutex的模式为normal。</p><p>该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。</p><h4 id="4-2-starvation模式"><a href="#4-2-starvation模式" class="headerlink" title="4.2 starvation模式"></a>4.2 starvation模式</h4><p>自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞。</p><p>处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1。</p><h3 id="5-Woken状态"><a href="#5-Woken状态" class="headerlink" title="5. Woken状态"></a>5. Woken状态</h3><p>Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。</p><h3 id="6-为什么重复解锁要panic"><a href="#6-为什么重复解锁要panic" class="headerlink" title="6.为什么重复解锁要panic"></a>6.为什么重复解锁要panic</h3><p>可能你会想，为什么Go不能实现得更健壮些，多次执行Unlock()也不要panic？</p><p>仔细想想Unlock的逻辑就可以理解，这实际上很难做到。Unlock过程分为将Locked置为0，然后判断Waiter值，如果值&gt;0，则释放信号量。</p><p>如果多次Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。</p><h3 id="7-编程Tips"><a href="#7-编程Tips" class="headerlink" title="7. 编程Tips"></a>7. 编程Tips</h3><h4 id="7-1-使用defer避免死锁"><a href="#7-1-使用defer避免死锁" class="headerlink" title="7.1 使用defer避免死锁"></a>7.1 使用defer避免死锁</h4><p>加锁后立即使用defer对其解锁，可以有效的避免死锁。</p><h5 id="7-2-加锁和解锁应该成对出现"><a href="#7-2-加锁和解锁应该成对出现" class="headerlink" title="7.2 加锁和解锁应该成对出现"></a>7.2 加锁和解锁应该成对出现</h5><p>加锁和解锁最好出现在同一个层次的代码块中，比如一个函数。</p><p>重复解锁会引起panic，应该避免这种操作的可能性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go range</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-range/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-range/</id>
    <published>2019-07-06T07:22:37.000Z</published>
    <updated>2019-07-06T07:23:00.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map和channel等，实际使用频率非常高。</p><p>探索range的实现机制是很有意思的事情，这可能会改变你使用range的习惯。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一：切片遍历"><a href="#2-1-题目一：切片遍历" class="headerlink" title="2.1 题目一：切片遍历"></a>2.1 题目一：切片遍历</h4><p>下面函数通过遍历切片，打印切片的下标和元素值，请问性能上有没有可优化的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func RangeSlice(slice []int)&#123;</span><br><span class="line">    for index,value := range slice &#123;</span><br><span class="line">        _,_ := index,value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>函数中使用<code>for-range</code>对切片进行遍历，获取切片的下标和元素值，这里忽略函数的实际意义。</p><p>参考答案：</p><p>遍历过程中，每次迭代会对index和value进行赋值，如果数据量大或者value类型为string时，对value的赋值操作可能是多余的，可以在for-range中忽略value值，使用slice[index]引用value值。</p><h4 id="2-2-题目二：Map遍历"><a href="#2-2-题目二：Map遍历" class="headerlink" title="2.2 题目二：Map遍历"></a>2.2 题目二：Map遍历</h4><p>下面函数通过遍历Map，打印Map的key和value，请问性能上有没有可以优化的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func RangeMap(myMap map[int]string) &#123;</span><br><span class="line">    for key, _ := range myMap &#123;</span><br><span class="line">        _, _ = key, myMap[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>函数中使用for-range对map进行遍历，获取map的key值，并根据key值获取value值，这里忽略函数的实际意义。</p><p>参考答案：</p><p>函数中for-range语句中值获取key值，然后根据key值获取value值，虽然看似减少了一次赋值，但通过key值查找value值的性能可能高于赋值消耗。能否优化取决于map所存储数据结构特征、结合实际情况进行判断。</p><h4 id="2-3-题目三：动态遍历"><a href="#2-3-题目三：动态遍历" class="headerlink" title="2.3 题目三：动态遍历"></a>2.3 题目三：动态遍历</h4><p>请问如下程序是否能正常结束？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    v := []int&#123;1, 2, 3&#125;</span><br><span class="line">    for i:= range v &#123;</span><br><span class="line">        v = append(v, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释：</p><p>main()函数中定义一个切片v，通过range遍历v，遍历过程中不断向v中添加新的元素。</p><p>参考答案：</p><p>能够正常结束。循环内改变切片的长度，不影响循环次数，循环次效在循环开始前就已经确定了。</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><p>对于for-range语句的实现，可以从编译器源码中找到答案。</p><p>编译器源码 <code>gofrontend/go/statements.cc/For_range_statement::do_lower()</code> 方法中有如下注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Arrange to do a loop appropriate for the type.  We will produce</span><br><span class="line">//   for INIT ; COND ; POST &#123;</span><br><span class="line">//           ITER_INIT</span><br><span class="line">//           INDEX = INDEX_TEMP</span><br><span class="line">//           VALUE = VALUE_TEMP // If there is a value</span><br><span class="line">//           original statements</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>可见range实际上是一个C风格的循环结构。range支持数组、数组指针、切片、map和channel类型，对于不同类型有些细节上的差异。</p><h4 id="3-1-range-for-slice"><a href="#3-1-range-for-slice" class="headerlink" title="3.1 range for slice"></a>3.1 range for slice</h4><p>下面的注释解释了遍历slice的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   for_temp := range</span><br><span class="line">//   len_temp := len(for_temp)</span><br><span class="line">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">//           value_temp = for_temp[index_temp]</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>遍历slice前会先获以slice的长度len_temp作为循环次数，循环体中，每次循环会先获取元素值，如果for-range中接收index和value的话，则会对index和value进行一次赋值。</p><p>由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是没办法遍历到的。</p><p>另外，数组与数组指针的遍历过程与slice基本一致，不再赘述。</p><h4 id="3-2-range-for-map"><a href="#3-2-range-for-map" class="headerlink" title="3.2 range for map"></a>3.2 range for map</h4><p>下面的注释解释了遍历map的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   var hiter map_iteration_struct</span><br><span class="line">//   for mapiterinit(type, range, &amp;hiter); hiter.key != nil; mapiternext(&amp;hiter) &#123;</span><br><span class="line">//           index_temp = *hiter.key</span><br><span class="line">//           value_temp = *hiter.val</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>遍历map时没有指定循环次数，循环体与遍历slice类似。由于map底层实现与slice不同，map底层使用hash表实现，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。</p><h4 id="3-3-range-for-channel"><a href="#3-3-range-for-channel" class="headerlink" title="3.3 range for channel"></a>3.3 range for channel</h4><p>遍历channel是最特殊的，这是由channel的实现机制决定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   for &#123;</span><br><span class="line">//           index_temp, ok_temp = &lt;-range</span><br><span class="line">//           if !ok_temp &#123;</span><br><span class="line">//                   break</span><br><span class="line">//           &#125;</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure><p>channel遍历是依次从channel中读取数据,读取前是不知道里面有多少个元素的。如果channel中没有元素，则会阻塞等待，如果channel已被关闭，则会解除阻塞并退出循环。</p><p><strong>注</strong></p><ul><li>上述注释中index_temp实际上描述是有误的，应该为value_temp，因为index对于channel是没有意义的。</li><li>使用for-range遍历channel时只能获取一个返回值。</li></ul><h3 id="4-编程Tips"><a href="#4-编程Tips" class="headerlink" title="4.编程Tips"></a>4.编程Tips</h3><ul><li>遍历过程中可以视情况放弃接收index或value，可以在一定程度上提升性能</li><li>遍历channel时，避免channel没有数据，可能会阻塞</li><li>尽量避免遍历过程中修改原数据</li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>for-range的实现实际上是C风格的for循环</li><li>使用index、value接收range返回值会发生一次数据拷贝。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map和channel等，实际使用频率非常高。&lt;/
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go select</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-select/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-select/</id>
    <published>2019-07-06T05:14:12.000Z</published>
    <updated>2019-07-06T06:36:50.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready（即是否可读或可写），使用起来非常方便。</p><p>本章试图根据源码总结其实现原理，从而发现一些使用误区或解释一些不太常见的现象。</p><h3 id="2-热身环节"><a href="#2-热身环节" class="headerlink" title="2. 热身环节"></a>2. 热身环节</h3><h4 id="2-1-题目1"><a href="#2-1-题目1" class="headerlink" title="2.1 题目1"></a>2.1 题目1</h4><p>下面的程序输出是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        chan1 &lt;- 1</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        chan2 &lt;- 1</span><br><span class="line">        time.Sleep(5 * time.Second)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，分别向两个channel中写入一个数据就进入睡眠。select语句两个case分别检测chan1和chan2是否可读，如果都不可读则执行default语句。</p><p>参考答案：</p><p>select中各个case执行顺序是随机的，如果某个case中的channel已经ready，则执行相应的语句并退出select流程，如果所有case中的channel都未ready，则执行default中语句然后退出select流程。另外，由于启动的协程和select语句并不能保证执行顺序，所以也有可能select执行时协程还未向channel中写入数据，所以select直接执行default语句并退出，所以，以下三种输出都有可能：</p><p>可能的输出一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chan1 ready.</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><p>可能的输出二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chan2 ready</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><p>可能的输出三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">main exit.</span><br></pre></td></tr></table></figure><h4 id="2-2-题目2"><a href="#2-2-题目2" class="headerlink" title="2.2 题目2"></a>2.2 题目2</h4><p>下面的程序执行到select时会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    writeFlag := false</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if writeFlag &#123;</span><br><span class="line">                chan1 &lt;- 1</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if writeFlag &#123;</span><br><span class="line">                chan2 &lt;- 1</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程会判断一个bool类型的变量，writeFlag来决定是否要向channel中写入数据，由于writeFlag永远是false，所以实际上协程什么也没做。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</p><p>参考答案：</p><p>select会按照随机的顺序检测各case语句中cahnnel是否ready，如果某个case中的channel已经ready则执行相应的case语句然后退出select流程，如果所有的channel都未ready且没有default的话，则会阻塞等待各个channel。所以上述程序会一直阻塞。</p><h4 id="2-3-题目3"><a href="#2-3-题目3" class="headerlink" title="2.3 题目3"></a>2.3 题目3</h4><p>下面程序有什么问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    chan1 := make(chan int)</span><br><span class="line">    chan2 := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        close(chan1)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        close(chan2)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">        fmt.Println(&quot;chan1 ready.&quot;)</span><br><span class="line">    case &lt;-chan2:</span><br><span class="line">        fmt.Println(&quot;chan2 ready.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;main exit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程分别关闭两个channel。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</p><p>参考答案：</p><p>select会按照随机的顺序检测各case语句中channel是否ready，考虑到已关闭的channel也是可读的，所以上述程序中select不会阻塞，具体执行哪个case语句具是随机的。</p><h4 id="2-4-题目4"><a href="#2-4-题目4" class="headerlink" title="2.4 题目4"></a>2.4 题目4</h4><p>下面程序会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中只有一个空的select语句。</p><p>参考答案：</p><p>对于空的select语句，程序会阻塞，准确的说是当前协程会被阻塞，同时Golang自带死锁检测机制，当发现当前协程再也没有机会被唤醒时，则会panic。所以上述程序会panic。</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3.实现原理"></a>3.实现原理</h3><p>Golang实现了select时，定义了一个数据结构表示每个case语句（含default，default实际上是一种特殊的case），select执行过程类比成一个函数，函数输入case数组，输出选中的case，然后程序流转到选中的case块。</p><h4 id="3-1-case数据结构"><a href="#3-1-case数据结构" class="headerlink" title="3.1 case数据结构"></a>3.1 case数据结构</h4><p>源码包<code>src/runtime/select.go:scase</code>定义了表示case语句的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type scase struct &#123;</span><br><span class="line">    c       *hchan      // chan</span><br><span class="line">    kind    uint16</span><br><span class="line">    elem    unsafe.Pointer  // data element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scase.c 为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。scase.kind表示该case的类型，分为读channel、写channel和default，三种类型分别由常量定义：</p><ul><li>caseRecv：case语句中尝试读取scase.c中的数据；</li><li>caseSend：case语句中尝试向scase.c中写入数据</li><li>caseDefault：default语句</li></ul><p>scase.elem 表示缓冲区地址，根据scase.kind的不同，有不同用途：</p><ul><li>scase.kind == caseRecv：scase.elem表示读出channel的数据存放地址；</li><li>scase.kind == caseSend：scase.elem表示将要写入channel的数据存放地址；</li></ul><h4 id="3-2-select实现逻辑"><a href="#3-2-select实现逻辑" class="headerlink" title="3.2 select实现逻辑"></a>3.2 select实现逻辑</h4><p>源码包<code>src/runtime/select.go:selectgo()</code>定义了select选择case的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase,order0 *uint16,ncases int)(int,bool)</span><br></pre></td></tr></table></figure><p>函数参数：</p><ul><li>cas为scase数组的首地址，selectgo()就是从这些scase中找出一个返回。</li><li>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder<ul><li>pollorder：每次selectgo执行都会把scase序列打乱，以达到随机检测case的目的。</li><li>lockorder：所有case语句中channel序列，以达到去重防止对channel加锁时重复加锁的目的</li></ul></li><li>ncase表示scase数据的长度</li></ul><p>函数返回值：</p><ul><li>1.int：选中case的编号，这个case编号和代码一致</li><li>2.bool：是否成功从channel中读取了数据，如果选中的case是从channel中读数据，则该返回值表示是否读取成功。</li></ul><p>selectgo实现的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func selectgo(cas0 *scase,order *uint16,ncase int) (int,bool)&#123;</span><br><span class="line">    //1.锁定scase语句中所有的channel</span><br><span class="line">    //2.按照随机顺序检测scase中的channel是否ready</span><br><span class="line">    //  2.1 如果case可读，则读取channel中数据，解锁所有的channel,然后返回(case index,true)</span><br><span class="line">    //  2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index,false)</span><br><span class="line">    //  2.3 所有case都未ready,则解锁所有的channel，然后返回(default index,false)</span><br><span class="line">    //3.所有case都未ready，且没有default语句</span><br><span class="line">    //  3.1将当前协程加入到所有channel的等待队列</span><br><span class="line">    //  3.2当前协程转入阻塞，等待被唤醒</span><br><span class="line">    //4.唤醒后返回channel对应case index</span><br><span class="line">    //  4.1 如果是读操作，解锁所有的channel，然后返回(case index,true)</span><br><span class="line">    //  4.2 如果是写操作，解锁所有的channel，然后返回(case index,false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别说明：</p><p>对于读channel的case来说，如<code>case elem,ok := &lt;- chan1：</code>，如果channel有可能被其它协程关闭的情况下，一定要检测是否读取成功，因为close的channel也有可能返回，此时ok==false。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>select语句中除default外，每个case操作一个channel，要么读要么写</li><li>select语句中除default外，各case执行顺序是随机的</li><li>select语句中如果没有default语句，则会阻塞等待任一case</li><li>select语句中读操作要判断是否成功读取，关闭的channel也可以读取。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready（即是否可读或可
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go defer</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-defer/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-defer/</id>
    <published>2019-07-06T02:25:32.000Z</published>
    <updated>2019-07-06T05:01:20.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前，再把延迟函数取出并执行。</p><p>为了方便描述，我们把创建defer的函数称为主函数，defer语句后面的函数称为延迟函数。</p><p>延迟函数可能有输入参数，这些参数可能来源于定义defer的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为，这些场景下，如果不了解defer的规则很容易出错。</p><p>其实官方说明的defer的三个原则很清楚，本节试图汇总defer的使用场景并做简单说明。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><p>下面函数输出结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncParameter() &#123;</span><br><span class="line">    var aInt = 1</span><br><span class="line"></span><br><span class="line">    defer fmt.Println(aInt)</span><br><span class="line"></span><br><span class="line">    aInt = 2</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目说明：</p><p>函数deferFuncParameter()定义一个整型变量并初始化为1，然后使用defer语句打印出变量值，最后修改变量值为2.</p><p>参考答案：</p><p>输出1。延迟函数fmt.Println(aInt)的参数在defer语句出现时就已经确定了，所以无论后面如何修改aInt变量都不会影响延迟函数。</p><h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><p>下面程序输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func printArray(array *[3]int) &#123;</span><br><span class="line">    for i := range array &#123;</span><br><span class="line">        fmt.Println(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func deferFuncParameter() &#123;</span><br><span class="line">    var aArray = [3]int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">    defer printArray(&amp;aArray)</span><br><span class="line"></span><br><span class="line">    aArray[0] = 10</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    deferFuncParameter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>函数deferFuncParameter()定义一个数组，通过defer延迟函数printArray()的调用，最后修改数组第一个元素。printArray()函数接受数组的指针并把数组全部打印出来。</p><p>参考答案：</p><p>输出10、2、3三个值。延迟函数printArray()的参数在defer语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在return语句之前，所以对数组的最终修改值会被打印出来。</p><h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>下面函数输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncReturn() (result int) &#123;</span><br><span class="line">    i := 1</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       result++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>函数拥有一个具名返回值result，函数内部声明一个变量i，defer指定一个延迟函数，最后返回变量i。延迟函数中递增result。</p><p>参考答案：</p><p>函数输出2。函数的return语句并不是原子的，实际执行分为设置返回值–&gt;ret，defer语句实际执行在返回前，即拥有defer的函数返回过程是：设置返回值–&gt;执行defer–&gt;ret。所以return语句先把result设置为i的值，即1，defer语句中又把result递增1，所以最终返回2。</p><h3 id="3-defer规则"><a href="#3-defer规则" class="headerlink" title="3. defer规则"></a>3. defer规则</h3><p>Golang官方博客里总结了defer的行为规则，只有三条，我们围绕这三条进行说明。</p><h4 id="3-1-规则一：延迟函数的参数在defer语句出现时就已经确定下来了"><a href="#3-1-规则一：延迟函数的参数在defer语句出现时就已经确定下来了" class="headerlink" title="3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了"></a>3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了</h4><p>官方给出了一个例子，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a()&#123;</span><br><span class="line">    i := 0 </span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer语句中的fmt.Println()参数i值在defer出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响fmt.Println()函数的执行，仍然打印”0”。</p><p>注意：对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，defer后面的语句对变量的修改可能会影响延迟函数。</p><h4 id="3-2-规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行"><a href="#3-2-规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行" class="headerlink" title="3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行"></a>3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行</h4><p>这个规则很好理解，定义defer类似于入栈操作，执行defer类似于出栈操作。</p><p>设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再跟据A资源申请B资源，跟据B资源申请C资源，即申请顺序是:A–&gt;B–&gt;C，释放时往往又要反向进行。这就是把deffer设计成LIFO(Last In First Out)的原因。</p><p>每申请到一个用完需要释放的资源时，立即定义一个defer来释放资源是个很好的习惯。</p><h4 id="3-3-规则三：延迟函数可能操作主函数的具名返回值"><a href="#3-3-规则三：延迟函数可能操作主函数的具名返回值" class="headerlink" title="3.3 规则三：延迟函数可能操作主函数的具名返回值"></a>3.3 规则三：延迟函数可能操作主函数的具名返回值</h4><p>定义defer的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer所作用的函数，即延迟函数可能会影响到返回值。</p><p>若要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回的就足够了。</p><h6 id="3-1-函数返回过程"><a href="#3-1-函数返回过程" class="headerlink" title="3.1 函数返回过程"></a>3.1 函数返回过程</h6><p>有一个事实必须要了解，关键字<code>return</code>不是一个原子操作，实际上<code>return</code>只代理汇编指令<code>ret</code>，即将跳转程序执行。比如语句<code>return i</code>，实际上分两步进行，即将<code>i</code>存入栈中作为返回值，然后执行跳转，而defer的执行时机正是<strong>跳转前</strong>，所示说defer执行时还是有机会操作返回值的。</p><p>举个实际的例子进行说明这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deferFuncReturn() (result int) &#123;</span><br><span class="line">    i := 1</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       result++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的return语句可以拆分成下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = i</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>而延迟函数的执行正是在return之前，即加入defer后执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = i</span><br><span class="line">result ++ </span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>所以上面函数实际返回i++值。</p><p>关于主函数有不同的返回方式，但返回机制就如上机介绍所说，只要把return语句拆开都可以很好的理解，下面分别举例说明</p><h5 id="3-1-1-主函数拥有匿名返回值，返回字面值"><a href="#3-1-1-主函数拥有匿名返回值，返回字面值" class="headerlink" title="3.1.1 主函数拥有匿名返回值，返回字面值"></a>3.1.1 主函数拥有匿名返回值，返回字面值</h5><p>一个主函数拥有一个匿名的返回值，返回时使用字面值，比如返回”1”、”2”、”Hello”这样的值，这种情况下defer语句是无法操作返回值的。</p><p>一个返回字面值的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() int &#123;</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的return语句，直接把1写入栈中作为返回值，延迟函数无法操作该返回值，所以就无法影响返回值。</p><h5 id="3-3-2-主函数拥有匿名返回值，返回变量"><a href="#3-3-2-主函数拥有匿名返回值，返回变量" class="headerlink" title="3.3.2 主函数拥有匿名返回值，返回变量"></a>3.3.2 主函数拥有匿名返回值，返回变量</h5><p>一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下defer语句可以引用到返回值，但不会改变返回值。</p><p>一个返回本地变量的函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() int &#123;</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，返回一个局部变量，同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量为”anony”，上面的返回语句可以拆分成以下过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anony = i</span><br><span class="line">i++</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>由于i是整型，会将值拷贝给anony，所以defer语句中修改i值，对函数返回值不造成影响。</p><h5 id="3-3-3-主函数拥有具名返回值"><a href="#3-3-3-主函数拥有具名返回值" class="headerlink" title="3.3.3 主函数拥有具名返回值"></a>3.3.3 主函数拥有具名返回值</h5><p>主函声明语句中带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。如果defer语句操作该返回值，可能会改变返回结果。</p><p>一个影响函返回值的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func foo() (ret int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        ret++</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数拆解出来，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = 0</span><br><span class="line">ret++</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>函数真正返回前，在defer中对返回值做了+1操作，所以函数最终返回1。</p><h3 id="4-defer实现原理"><a href="#4-defer实现原理" class="headerlink" title="4. defer实现原理"></a>4. defer实现原理</h3><p>本节我们尝试了解一些defer的实现机制。</p><h4 id="4-1-defer数据结构"><a href="#4-1-defer数据结构" class="headerlink" title="4.1 defer数据结构"></a>4.1 defer数据结构</h4><p>源码包<code>src/src/runtime/runtime2.go:_defer</code>定义了defer的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type _defer struct &#123;</span><br><span class="line">    sp      uintptr   //函数栈指针</span><br><span class="line">    pc      uintptr   //程序计数器</span><br><span class="line">    fn      *funcval  //函数地址</span><br><span class="line">    link    *_defer   //指向自身结构的指针，用于链接多个defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道defer后面一定要接一个函数的，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等等。</p><p>与函数不同的一点是它含有一个指针，可用于指向另一个defer，每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer插入到单链表表头，每次执行defer时就从单链表表头取出一个defer执行。</p><p>下图展示多个defer被链接的过程：</p><p><img src="http://image.huany.top/hexo/go/defer.jpg" alt></p><p>从上图可以看到，新声明的defer总是添加到链表头部。函数返回前执行defer则是从链表首部依次取出执行。</p><p>一个goroutine可能连续调用多个函数，defer添加过程跟上述流程一致，进入函数时添加defer，离开函数时取出defer，所有即便调用多个函数，也总能保证defer是按照LIFO方式执行 的。</p><h4 id="4-2-defer的创建和执行"><a href="#4-2-defer的创建和执行" class="headerlink" title="4.2 defer的创建和执行"></a>4.2 defer的创建和执行</h4><p>源码包<code>src/runtine/panic.go</code>定义了两个方法分别用于创建defer和执行defer。</p><ul><li>deferproc()：在声明defer处调用，其将defer函数存入goroutine的链表中；</li><li>deferreturn()：在return指令，准确的将是在ret指令前调用，其将defer从goroutine链表中取出并执行。</li></ul><p>可以简单的这么理解，在编译阶段，声明defer出插入了deferproc()，在函数return前插入了deferreturn()。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>defer定义的延迟函数参数在defer语句出来时就已经确定下来了</li><li>defer定义顺序与执行顺序相反</li><li>return不是原子操作，执行过程是：保存返回值（若有） –&gt; 执行defer –&gt; 执行return跳转</li><li>申请资源后立即使用defer关闭资源是好习惯</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前，再把延迟函数取出并执行。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go iota</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-iota/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-iota/</id>
    <published>2019-07-05T16:29:29.000Z</published>
    <updated>2019-07-05T16:30:10.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>我们知道iota常用于const表达式中，我们还知道其值是从零开始的，const声明块中每增加一行iota值自增1。</p><p>使用iota可以简化常量定义，但其规则必须要牢牢掌握，否则在我们阅读别人源码时可能会造成误解或障碍。本节我们尝试全面的总结其使用场景，另外花一小部分时间看一下其实现原理，从原理上把握可以更深刻的记忆这些规则。</p><h3 id="2-热身"><a href="#2-热身" class="headerlink" title="2.热身"></a>2.热身</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><p>下面常量定义源于GO源码，下面每个常量的值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Priority int</span><br><span class="line">const (</span><br><span class="line">    LOG_EMERG Priority = iota</span><br><span class="line">    LOG_ALERT</span><br><span class="line">    LOG_CRIT</span><br><span class="line">    LOG_ERR</span><br><span class="line">    LOG_WARNING</span><br><span class="line">    LOG_NOTICE</span><br><span class="line">    LOG_INFO</span><br><span class="line">    LOG_DEBUG</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>上面代码源于日志模块，定义了一组代表日志级别的常量，常量类型为Priority，实际为int类型。</p><p>参考答案：</p><p>iota初始值为0，也即LOG_EMERG值为0，下面每个常量递增1。</p><h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><p>下面代码取自Go源码，请问每个常量值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    mutexLocked = 1 &lt;&lt; iota // mutex is locked</span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexStarving</span><br><span class="line">    mutexWaiterShift = iota</span><br><span class="line">    starvationThresholdNs = 1e6</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>以上代码取自Go互斥锁Mutex的实现，用于指示各种状态位的地址偏移。</p><p>参考答案：</p><p>mutexLocked == 1；mutexWoken == 2；mutexStarving == 4；mutexWaiterShift == 3；starvationThresholdNs == 1000000。</p><h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>请问每个常量值是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1</span><br><span class="line">    bit1, mask1</span><br><span class="line">    _, _</span><br><span class="line">    bit3, mask3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>题目解释：</p><p>以上代码取自Go官方文档。</p><p>参考答案：</p><p>bit0 == 1， mask0 == 0， bit1 == 2， mask1 == 1， bit3 == 8， mask3 == 7</p><h3 id="3-规则"><a href="#3-规则" class="headerlink" title="3.规则"></a>3.规则</h3><p>很多书上或博客描述的规则是这样的： </p><ol><li>iota在const关键字出现时被重置为0 </li><li>const声明块中每新增一行iota值自增1</li></ol><p>我曾经也这么理解，看过编译器代码后发现，其实规则只有一条：</p><ul><li><strong>iota代表了const声明块的行索引（下标从0开始）</strong></li></ul><p>这样理解更贴近编译器实现逻辑，也更准确。除此之外，const声明还有个特点，即第一个常量必须指定一个表达式，后续的常量如果没有表达式，则继承上面的表达式。</p><p>下面再来根据这个规则看下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1   //const声明第0行，即iota==0</span><br><span class="line">    bit1, mask1                            //const声明第1行，即iota==1, 表达式继承上面的语句</span><br><span class="line">    _, _                                   //const声明第2行，即iota==2</span><br><span class="line">    bit3, mask3                            //const声明第3行，即iota==3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>第0行的表达式展开即bit0, mask0 = 1 &lt;&lt; 0, 1&lt;&lt;0 - 1，所以bit0 == 1，mask0 == 0；</li><li>第1行没有指定表达式继承第一行，即bit1, mask1 = 1 &lt;&lt; 1, 1&lt;&lt;1 - 1，所以bit1 == 2，mask1 == 1；</li><li>第2行没有定义常量</li><li>第3行没有指定表达式继承第一行，即bit3, mask3 = 1 &lt;&lt; 3, 1&lt;&lt;3 - 1，所以bit0 == 8，mask0 == 7；</li></ul><h3 id="4-编译原理"><a href="#4-编译原理" class="headerlink" title="4.编译原理"></a>4.编译原理</h3><p>const块中每一行在GO中使用spec数据结构描述，spec声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// A ValueSpec node represents a constant or variable declaration</span><br><span class="line">// (ConstSpec or VarSpec production).</span><br><span class="line">//</span><br><span class="line">ValueSpec struct &#123;</span><br><span class="line">    Doc     *CommentGroup // associated documentation; or nil</span><br><span class="line">    Names   []*Ident      // value names (len(Names) &gt; 0)</span><br><span class="line">    Type    Expr          // value type; or nil</span><br><span class="line">    Values  []Expr        // initial values; or nil</span><br><span class="line">    Comment *CommentGroup // line comments; or nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只关注ValueSpec.Names， 这个切片中保存了一行中定义的常量，如果一行定义N个常量，那么ValueSpec.Names切片长度即为N。</p><p>const块实际上是spec类型的切片，用于表示const中的多行。</p><p>所以编译期间构造常量时的伪算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for iota, spec := range ValueSpecs &#123;</span><br><span class="line">    for i, name := range spec.Names &#123;</span><br><span class="line">        obj := NewConst(name, iota...) //此处将iota传入，用于构造常量</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;我们知道iota常用于const表达式中，我们还知道其值是从零开始的，const声明块中每增加一行iota值自增1。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go channel 低层源码剖析</title>
    <link href="https://meichaofan.github.io/2019/07/06/go-channel/"/>
    <id>https://meichaofan.github.io/2019/07/06/go-channel/</id>
    <published>2019-07-05T16:00:48.000Z</published>
    <updated>2019-07-05T16:01:30.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>channel是Golang在语言层面提供的goroutine间通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统方法来解决。</p><p>本章，从源码角度分析channel的实现机制，实际上这部分源码非常简单易读。</p><h3 id="chan数据结构"><a href="#chan数据结构" class="headerlink" title="chan数据结构"></a>chan数据结构</h3><p><code>src/runtine/chan.go:hchan</code>定义了channel的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">    qcount   uint           // 当前队列中剩余元素个数</span><br><span class="line">    dataqsiz uint           // 环形队列长度，即可以存放的元素个数</span><br><span class="line">    buf      unsafe.Pointer // 环形队列指针</span><br><span class="line">    elemsize uint16         // 每个元素的大小</span><br><span class="line">    closed   uint32         // 标识关闭状态</span><br><span class="line">    elemtype *_type // 元素类型</span><br><span class="line">    sendx    uint   // 队列下标，指示元素写入时存放到队列中的位置</span><br><span class="line">    recvx    uint   // 队列下标，指示元素从队列的该位置读出</span><br><span class="line">    recvq    waitq  // 等待读消息的goroutine队列</span><br><span class="line">    sendq    waitq  // 等待写消息的goroutine队列</span><br><span class="line">    lock mutex      // 互斥锁，chan不允许并发读写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。</p><h5 id="2-1-环形队列"><a href="#2-1-环形队列" class="headerlink" title="2.1 环形队列"></a>2.1 环形队列</h5><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。</p><p>下图展示了一个可缓存6个元素的channel示意图：</p><p><img src="http://image.huany.top/hexo/go/chan-01-circle_queue.png" alt></p><ul><li>datasiz 指示了队列长度为6，即可缓存6个元素；</li><li>buf指向队列的内存，队列中还剩余两个元素；</li><li>qcount表示队列中还有两个元素；</li><li>sendx指示后续写入的数据存储的位置，取值[0,6)</li><li>recvx指示从该位置读取数据，取值[0,6)</li></ul><h4 id="2-2-等待队列"><a href="#2-2-等待队列" class="headerlink" title="2.2 等待队列"></a>2.2 等待队列</h4><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前的goroutine会被阻塞。</p><p>被阻塞的goroutine会被挂在channel的等待队列中；</p><ul><li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li><li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li></ul><p>下图展示了一个没有缓冲区的channel，有几个gouroutine阻塞等待读数据：</p><p><img src="http://image.huany.top/hexo/go/chan-02-wait_queue.png" alt></p><p><strong>注意</strong>，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p><h4 id="2-3-类型信息"><a href="#2-3-类型信息" class="headerlink" title="2.3 类型信息"></a>2.3 类型信息</h4><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p><ul><li>elemtype代表类型，用于数据传递过程中的赋值；</li><li>elemsize代表类型大小，用于在buf中定位元素位置。</li></ul><h4 id="2-4-锁"><a href="#2-4-锁" class="headerlink" title="2.4 锁"></a>2.4 锁</h4><p>一个channel同时仅允许被一个goroutine读写</p><h3 id="3-channel读写"><a href="#3-channel读写" class="headerlink" title="3.channel读写"></a>3.channel读写</h3><h4 id="3-1-创建channel"><a href="#3-1-创建channel" class="headerlink" title="3.1 创建channel"></a>3.1 创建channel</h4><p>创建channel的过程实际上是初始化hchan结构，其中类型信息和缓冲区长度由<code>make</code>语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p><p>创建channel的伪代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan&#123;</span><br><span class="line">    var c *hchan</span><br><span class="line">    c = new(hchan)</span><br><span class="line">    c.buf = malloc(元素类型*size)</span><br><span class="line">    c.elemsize = 元素类型大小</span><br><span class="line">    c.elemtype = 元素类型</span><br><span class="line">    c.dataqsiz size</span><br><span class="line">    </span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-向channel写数据"><a href="#3-2-向channel写数据" class="headerlink" title="3.2 向channel写数据"></a>3.2 向channel写数据</h4><p>向一个channel中写数据简单过程如下：</p><ul><li>1.如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后把该G唤醒，结束发送过程</li><li>2.如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程；</li><li>3.如果缓冲区没有空余位置，将待发数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒。.</li></ul><p>简单流程图如下：</p><p><img src="http://image.huany.top/hexo/go/chan-03-send_data.png" alt></p><h4 id="3-3-从channel读数据"><a href="#3-3-从channel读数据" class="headerlink" title="3.3 从channel读数据"></a>3.3 从channel读数据</h4><p>从一个channel读数据简单过程如下：</p><ul><li>1.如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li><li>2.如果等待发送队列sendq不为空，缓冲区已满，从缓冲区首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li><li>3.如果缓冲区有数据，则从缓冲区取出数据，结束读取过程；</li><li>4.将当前的goroutine加入recvq，进入睡眠，等待被写goroutine唤醒。</li></ul><p><img src="http://image.huany.top/hexo/go/chan-04-recieve_data.png" alt></p><h4 id="3-4-关闭channel"><a href="#3-4-关闭channel" class="headerlink" title="3.4 关闭channel"></a>3.4 关闭channel</h4><p>关闭channel时会把revq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但是这些G会panic。</p><p>除此之外，panic出现的常见场景还有：</p><ul><li>1.关闭值为nil的channel</li><li>2.关闭已经被关闭的channel</li><li>3.向已经关闭的channel写数据</li></ul><h3 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4.常见用法"></a>4.常见用法</h3><h4 id="4-1-单向channel"><a href="#4-1-单向channel" class="headerlink" title="4.1 单向channel"></a>4.1 单向channel</h4><p>顾名思义，单向channel指只能用于发送或接收数据，实际上也没有单向channel。</p><p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p><ul><li>func readChan(chanName &lt;-chan int)：通过形参限定函数内部只能从channel中读取数据</li><li>func writeChan(chanName chan&lt;- int)：通过形参限定函数内部只能往channel中写数据</li></ul><p>一个简单的示例程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func readChan(chanName &lt;-chan int) &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeChan(chanName chan&lt;- int) &#123;</span><br><span class="line">    chanName &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var mychan = make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来读。</p><h4 id="4-2-select"><a href="#4-2-select" class="headerlink" title="4.2 select"></a>4.2 select</h4><p>使用select可以监控多个channel，比如监控多个channel，当其中某一个channel有数据的话，就从中读出数据。</p><p>一个简单的示例程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func addNumberToChan(chanName chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        chanName &lt;- 1</span><br><span class="line">        time.Sleep(1 * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var chan1 = make(chan int, 10)</span><br><span class="line">    var chan2 = make(chan int, 10)</span><br><span class="line"></span><br><span class="line">    go addNumberToChan(chan1)</span><br><span class="line">    go addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(&quot;Get element from chan1: %d\n&quot;, e)</span><br><span class="line">        case e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(&quot;Get element from chan2: %d\n&quot;, e)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Printf(&quot;No element in chan1 and chan2.\n&quot;)</span><br><span class="line">            time.Sleep(1 * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go run main.go</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: 1</span><br><span class="line">Get element from chan1: 1</span><br><span class="line">No element in chan1 and chan2.</span><br></pre></td></tr></table></figure><p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的。</p><p>通过这个示例想说的是：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p><h4 id="4-3-range"><a href="#4-3-range" class="headerlink" title="4.3 range"></a>4.3 range</h4><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func chanRange(chanName chan int) &#123;</span><br><span class="line">    for e := range chanName &#123;</span><br><span class="line">        fmt.Printf(&quot;Get element from chan: %d\n&quot;, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;channel是Golang在语言层面提供的goroutine间通信方式，比Unix管道更易用也更轻便。channel主
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go map原理剖析</title>
    <link href="https://meichaofan.github.io/2019/07/01/go-map/"/>
    <id>https://meichaofan.github.io/2019/07/01/go-map/</id>
    <published>2019-07-01T14:00:04.000Z</published>
    <updated>2019-07-01T15:41:59.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-map数据结构"><a href="#1-map数据结构" class="headerlink" title="1. map数据结构"></a>1. map数据结构</h3><p>golang的map的使用了哈希表作为低层实现，一个哈希表里可以有多个哈希表节点，也即<strong>bucket</strong>，而每个bucket保存了map中的一个或一组键值对。</p><p>map的数据结构由<code>runtime/map.go:hmap</code>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">    count   int //当前保存的元素个数</span><br><span class="line">    ...</span><br><span class="line">    B       uint8   //指示bucket数组的大小</span><br><span class="line">    ...</span><br><span class="line">    buckets unsafe.Pointer  //bucket数组指针，数组的大小为2^B</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示一个拥有4个bucket的map:</p><p><img src="http://image.huany.top/hexo/go/map-01-struct.png" alt></p><p>本例中，<code>hmap.B=2</code>，而hmap.buckets的长度是2^B为4，元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p><p><code>bucket</code>很多时候会翻译成桶，所谓的<code>哈希桶</code>实际上就是bucket。</p><h3 id="2-bucket数据结构"><a href="#2-bucket数据结构" class="headerlink" title="2. bucket数据结构"></a>2. bucket数据结构</h3><p>bucket数据结构由<code>runtime/map.go:bmap定义</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [8]uint8 //存储哈希值的高8位</span><br><span class="line">    data    byte[1]  //key value数据:key/key/key/.../value/value/value...</span><br><span class="line">    overflow *bmap   //溢出bucket的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket可以存储8个键值对。</p><ul><li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li><li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li><li>overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li></ul><p><strong>注意</strong>：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p><p>下图展示bucket存放8个key-value对：</p><p><img src="http://image.huany.top/hexo/go/map-02-struct_sketch.png" alt></p><h3 id="3-哈希冲突"><a href="#3-哈希冲突" class="headerlink" title="3. 哈希冲突"></a>3. 哈希冲突</h3><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。 由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p><p>下图展示产生冲突后的map：</p><p><img src="http://image.huany.top/hexo/go/map-03-struct_sketch.png" alt></p><p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。</p><h3 id="4-负载因子"><a href="#4-负载因子" class="headerlink" title="4. 负载因子"></a>4. 负载因子</h3><p>负载因子是衡量一个哈希表冲突情况，公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 键数量 / bucket数量</span><br></pre></td></tr></table></figure><p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p><p>哈希表需要将负载因子控制在一个合适的大小，超过阈值需要进行refresh，也即键值对重新组织：</p><ul><li>哈希因子过小，说明空间利用率低</li><li>哈希因子过大，说明冲突严重，存取效率低</li></ul><p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p><h3 id="5-渐进式扩容"><a href="#5-渐进式扩容" class="headerlink" title="5. 渐进式扩容"></a>5. 渐进式扩容</h3><h4 id="5-1-扩容的前提条件"><a href="#5-1-扩容的前提条件" class="headerlink" title="5.1 扩容的前提条件"></a>5.1 扩容的前提条件</h4><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。 触发扩容的条件有二个： 1. 负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。 2. overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</p><h4 id="5-2-增量扩容"><a href="#5-2-增量扩容" class="headerlink" title="5.2 增量扩容"></a>5.2 增量扩容</h4><p>当负载因子过大时，就新建一个buckets，新的buckets长度是原来的2倍，然后旧buckets数据搬迁到新的buckets。 考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p><p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p><p><img src="http://image.huany.top/hexo/go/map-04-struct_sketch.png" alt></p><p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p><p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p><p><img src="http://image.huany.top/hexo/go/map-05-struct_sketch.png" alt></p><p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。 后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p><p>搬迁完成后的示意图如下：</p><p><img src="http://image.huany.top/hexo/go/map-06-struct_sketch.png" alt></p><p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。</p><h4 id="5-3-等量扩容"><a href="#5-3-等量扩容" class="headerlink" title="5.3 等量扩容"></a>5.3 等量扩容</h4><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。 在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p><p><img src="http://image.huany.top/hexo/go/map-07-struct_sketch.png" alt></p><p>上图可见，overflow的buckt中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p><h3 id="6-查找过程"><a href="#6-查找过程" class="headerlink" title="6. 查找过程"></a>6. 查找过程</h3><p>查找过程如下：</p><ol><li>跟据key值算出哈希值 </li><li>取哈希值低位与hmpa.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ol><p><strong>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</strong></p><h3 id="7-插入过程"><a href="#7-插入过程" class="headerlink" title="7. 插入过程"></a>7. 插入过程</h3><p>新员素插入过程如下： </p><ol><li>跟据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值 </li><li>如果没找到将key，将key插入</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-map数据结构&quot;&gt;&lt;a href=&quot;#1-map数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. map数据结构&quot;&gt;&lt;/a&gt;1. map数据结构&lt;/h3&gt;&lt;p&gt;golang的map的使用了哈希表作为低层实现，一个哈希表里可以有多个哈希表节点
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go string低层原理</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-string/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-string/</id>
    <published>2019-06-30T14:19:46.000Z</published>
    <updated>2019-06-30T15:09:45.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="string标准概念"><a href="#string标准概念" class="headerlink" title="string标准概念"></a>string标准概念</h3><p>Go标准库<code>builtin</code>给出了所有内置类型的定义。源码位于<code>src/builtin/builtin.go</code>，其中关于string的描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="line">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="line">// not nil. Values of string type are immutable.</span><br><span class="line">type string string</span><br></pre></td></tr></table></figure><p>所以string是8比特字节的集合，通常但不一定是UTF-8编码的文本。</p><p>另外还提到了两点，非常重要：</p><ul><li>string可以为空（长度为0），但不会是nil；</li><li>string对象是不可修改的。</li></ul><h3 id="string-数据结构"><a href="#string-数据结构" class="headerlink" title="string 数据结构"></a>string 数据结构</h3><p>源码包<code>src/runtime/string.go:stringStruct</code>定义了string的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据结构很简单：</p><ul><li>stringStruct.str: 字符串首字母地址；</li><li>stringStruct.len：字符串的长度；</li></ul><p>string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换。这个后面再详细介绍。</p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>如下代码所示，可以声明一个string变量并赋予初值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str string</span><br><span class="line">str = &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>字符串构建过程中先根据字符串构建stringStruct，再转换成string。转换的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func gostringnocopy(str *byte) string &#123; // 跟据字符串地址构建string</span><br><span class="line">    ss := stringStruct&#123;str: unsafe.Pointer(str), len: findnull(str)&#125; // 先构造stringStruct</span><br><span class="line">    s := *(*string)(unsafe.Pointer(&amp;ss))                             // 再将stringStruct转换成string</span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string在runtime包中就是stringStruct，对外呈现叫做string。</p><h4 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h4><p>byte切片可以很方便的转换成string，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetStringBySlice(s []byte) string &#123;</span><br><span class="line">    return string(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这种转换需要一次内存拷贝。</p><p>转换过程如下： </p><ol><li>跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；</li><li>构建string（string.str = p；string.len = len；） </li><li>拷贝数据(切片中数据拷贝到新申请的内存空间)</li></ol><p>转换示意图：<br><img src="http://image.huany.top/hexo/go/string-01-slice2string.png" alt></p><h4 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h4><p>string也可以很方便的转成byte切片，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func GetSliceByString(str string) []byte &#123;</span><br><span class="line">    return []byte(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string转换成byte切片，也需要一次内存拷贝，其过程如下：</p><ul><li>申请切片内存空间</li><li>将string拷贝到切片</li></ul><p>转换示意图：<br><img src="http://image.huany.top/hexo/go/string-02-string2slice.png" alt></p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>字符串可以很方便的拼接，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Str1&quot; + &quot;Str2&quot; + &quot;Str3&quot;</span><br></pre></td></tr></table></figure><p>即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。</p><p>一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。</p><p>字符串拼接伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func concatstrings(a []string) string &#123; // 字符串拼接</span><br><span class="line">    length := 0        // 拼接后总的字符串长度</span><br><span class="line"></span><br><span class="line">    for _, str := range a &#123;</span><br><span class="line">        length += length(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间</span><br><span class="line"></span><br><span class="line">    for _, str := range a &#123;</span><br><span class="line">        copy(b, str)    // string无法修改，只能通过切片修改</span><br><span class="line">        b = b[len(str):]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为string是无法直接修改的，所以这里使用rawstring()方法初始化一个指定大小的string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了string。</p><p>rawstring()源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func rawstring(size int) (s string, b []byte) &#123; // 生成一个新的string，返回的string和切片共享相同的空间</span><br><span class="line">    p := mallocgc(uintptr(size), nil, false)</span><br><span class="line"></span><br><span class="line">    stringStructOf(&amp;s).str = p</span><br><span class="line">    stringStructOf(&amp;s).len = size</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么字符串不允许修改？"><a href="#为什么字符串不允许修改？" class="headerlink" title="为什么字符串不允许修改？"></a>为什么字符串不允许修改？</h4><p>像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。</p><p>因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。</p><h4 id="byte转换成string一定会拷贝内存吗？"><a href="#byte转换成string一定会拷贝内存吗？" class="headerlink" title="[]byte转换成string一定会拷贝内存吗？"></a>[]byte转换成string一定会拷贝内存吗？</h4><p>byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。</p><p>比如，编译器会识别如下临时场景：</p><ul><li>使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；</li><li>字符串拼接，如”&lt;” + “string(b)” + “&gt;”；</li><li>字符串比较：string(b) == “foo”</li></ul><p>因为是临时把byte切片转换成string，也就避免了因byte切片内容改变而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。</p><h4 id="string和-byte如何取舍？"><a href="#string和-byte如何取舍？" class="headerlink" title="string和[]byte如何取舍？"></a>string和[]byte如何取舍？</h4><p>string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要跟据实际应用场景来选择。</p><p>string 擅长的场景：</p><ul><li>需要字符串比较的场景；</li><li>不需要nil字符串的场景；</li></ul><p>[]byte擅长的场景：</p><ul><li>修改字符串的场景，尤其是修改粒度为1个字节</li><li>函数返回值，需要用nil表示含义的场景；</li><li>需要切片操作的场景；</li></ul><p>虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;string标准概念&quot;&gt;&lt;a href=&quot;#string标准概念&quot; class=&quot;headerlink&quot; title=&quot;string标准概念&quot;&gt;&lt;/a&gt;string标准概念&lt;/h3&gt;&lt;p&gt;Go标准库&lt;code&gt;builtin&lt;/code&gt;给出了所有内置类型的定义。
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go slice实现原理</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-slice/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-slice/</id>
    <published>2019-06-30T09:27:15.000Z</published>
    <updated>2019-06-30T13:20:57.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>Slice又称为动态数组，低层依托于数组实现。可以方便的进行扩容，传递等。实际使用过程中，比数组更灵活。</p><h3 id="2-Slice实现原理"><a href="#2-Slice实现原理" class="headerlink" title="2 Slice实现原理"></a>2 Slice实现原理</h3><p>Slice依托于数组实现，低层数组对用户屏蔽，在低层数组容量不足时可以实现自动重分配并生成新的Slice。</p><h3 id="2-1-Slice的数据结构"><a href="#2-1-Slice的数据结构" class="headerlink" title="2.1 Slice的数据结构"></a>2.1 Slice的数据结构</h3><p>源码包中<code>src/runtime/slice.go</code>定义了Slice的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type slice struct&#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    len int</span><br><span class="line">    cap int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构看，slice其实就是一个结构体，array指针指向低层数组，len表示切片长度，cap表示低层数组容量。</p><h3 id="2-2-使用make创建Slice"><a href="#2-2-使用make创建Slice" class="headerlink" title="2.2 使用make创建Slice"></a>2.2 使用make创建Slice</h3><p>使用<strong>make</strong>关键字创建Slice时，可以同时制定长度和容量，创建时低层会分配一个数组，数组的长度即容量。</p><p>例如，语句 <code>slice:=make([]int,5,10)</code>所创建的slice，结构如下图所示:</p><p><img src="http://image.huany.top/hexo/go/make_slice_01.png" alt></p><p>该Slice的长度为5，可以使用slice[0]~slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。</p><h3 id="2-3-使用数组创建Slice"><a href="#2-3-使用数组创建Slice" class="headerlink" title="2.3 使用数组创建Slice"></a>2.3 使用数组创建Slice</h3><p>使用数组来创建Slice时，Slice将于原数组共用一部分内存。例如，语句<code>slice:=array[5:7]</code>所创建的Slice，结构如下图所示:</p><p><img src="http://image.huany.top/hexo/go/make_slice_02.jpg" alt></p><p>切片从数组array[5]开始，到数组array[7]结束（不含array[7]）,即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5。</p><p>数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。</p><h3 id="2-4-Slice扩容"><a href="#2-4-Slice扩容" class="headerlink" title="2.4 Slice扩容"></a>2.4 Slice扩容</h3><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</p><p>例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如图所示：</p><p><img src="http://image.huany.top/hexo/go/make_slice_03.jpg" alt></p><p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。</p><p>扩容容量的选择遵循以下规则：</p><ul><li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li><li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li></ul><p>使用append()向Slice添加一个元素的实现步骤如下：</p><ol><li>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</li><li>原Slice容量不够，则将Slice先扩容，扩容后得到新Slice</li><li>将新元素追加进新Slice，Slice.len++，返回新的Slice。</li></ol><h3 id="2-5-Slice-Copy"><a href="#2-5-Slice-Copy" class="headerlink" title="2.5 Slice Copy"></a>2.5 Slice Copy</h3><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。也就是说，copy过程中不会发生扩容。</p><h3 id="2-6-特殊切片"><a href="#2-6-特殊切片" class="headerlink" title="2.6 特殊切片"></a>2.6 特殊切片</h3><p>跟据数组或切片生成新的切片一般使用<code>slice := array[start:end]</code>方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p><p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := make([]int, 5, 10)</span><br><span class="line">sliceB := sliceA[0:5]</span><br></pre></td></tr></table></figure><p>根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即<code>slice[start:end:cap]</code>, 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sliceA := make([]int, 5, 10)  //length = 5; capacity = 10</span><br><span class="line">sliceB := sliceA[0:5]         //length = 5; capacity = 10</span><br><span class="line">sliceC := sliceA[0:5:5]       //length = 5; capacity = 5</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><ul><li>每个切片都指向一个底层数组</li><li>每个切片都保存了当前切片的长度、底层数组可用容量</li><li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li><li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li><li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣</li><li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;Slice又称为动态数组，低层依托于数组实现。可以方便的进行扩容，传递等。实际使用过程中，比数组更灵活。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-date-time-conver</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-date-time-conver/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-date-time-conver/</id>
    <published>2019-06-30T09:00:56.000Z</published>
    <updated>2019-06-30T09:03:11.046Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    datetime := &quot;2015-01-01 00:00:00&quot;  //待转化为时间戳的字符串</span><br><span class="line"></span><br><span class="line">    //日期转化为时间戳</span><br><span class="line">    timeLayout := &quot;2006-01-02 15:04:05&quot;  //转化所需模板</span><br><span class="line">    loc, _ := time.LoadLocation(&quot;Local&quot;)    //获取时区</span><br><span class="line">    tmp, _ := time.ParseInLocation(timeLayout, datetime, loc)</span><br><span class="line">    timestamp := tmp.Unix()    //转化为时间戳 类型是int64</span><br><span class="line">    fmt.Println(timestamp)</span><br><span class="line">    </span><br><span class="line">    //时间戳转化为日期</span><br><span class="line">    datetime = time.Unix(timestamp, 0).Format(timeLayout)</span><br><span class="line">    fmt.Println(datetime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1420041600</span><br><span class="line">2015-01-01 00:00:00</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go strings包介绍</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-strings-package/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-strings-package/</id>
    <published>2019-06-30T07:22:04.000Z</published>
    <updated>2019-06-30T08:35:20.455Z</updated>
    
    <content type="html"><![CDATA[<p><strong>strings</strong>包提供了操作字符串的简单函数。</p><ol><li>func Compare(a,b string) int</li><li>func Contains(s, substr string) bool</li><li>func Count(s, sep string) int</li><li>func Fields(s string) []string</li><li>func FieldsFunc(s string, f func(rune) bool) []string</li><li>func HasPrefix(s, prefix string) bool</li><li>func HasSuffix(s, suffix string) bool</li><li>func Index(s, sep string) int</li><li>func LastIndex(s,sep string) int</li><li>func Join(a []string,sep string) string</li><li>func Repeat(s string,count int) string</li><li>func Replace(s,old,new string,n int) string</li><li>func Split(s,sep string) []string</li><li>func SplitN(s,sep string, n int) []string</li><li>func ToLower(s string) string</li><li>funcc ToUpper(s string) string</li><li>func Trim(s string,cutset string) string</li></ol><hr><h3 id="1-func-Compare"><a href="#1-func-Compare" class="headerlink" title="1. func Compare"></a>1. func Compare</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Compare(a, b string) int</span><br></pre></td></tr></table></figure><p>根据字典顺序，比较两个字符串的大小。字典顺序，就是说，将多个字符串的同一位置的字符按照26个字母的顺序进行比对。a最小，z最大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b.</span><br></pre></td></tr></table></figure><h3 id="2-func-Contains"><a href="#2-func-Contains" class="headerlink" title="2. func Contains"></a>2. func Contains</h3><p>判断，原字符串是否包含子串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;foo&quot;))</span><br><span class="line">fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;bar&quot;))</span><br><span class="line">fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;&quot;))</span><br><span class="line">fmt.Println(strings.Contains(&quot;&quot;, &quot;&quot;))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="3-func-Count"><a href="#3-func-Count" class="headerlink" title="3. func Count"></a>3. func Count</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Count(s, sep string) int</span><br></pre></td></tr></table></figure><p>Count计算s中非重叠sep实例的数量。如果sep是空字符串，则Count返回1 +len(s)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（strings.Count（“cheese”，“e”））</span><br><span class="line">fmt.Println（strings.Count（“five”，“”））//在每个符文之前和之后</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="4-func-Fields"><a href="#4-func-Fields" class="headerlink" title="4. func Fields"></a>4. func Fields</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Fields(s string) []string</span><br></pre></td></tr></table></figure><p>以空格为分隔符，分割字符串s，并返回字符切片</p><h3 id="5-func-FieldsFunc"><a href="#5-func-FieldsFunc" class="headerlink" title="5. func FieldsFunc"></a>5. func FieldsFunc</h3><p>按照空格，分割字符串，同时对分割后的单个字符串，做相应的逻辑判断，如果匿名函数为真，则不返回该子串。最后返回一个字符串切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//只返回字母</span><br><span class="line">func testFieldsFunc() &#123;</span><br><span class="line">        str := &quot;- MY NAME is meichaofan JACK 1534&quot;</span><br><span class="line">            r := strings.FieldsFunc(str, func(r rune) bool &#123;</span><br><span class="line">                        return !unicode.IsLetter(r)</span><br><span class="line">                            &#125;)</span><br><span class="line">                fmt.Printf(&quot;%v&quot;, r)</span><br><span class="line">&#125;</span><br><span class="line">//output </span><br><span class="line">// [MY NAME is meichaofan JACK]</span><br></pre></td></tr></table></figure></p><h3 id="6-func-HasPrefix"><a href="#6-func-HasPrefix" class="headerlink" title="6. func HasPrefix"></a>6. func HasPrefix</h3><p>判断字符串是否以某个前缀开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testHasPrefix()  &#123;</span><br><span class="line">        str := &quot;meichaofan&quot;</span><br><span class="line">            r := strings.HasPrefix(str,&quot;mei&quot;)</span><br><span class="line">                fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">//true</span><br></pre></td></tr></table></figure><h3 id="7-func-HasSuffix"><a href="#7-func-HasSuffix" class="headerlink" title="7. func HasSuffix"></a>7. func HasSuffix</h3><p>判断字符串是否以某个后缀结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testHasSuffix()  &#123;</span><br><span class="line">        str := &quot;/home/meichaofan&quot;</span><br><span class="line">            r := strings.HasPrefix(str,&quot;/&quot;)</span><br><span class="line">                fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">//false</span><br></pre></td></tr></table></figure><h3 id="8-func-Index"><a href="#8-func-Index" class="headerlink" title="8.func Index"></a>8.func Index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Index（s，sep string）int</span><br></pre></td></tr></table></figure><p>Index 返回s中第一个sep子串的位置，如果不存在sep，返回-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（strings.Index（“chicken”，“ken”））</span><br><span class="line">fmt.Println（strings.Index（“chicken”，“dmr”））</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="9-func-LastIndex"><a href="#9-func-LastIndex" class="headerlink" title="9.func LastIndex"></a>9.func LastIndex</h3><p>返回子串最后一次出现的位置</p><h3 id="10-func-Join"><a href="#10-func-Join" class="headerlink" title="10.func Join"></a>10.func Join</h3><p>字符串切片以<strong>sep</strong>合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := []string&#123;&quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;jack&quot;&#125;</span><br><span class="line">r:= strings.Join(str,&quot;-&quot;)</span><br><span class="line">fmt.Println(r)</span><br><span class="line">//output</span><br><span class="line">//my-name-is-jack</span><br></pre></td></tr></table></figure><h3 id="11-func-Repeat"><a href="#11-func-Repeat" class="headerlink" title="11. func Repeat"></a>11. func Repeat</h3><p>重复字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（“ba”+ strings.Repeat（“na”，2））</span><br><span class="line">//output</span><br><span class="line">//banana</span><br></pre></td></tr></table></figure><h3 id="12-func-Replace"><a href="#12-func-Replace" class="headerlink" title="12. func Replace"></a>12. func Replace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Replace(s, old, new string, n int) string</span><br></pre></td></tr></table></figure><p>字符串替换，将原串中<strong>old</strong>串，替换成<strong>new</strong>串。替换次数为<strong>n</strong>次。当n&lt;0，替换次数没有限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;k&quot;, &quot;ky&quot;, 2))</span><br><span class="line">fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;oink&quot;, &quot;moo&quot;, -1))</span><br><span class="line">//output </span><br><span class="line">//oinky oinky oink</span><br><span class="line">//moo moo moo</span><br></pre></td></tr></table></figure><h3 id="13-fun-Split"><a href="#13-fun-Split" class="headerlink" title="13.fun Split"></a>13.fun Split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Split(s, sep string) []string</span><br></pre></td></tr></table></figure><p>将字符串s按照分隔符<strong>sep</strong>分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span><br><span class="line">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</span><br><span class="line">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</span><br><span class="line">[&quot;&quot;]</span><br></pre></td></tr></table></figure><h3 id="14-func-SplitN"><a href="#14-func-SplitN" class="headerlink" title="14. func SplitN"></a>14. func SplitN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SplitN（s，sep string，n int）[] string</span><br></pre></td></tr></table></figure><p>n表示要返回的子字符串数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n&gt;0:最多n个子串，最后一个子字符串是未分割的余数</span><br><span class="line">n==0:结果是nil</span><br><span class="line">n&lt;0;所有子串 等效于 split</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf（“％q \ n”，strings.SplitN（“a，b，c”，“，”，2））</span><br><span class="line">z：= strings.SplitN（“a，b，c”，“，”，0 ）</span><br><span class="line">fmt.Printf（“％q（nil =％v）\ n”，z，z == nil）</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[“a”“b，c”] </span><br><span class="line">[]（nil = true）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;strings&lt;/strong&gt;包提供了操作字符串的简单函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;func Compare(a,b string) int&lt;/li&gt;
&lt;li&gt;func Contains(s, substr string) bool&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 初始化顺序</title>
    <link href="https://meichaofan.github.io/2019/06/30/go-initialization-sequence/"/>
    <id>https://meichaofan.github.io/2019/06/30/go-initialization-sequence/</id>
    <published>2019-06-30T07:00:59.000Z</published>
    <updated>2019-06-30T07:09:28.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>先执行import包的每个文件的<strong>常量</strong>和<strong>变量</strong>，然后是<strong>init</strong>函数，最后执行<strong>main</strong>函数，当<strong>main</strong>函数执行结束程序退出。</p><p><img src="http://image.huany.top/hexo/go/go-initialization-sequence.png" alt="go 初始化顺序"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初始化顺序&quot;&gt;&lt;a href=&quot;#初始化顺序&quot; class=&quot;headerlink&quot; title=&quot;初始化顺序&quot;&gt;&lt;/a&gt;初始化顺序&lt;/h3&gt;&lt;p&gt;先执行import包的每个文件的&lt;strong&gt;常量&lt;/strong&gt;和&lt;strong&gt;变量&lt;/strong&gt;，然后
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全方位解读PHP7低层源码</title>
    <link href="https://meichaofan.github.io/2019/06/15/php7-source-code/"/>
    <id>https://meichaofan.github.io/2019/06/15/php7-source-code/</id>
    <published>2019-06-15T14:43:03.000Z</published>
    <updated>2019-06-15T14:50:10.369Z</updated>
    
    <content type="html"><![CDATA[<p>本栏从源码的角度，解析PHP7。对掌握PHP有重大帮助，望坚持更新。</p><ul><li>PHP7的新特性</li><li>基础变量与内存管理</li><li>PHP运行的生命周期</li><li>PHP代码的编译与执行</li><li>基础语法实现的细节</li><li>PHP扩展编写</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本栏从源码的角度，解析PHP7。对掌握PHP有重大帮助，望坚持更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP7的新特性&lt;/li&gt;
&lt;li&gt;基础变量与内存管理&lt;/li&gt;
&lt;li&gt;PHP运行的生命周期&lt;/li&gt;
&lt;li&gt;PHP代码的编译与执行&lt;/li&gt;
&lt;li&gt;基础语法实现的细节&lt;/
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://meichaofan.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>NumPy介绍</title>
    <link href="https://meichaofan.github.io/2019/05/31/python-numpy/"/>
    <id>https://meichaofan.github.io/2019/05/31/python-numpy/</id>
    <published>2019-05-30T16:23:41.000Z</published>
    <updated>2019-05-30T16:24:29.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>在学习深度学习时，NumPy的数组类提供了很多关于操作数组和矩阵的便捷方法。</p><hr><h2 id="2019-5-30"><a href="#2019-5-30" class="headerlink" title="2019/5/30"></a>2019/5/30</h2><h3 id="1-1-导入NumPy"><a href="#1-1-导入NumPy" class="headerlink" title="1.1 导入NumPy"></a>1.1 导入NumPy</h3><p>NumPy并不存在于标准版<code>Python</code>中，因此，首先需要导入NumPy库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br></pre></td></tr></table></figure><h3 id="1-2-生成NumPy数组"><a href="#1-2-生成NumPy数组" class="headerlink" title="1.2 生成NumPy数组"></a>1.2 生成NumPy数组</h3><p>使用<code>np.array()</code>方法。<code>np.array()</code>接受Python的<strong>列表</strong>作为参数，生成NumPy数组（<code>num.ndarray</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=np.array([1.0,2.0,3.0])</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">[1. 2. 3.]</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &apos;numpy.ndarray&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-NumPy的算术运算"><a href="#1-3-NumPy的算术运算" class="headerlink" title="1.3 NumPy的算术运算"></a>1.3 NumPy的算术运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0])</span><br><span class="line">&gt;&gt;&gt; y = np.array([2.0, 4.0, 6.0])</span><br><span class="line">&gt;&gt;&gt; x + y # 对应元素的加法</span><br><span class="line">array([ 3., 6., 9.])</span><br><span class="line">&gt;&gt;&gt; x - y</span><br><span class="line">array([ -1., -2., -3.])</span><br><span class="line">&gt;&gt;&gt; x * y # element-wise product</span><br><span class="line">array([ 2., 8., 18.])</span><br><span class="line">&gt;&gt;&gt; x / y</span><br><span class="line">array([ 0.5, 0.5, 0.5])</span><br></pre></td></tr></table></figure><p>需要注意，数组x和数组y的元素个数相同，如果元素个数不同，程序会报错。</p><p>NumPy数组不仅可以进行<strong>对应</strong>元素的运算，也可以和单一的数值（标量）进行运算，这个功能叫<strong>广播</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0])</span><br><span class="line">&gt;&gt;&gt; x / 2.0</span><br><span class="line">array([ 0.5, 1. , 1.5])</span><br></pre></td></tr></table></figure><h3 id="NumPy的N维数组"><a href="#NumPy的N维数组" class="headerlink" title="NumPy的N维数组"></a>NumPy的N维数组</h3><p>NumPy可以生成多维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = np.array([[1, 2], [3, 4]])</span><br><span class="line">&gt;&gt;&gt; print(A)</span><br><span class="line">[[1 2]</span><br><span class="line">[3 4]]</span><br><span class="line">&gt;&gt;&gt; A.shape #查看数组形状</span><br><span class="line">(2, 2)</span><br><span class="line">&gt;&gt;&gt; A.dtype #查看数组元素的数据类型</span><br><span class="line">dtype(&apos;int64&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; B = np.array([[3, 0],[0, 6]])</span><br><span class="line">&gt;&gt;&gt; A + B   #两个二维数组相加</span><br><span class="line">array([[ 4, 2],</span><br><span class="line">[ 3, 10]])</span><br><span class="line">&gt;&gt;&gt; A * B    #两个二维数组相乘，对应位置的元素进行算术运算</span><br><span class="line">array([[ 3, 0],</span><br><span class="line">[ 0, 24]])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#广播</span><br><span class="line">&gt;&gt;&gt;print(A)</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">&gt;&gt;&gt;A*10</span><br><span class="line">array([[ 10, 20],</span><br><span class="line">[ 30, 40]])</span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>元素的索引从0开始。对各个元素的访问如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = np.array([[51, 55], [14, 19], [0, 4]])</span><br><span class="line">&gt;&gt;&gt; print(X)</span><br><span class="line">[[51 55]</span><br><span class="line">[14 19]</span><br><span class="line">[ 0 4]]</span><br><span class="line">&gt;&gt;&gt; X[0] # 第0行</span><br><span class="line">array([51, 55])</span><br><span class="line">&gt;&gt;&gt; X[0][1] # (0,1)的元素</span><br><span class="line">55</span><br></pre></td></tr></table></figure><p>也可以用for语句访问各个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for row in X:</span><br><span class="line">... print(row)</span><br><span class="line">...</span><br><span class="line">[51 55]</span><br><span class="line">[14 19]</span><br><span class="line">[0 4]</span><br></pre></td></tr></table></figure><p>除了前面介绍的索引操作，NumPy还可以使用数组访问各个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = X.flatten() # 将X转换为一维数组</span><br><span class="line">&gt;&gt;&gt; print(X)</span><br><span class="line">[51 55 14 19 0 4]</span><br><span class="line">&gt;&gt;&gt; X[np.array([0, 2, 4])] # 获取索引为0、 2、 4的元素</span><br><span class="line">array([51, 14, 0])</span><br></pre></td></tr></table></figure><p> 运用这个标记法，可以获取满足一定条件的元素。例如，要从 X中抽出大于15的元素，可以写成如下形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X &gt; 15</span><br><span class="line">array([ True, True, False, True, False, False], dtype=bool)</span><br><span class="line">&gt;&gt;&gt; X[X&gt;15]</span><br><span class="line">array([51, 55, 19])</span><br></pre></td></tr></table></figure><p>对NumPy数组使用不等号运算符等（上例中是 X &gt; 15）,结果会得到一个布尔型的数组。上例中就是使用这个布尔型数组取出了数组的各个元素（取出 True对应的元素）。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NumPy&quot;&gt;&lt;a href=&quot;#NumPy&quot; class=&quot;headerlink&quot; title=&quot;NumPy&quot;&gt;&lt;/a&gt;NumPy&lt;/h2&gt;&lt;p&gt;在学习深度学习时，NumPy的数组类提供了很多关于操作数组和矩阵的便捷方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;20
      
    
    </summary>
    
    
      <category term="python" scheme="https://meichaofan.github.io/tags/python/"/>
    
      <category term="numpy" scheme="https://meichaofan.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1-two-sum</title>
    <link href="https://meichaofan.github.io/2019/05/29/leetcode-1-two-sum/"/>
    <id>https://meichaofan.github.io/2019/05/29/leetcode-1-two-sum/</id>
    <published>2019-05-29T08:28:57.000Z</published>
    <updated>2019-05-29T09:35:10.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="PHP版本"><a href="#PHP版本" class="headerlink" title="PHP版本"></a>PHP版本</h3><h3 id="JAVA版本"><a href="#JAVA版本" class="headerlink" title="JAVA版本"></a>JAVA版本</h3><h3 id="Go版本"><a href="#Go版本" class="headerlink" title="Go版本"></a>Go版本</h3><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://meichaofan.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://meichaofan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>好好过生活，知足最快乐</title>
    <link href="https://meichaofan.github.io/2019/05/28/have-a-good-life/"/>
    <id>https://meichaofan.github.io/2019/05/28/have-a-good-life/</id>
    <published>2019-05-28T09:09:41.000Z</published>
    <updated>2019-05-28T09:21:44.136Z</updated>
    
    <content type="html"><![CDATA[<p><em>还记得 你说家是唯一的城堡</em></p><p><em>随着稻香河流继续奔跑</em></p><p><em>微微笑 小时候的梦我知道</em></p><p><em>不要哭 让萤火虫带着你逃跑</em></p><p><em>乡间的歌谣 永远的依靠</em></p><p><em>回家吧 回到最初的美好</em></p><hr><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ul><li><a href="/2019/05/28/graduation-finally/">毕业在即，云胡不喜</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;还记得 你说家是唯一的城堡&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;随着稻香河流继续奔跑&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;微微笑 小时候的梦我知道&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不要哭 让萤火虫带着你逃跑&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;乡间的歌谣 永远的依靠&lt;/em&gt;&lt;
      
    
    </summary>
    
    
      <category term="life" scheme="https://meichaofan.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>毕业在即，云乎不喜</title>
    <link href="https://meichaofan.github.io/2019/05/28/graduation-finally/"/>
    <id>https://meichaofan.github.io/2019/05/28/graduation-finally/</id>
    <published>2019-05-28T08:51:23.000Z</published>
    <updated>2019-05-28T13:32:25.535Z</updated>
    
    <content type="html"><![CDATA[<p>终于要换一种身份开启人生新一段旅程。</p><p> <img src="https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/d909af140ea14cb3f8ce3385d22b0d6.jpg" alt="没有电的实验室"></p><p><img src="https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/380a3be32413d25df630dfe3b83b976.jpg" alt="第一次看见北京早上5点钟的天空"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于要换一种身份开启人生新一段旅程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://huany-image.oss-cn-beijing.aliyuncs.com/hexo/d909af140ea14cb3f8ce3385d22b0d6.jpg&quot; alt=&quot;没有电的实
      
    
    </summary>
    
    
      <category term="life" scheme="https://meichaofan.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Linux如何给应用程序创建一个桌面启动图标</title>
    <link href="https://meichaofan.github.io/2019/04/29/linux-create-a-desktop-app/"/>
    <id>https://meichaofan.github.io/2019/04/29/linux-create-a-desktop-app/</id>
    <published>2019-04-29T02:04:29.000Z</published>
    <updated>2019-04-29T02:07:22.952Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述的是linux中如何给应用程序创建一个快速启动图标，话不多说，我们来看实际的操作步骤：</p><p>本文的实例是给celipse创建一个启动图标</p><hr><ol><li><p>我们需要通过下列命令，来创建一个启动的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/applications/eclipse.desktop</span><br></pre></td></tr></table></figure></li><li><p>将下列内容复制到启动脚本中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=Eclipse</span><br><span class="line">Comment=Eclipse IDE</span><br><span class="line">Exec=/usr/local/android/eclipse/eclipse      </span><br><span class="line">Icon=/usr/local/android/eclipse/icon.xpm</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>说明部分：<br>Exec ：这个是应用程序可执行文件的目录<br>Icon ：这个是图标的目录</p></blockquote><ol start="3"><li>然后在applications -&gt; programming 菜单中就可以找到你所创建的图标了，然后再右键创建一个桌面图标即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲述的是linux中如何给应用程序创建一个快速启动图标，话不多说，我们来看实际的操作步骤：&lt;/p&gt;
&lt;p&gt;本文的实例是给celipse创建一个启动图标&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们需要通过下列命令，来创建一个启动的脚本：&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://meichaofan.github.io/tags/Linux/"/>
    
      <category term="Desktop" scheme="https://meichaofan.github.io/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 系统修改默认运行级别</title>
    <link href="https://meichaofan.github.io/2019/04/29/ubuntu-change-runlevel/"/>
    <id>https://meichaofan.github.io/2019/04/29/ubuntu-change-runlevel/</id>
    <published>2019-04-28T17:40:12.000Z</published>
    <updated>2019-04-28T17:48:54.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Deb系运行级别（Debian、Ubuntu）"><a href="#Deb系运行级别（Debian、Ubuntu）" class="headerlink" title="Deb系运行级别（Debian、Ubuntu）"></a>Deb系运行级别（Debian、Ubuntu）</h2><blockquote><p>0 – Halt，关机模式<br>1 – Single，单用户模式<br>2 - Full multi-user with display manager (GUI)<br>3 - Full multi-user with display manager (GUI)<br>4 - Full multi-user with display manager (GUI)<br>5 - Full multi-user with display manager (GUI)<br>6 – Reboot，重启<br>S - 单用户恢复模式</p></blockquote><p>2~5级是没有任何区别的，他们为多用户模式。</p><h2 id="Rpm系运行级别（Redhat、CentOS）"><a href="#Rpm系运行级别（Redhat、CentOS）" class="headerlink" title="Rpm系运行级别（Redhat、CentOS）"></a>Rpm系运行级别（Redhat、CentOS）</h2><blockquote><p>0 – Halt，关机模式<br>1 – Single，单用户模式<br>2 – 多用户模式，但不能使用NFS（相当于Windows下的网上邻居）<br>3 – 字符界面的多用户模式<br>4 – Undefined<br>5 – Full multi-user with display manager (GUI)<br>6 – Reboot，重启</p></blockquote><h2 id="查看当前运行级别"><a href="#查看当前运行级别" class="headerlink" title="查看当前运行级别"></a>查看当前运行级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meichaofan@ubuntu:~$ runlevel </span><br><span class="line">N 2</span><br></pre></td></tr></table></figure><h2 id="ubuntu系统下修改运行级别"><a href="#ubuntu系统下修改运行级别" class="headerlink" title="ubuntu系统下修改运行级别"></a>ubuntu系统下修改运行级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/default/grup</span><br><span class="line">将</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;</span><br><span class="line">改为</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;</span><br><span class="line">然后执行</span><br><span class="line">update-grub2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Deb系运行级别（Debian、Ubuntu）&quot;&gt;&lt;a href=&quot;#Deb系运行级别（Debian、Ubuntu）&quot; class=&quot;headerlink&quot; title=&quot;Deb系运行级别（Debian、Ubuntu）&quot;&gt;&lt;/a&gt;Deb系运行级别（Debian、U
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="https://meichaofan.github.io/tags/ubuntu/"/>
    
      <category term="runlevel" scheme="https://meichaofan.github.io/tags/runlevel/"/>
    
  </entry>
  
  <entry>
    <title>linux的进程调度</title>
    <link href="https://meichaofan.github.io/2019/04/28/linux-process-sche/"/>
    <id>https://meichaofan.github.io/2019/04/28/linux-process-sche/</id>
    <published>2019-04-28T09:53:20.000Z</published>
    <updated>2019-04-28T09:58:37.066Z</updated>
    
    <content type="html"><![CDATA[<p>转载至 <a href="https://blog.csdn.net/gatieme/article/details/51701149" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51701149</a></p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><hr><h3 id="1-1-进程调度"><a href="#1-1-进程调度" class="headerlink" title="1.1 进程调度"></a>1.1 进程调度</h3><p>内存中保存了对每个进程的唯一描述，并通过若干结构与其它进程连接起来。</p><p><strong>调度器</strong>面对的情形就是这样，其任务是在程序之间共享CPU时间，创造并行执行的错觉，该任务分为两个不同的部分，其中一个涉及<strong>调度策略</strong>，另外一个涉及<strong>上下文切换</strong>。</p><hr><h3 id="1-2-进程的分类"><a href="#1-2-进程的分类" class="headerlink" title="1.2 进程的分类"></a>1.2 进程的分类</h3><hr><p>Linux把进程区分为<strong>实时进程</strong>和<strong>非实时进程</strong>，其中非实时进程进一步划分为<strong>交互式进程</strong>和<strong>批处理进程</strong>。</p><table><thead><tr><th>类型</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td>实时进程（real-time process）</td><td style="text-align:center">这些进程需要很强的调度需要，这样的进程不会被低优先级进程阻塞，并且他们的响应时间要尽可能的短</td><td style="text-align:center">视频音频应用程程序，机器人控制程序以及物理传感器收集数据的程序</td></tr><tr><td>交互式进程（interactive process）</td><td style="text-align:center">此类进程经常与用户进行交互，因此需要花很多时间等待键盘和鼠标操作，当接受了用户输入后，进程必须很快被唤醒，否则用户感觉系统反应迟钝</td><td style="text-align:center">shell,文本编辑程序和图形应用程序</td></tr><tr><td>批处理进程（batch process）</td><td style="text-align:center">此类进程不必与用户交互，因此经常在后台运行，因为这样的进程不必很快响应，因此常受到调度程序的怠慢</td><td style="text-align:center">程序语言的编译程序，数据库搜索引擎以及科学计算</td></tr></tbody></table><p>在Linux中，调度算法可以明确的确认所有实时进程的身份，但是没办法区分交互式程序和批处理程序，在Linux2.6的调度程序实现了基于进程过去式行为的启发式算法，以确定进程应该被当做交互式进程还是批处理进程，当然与批处理进程相比，调度程序有偏爱交互式进程的倾向。</p><h3 id="1-3-不同进程采用不同的调度策略"><a href="#1-3-不同进程采用不同的调度策略" class="headerlink" title="1.3 不同进程采用不同的调度策略"></a>1.3 不同进程采用不同的调度策略</h3><hr><p>根据进程的不同分类Linux采用不同的调度策略。</p><p><strong>对于实时进程，采用FIFO或者Round Robin的调度策略</strong>。</p><p>对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器核心思想是<strong>“完全公平”</strong>。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。</p><p>注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和/或数据）的多个线程。因此进程调度也包含了线程调度的功能。</p><p>目前实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.</p><p>但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢，因此在linux调度器的发展历程中经过了多次重大变动, linux总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程.</p><h3 id="1-4-Linux调度器的演变"><a href="#1-4-Linux调度器的演变" class="headerlink" title="1.4 Linux调度器的演变"></a>1.4 Linux调度器的演变</h3><hr><p>一开始的调度器是复杂度为<em>O(n)</em>的调度算法（实际上每次遍历所有任务，所以复杂度为<em>O(n)</em>），这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从Linux2.5开始引入了赫赫有名<em>O(1)</em>的调度器。</p><p>然而，linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在<strong>O(1)</strong>调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是<strong>CFS调度器Completely Fair Scheduler</strong>. 这个也是在2.6内核中引入的，具体为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，<strong>O(1)</strong>调度器被抛弃了。</p><p>所以完全有理由相信，后续如果再会出现一个更优秀的调度器，CFS也不会幸免。因为linux只要最好的那个。</p><h2 id="2-O-n-的始调度算法"><a href="#2-O-n-的始调度算法" class="headerlink" title="2. O(n)的始调度算法"></a>2. <em>O(n)</em>的始调度算法</h2><hr><h3 id="2-1-Linux2-4之前的内核调度器"><a href="#2-1-Linux2-4之前的内核调度器" class="headerlink" title="2.1 Linux2.4之前的内核调度器"></a>2.1 Linux2.4之前的内核调度器</h3><hr><p>早期的Linux进程调度器使用了最低的设计，它显然不关注具有很多处理器的大型架构，更不用说是超线程了。</p><p>Linux调度器使用了<strong>环形队列</strong>用于可运行的任务管理, 使用循环调度策略.</p><p>此调度器添加和删除进程效率很高（具有保护结构的锁）。简而言之，该调度器并不复杂但是简单快捷.</p><p>Linux版本2.2引入了调度类的概念，允许针对实时任务、非抢占式任务、非实时任务的调度策略。调度器还包括对称多处理 (SMP) 支持。</p><h3 id="2-2-Linux2-4的调度器"><a href="#2-2-Linux2-4的调度器" class="headerlink" title="2.2 Linux2.4的调度器"></a>2.2 Linux2.4的调度器</h3><hr><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><hr><p>在Linux2.4.18中(linux-2.5)之前的内核, 当很多任务都处于活动状态时, 调度器有很明显的限制. 这是由于调度器是使用一个复杂度为<em>O(n)</em>的算法实现的.</p><p>调度器采用基于优先级的设计，这个调度器和Linus在1992年发布的调度器没有大的区别。该调度器的<code>pick next</code>算法非常简单：对runqueue中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程。(Runqueue是Linux 内核中保存所有就绪进程的队列)。 <code>pick next</code>用来指从所有候选进程中挑选下一个要被调度的进程的过程。</p><p>这种调度算法非常简单易懂: <strong>在每次进程切换时, 内核扫描可运行进程的链表, 计算优先级,然后选择“最佳”进程来运行。</strong></p><p>在这种调度器中, 调度任务所花费的时间是一个系统中任务个数的函数. 换而言之, 活动的任务越多, 调度任务所花费的时间越长. 在任务负载非常重时, 处理器会因调度消耗掉大量的时间, 用于任务本身的时间就非常少了。因此，这个算法缺乏可伸缩性</p><h4 id="2-2-2-详情"><a href="#2-2-2-详情" class="headerlink" title="2.2.2 详情"></a>2.2.2 详情</h4><hr><p>每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有RUNNING进程的时间片都被用完之后，才对所有进程重新分配时间片。这段时间被称为一个epoch。这种设计保证了每个进程都有机会得到执行。每个epoch中，每个进程允许执行到其时间切片用完。如果某个进程没有使用其所有的时间切片，那么剩余时间切片的一半将被添加到新时间切片使其在下个epoch中可以执行更长时间。调度器只是迭代进程，应用goodness函数（指标）决定下面执行哪个进程。当然，各种进程对调度的需求并不相同，Linux 2.4调度器主要依靠改变进程的优先级，来满足不同进程的调度需求。事实上，所有后来的调度器都主要依赖修改进程优先级来满足不同的调度需求。</p><p>实时进程：实时进程的优先级是静态设定的，而且始终大于普通进程的优先级。因此只有当runqueue中没有实时进程的情况下，普通进程才能够获得调度。</p><blockquote><p>实时进程采用两种调度策略，SCHED_FIFO 和 SCHED_RR。FIFO 采用先进先出的策略，对于所有相同优先级的进程，最先进入 runqueue 的进程总能优先获得调度；Round Robin采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流获得调度。</p></blockquote><p>普通进程：对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速的用户响应。普通进程的优先级主要由进程描述符中的<code>Counter</code>字段决定 (还要加上<code>nice</code>设定的静态优先级) 。进程被创建时子进程的counter值为父进程counter值的一半，这样保证了任何进程不能依靠不断地<code>fork()</code>子进程从而获得更多的执行机会。</p><p>Linux2.4调度器是如何提高交互式进程的优先级的呢？如前所述，当所有 RUNNING 进程的时间片被用完之后，调度器将重新计算所有进程的 counter 值，所有进程不仅包括 RUNNING 进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的 counter 本来就没有用完，在重新计算时，他们的 counter 值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因等待用户输入而处于睡眠状态，当它们重新被唤醒并进入 runqueue 时，就会优先于其它进程而获得 CPU。从用户角度来看，交互式进程的响应速度就提高了。</p><p>该调度器的主要缺点：</p><ul><li><p>可扩展性不好<br>调度器选择进程时需要遍历整个 runqueue 从中选出最佳人选，因此该算法的执行时间与进程数成正比。另外每次重新计算 counter 所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新 counter 操作的代价会非常高，导致系统整体的性能下降。</p></li><li><p>高负载系统上的调度性能比较低<br>2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间于该时间片的大小成正比。</p></li><li><p>交互式进程的优化并不完善<br>Linux2.4识别交互式进程的原理基于以下假设，即交互式进程比批处理进程更频繁地处于SUSPENDED状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行IO操作，比如一个数据库引擎在处理查询时会经常地进行磁盘IO，虽然它们并不需要快速地用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。</p></li><li><p>对实时进程的支持不够<br>Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</p></li></ul><p>为了解决这些问题，Ingo Molnar开发了新的<em>O(1)</em>调度器，在CFS和RSDL之前，这个调度器不仅被Linux2.6采用，还被backport到Linux2.4中，很多商业的发行版本都采用了这个调度器</p><h2 id="3-O-1-的调度算法"><a href="#3-O-1-的调度算法" class="headerlink" title="3. O(1)的调度算法"></a>3. <em>O(1)</em>的调度算法</h2><hr><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><hr><p>由于进程优先级的最大值为139，因此MAX_PRIO的最大值取140(具体的是，普通进程使用100到139的优先级，实时进程使用0到99的优先级).</p><p>因此，该调度算法为每个优先级都设置一个可运行队列, 即包含140个可运行状态的进程链表，每一条优先级链表上的进程都具有相同的优先级，而不同进程链表上的进程都拥有不同的优先级。</p><p>除此之外, 还包括一个优先级位图bitmap。该位图使用一个位(bit)来代表一个优先级，而140个优先级最少需要5个32位来表示， 因此只需要一个int[5]就可以表示位图，该位图中的所有位都被置0，当某个优先级的进程处于可运行状态时，该优先级所对应的位就被置1。</p><p>如果确定了优先级，那么选取下一个进程就简单了，只需在queue数组中对应的链表上选取一个进程即可。</p><p>最后，在早期的内核中，抢占是不可能的；这意味着如果有一个低优先级的任务在执行，高优先级的任务只能等待它完成。</p><h3 id="3-2-详情"><a href="#3-2-详情" class="headerlink" title="3.2 详情"></a>3.2 详情</h3><hr><p>从名字就可以看出O(1)调度器主要解决了以前版本中的扩展性问题。</p><p>O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。</p><p>此外Linux 2.6内核支持内核态抢占，因此更好地支持了实时进程。</p><p>相对于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。</p><p>Linux 2.6内核也支持三种调度策略。其中SCHED_FIFO和SCHED_RR用于实时进程，而SCHED_NORMAL用于普通进程。</p><p>O(1)调度器在两个方面修改了Linux 2.4调度器，<strong>一是进程优先级的计算方法；二是pick next算法。</strong></p><p>O(1)调度器跟踪运行队列中可运行的任务（实际上，每个优先级水平有两个运行队列，一个用于活动任务，一个用于过期任务）， 这意味着要确定接下来执行的任务，调度器只需按优先级将下一个任务从特定活动的运行队列中取出即可。</p><h3 id="3-2-1-普通进程的优先级计算"><a href="#3-2-1-普通进程的优先级计算" class="headerlink" title="3.2.1 普通进程的优先级计算"></a>3.2.1 普通进程的优先级计算</h3><hr><p>不同类型的进程应该有不同的优先级。每个进程与生俱来（即从父进程那里继承而来）都有一个优先级，我们将其称为静态优先级。普通进程的静态优先级范围从100到139，100为最高优先级，139 为最低优先级，0－99保留给实时进程。当进程用完了时间片后，系统就会为该进程分配新的时间片（即基本时间片），静态优先级本质上决定了时间片分配的大小。</p><p>静态优先级和基本时间片的关系如下：</p><blockquote><p>静态优先级&lt;120，基本时间片=max((140-静态优先级)<em>20,MIN_TIMESLICE)<br>静态优先级&gt;=120，基本时间片=max((140-静态优先级)</em>5,MIN_TIMESLICE)</p></blockquote><p>其中MIN_TIMESLICE为系统规定的最小时间片。从该计算公式可以看出，静态优先级越高（值越低），进程得到的时间片越长。其结果是，优先级高的进程会获得更长的时间片，而优先级低的进程得到的时间片则较短。进程除了拥有静态优先级外，还有动态优先级，其取值范围是100到139。当调度程序选择新进程运行时就会使用进程的动态优先级，动态优先级和静态优先级的关系可参考下面的公式：</p><blockquote><p>动态优先级=max(100，min(静态优先级-bonus+5)，139)</p></blockquote><p>从上面看出，动态优先级的生成是以静态优先级为基础，再加上相应的惩罚或奖励(bonus)。这个bonus并不是随机的产生，而是根据进程过去的平均睡眠时间做相应的惩罚或奖励。</p><p>所谓平均睡眠时间（sleep_avg，位于task_struct结构中）就是进程在睡眠状态所消耗的总时间数，这里的平均并不是直接对时间求平均数。平均睡眠时间随着进程的睡眠而增长，随着进程的运行而减少。因此，平均睡眠时间记录了进程睡眠和执行的时间，它是用来判断进程交互性强弱的关键数据。如果一个进程的平均睡眠时间很大，那么它很可能是一个交互性很强的进程。反之，如果一个进程的平均睡眠时间很小，那么它很可能一直在执行。另外，平均睡眠时间也记录着进程当前的交互状态，有很快的反应速度。比如一个进程在某一小段时间交互性很强，那么sleep_avg就有可能暴涨（当然它不能超过 MAX_SLEEP_AVG），但如果之后都一直处于执行状态，那么sleep_avg就又可能一直递减。理解了平均睡眠时间，那么bonus的含义也就显而易见了。交互性强的进程会得到调度程序的奖励（bonus为正），而那些一直霸占CPU的进程会得到相应的惩罚（bonus为负）。其实bonus相当于平均睡眠时间的缩影，此时只是将sleep_avg调整成bonus数值范围内的大小。可见平均睡眠时间可以用来衡量进程是否是一个交互式进程。如果满足下面的公式，进程就被认为是一个交互式进程：</p><blockquote><p>动态优先级≤3*静态优先级/4 + 28</p></blockquote><p>平均睡眠时间是进程处于等待睡眠状态下的时间，该值在进程进入睡眠状态时增加，而进入RUNNING状态后则减少。该值的更新时机分布在很多内核函数内：时钟中断scheduler_tick()；进程创建；进程从TASK_INTERRUPTIBLE状态唤醒；负载平衡等。</p><h3 id="3-2-2-实时进程的优先级计算"><a href="#3-2-2-实时进程的优先级计算" class="headerlink" title="3.2.2 实时进程的优先级计算"></a>3.2.2 实时进程的优先级计算</h3><hr><p>实时进程的优先级由sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用rt_priority域表示。</p><h3 id="3-2-3-pick-next算法"><a href="#3-2-3-pick-next算法" class="headerlink" title="3.2.3 pick next算法"></a>3.2.3 pick next算法</h3><hr><p>普通进程的调度选择算法基于进程的优先级，拥有最高优先级的进程被调度器选中。</p><p>Linux2.4中，时间片counter同时也表示了一个进程的优先级。Linux2.6中时间片用任务描述符中的time_slice域表示，而优先级用prio（普通进程）或者rt_priority（实时进程）表示。调度器为每一个CPU维护了两个进程队列数组：指向活动运行队列的active数组和指向过期运行队列的expire数组。数组中的元素着保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。它们是按照先进先出的顺序进行服务的。被调度执行的任务都会被添加到各自运行队列优先级列表的末尾。每个任务都有一个时间片，这取决于系统允许执行这个任务多长时间。运行队列的前100个优先级列表保留给实时任务使用，后40个用于用户任务，参见下图：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/Linux-runqueue.png?raw=true" width="50%" height="50%"></div><p>当需要选择当前最高优先级的进程时，2.6调度器不用遍历整个runqueue，而是直接从active数组中选择当前最高优先级队列中的第一个进程。假设当前所有进程中最高优先级为50（换句话说，系统中没有任何进程的优先级小于50）。则调度器直接读取 active[49]，得到优先级为50的进程队列指针。该队列头上的第一个进程就是被选中的进程。这种算法的复杂度为O(1)，从而解决了2.4调度器的扩展性问题。为了实现O(1)算法active数组维护了一个由5个32位的字（140个优先级）组成的bitmap，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。 sched_find_first_bit()函数查询该bitmap，返回当前被置位的最高优先级的数组下标。在上例中sched_find_first_bit函数将返回49。在IA处理器上可以通过bsfl等指令实现。可见查找一个任务来执行所需要的时间并不依赖于活动任务的个数，而是依赖于优先级的数量。这使得 2.6 版本的调度器成为一个复杂度为 O(1) 的过程，因为调度时间既是固定的，而且也不会受到活动任务个数的影响。</p><p>为了提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法：每次时钟tick中断时，进程的时间片(time_slice)被减一。当time_slice为0时，表示当前进程的时间片用完，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置其时间片并重新插入active数组。如果不是交互式进程则从active数组中移到expired数组，并根据上述公式重新计算时间片。这样实时进程和交互式进程就总能优先获得CPU。然而这些进程不能始终留在active数组中，否则进入expire数组的进程就会产生饥饿现象。当进程已经占用CPU时间超过一个固定值后，即使它是实时进程或者交互式进程也会被移到expire数组中。当active数组中的所有进程都被移到expire数组中后，调度器交换active数组和expire数组。因此新的active数组又恢复了初始情况，而expire数组为空，从而开始新的一轮调度。</p><p>Linux 2.6调度器改进了前任调度器的可扩展性问题，schedule()函数的时间复杂度为O(1)。这取决于两个改进：</p><ul><li>pick next算法借助于active数组，无需遍历runqueue；</li><li>消了定期更新所有进程counter的操作，动态优先级的修改分布在进程切换，时钟tick中断以及其它一些内核函数中进行。</li></ul><p>为了解决O(1)调度器面临的问题以及应对其他外部压力, 需要改变某些东西。这种改变来自Con Kolivas的内核补丁staircase scheduler（楼梯调度算法），以及改进的RSDL（Rotating Staircase Deadline Scheduler）。它为调度器设计提供了一个新的思路。Ingo Molnar在RSDL之后开发了CFS，并最终被2.6.23内核采用。接下来我们开始介绍这些新一代调度器。</p><h2 id="4-Linux-2-6的新一代调度器CFS"><a href="#4-Linux-2-6的新一代调度器CFS" class="headerlink" title="4. Linux 2.6的新一代调度器CFS"></a>4. Linux 2.6的新一代调度器CFS</h2><hr><h3 id="4-1-楼梯调度算法staircase-scheduler"><a href="#4-1-楼梯调度算法staircase-scheduler" class="headerlink" title="4.1 楼梯调度算法staircase scheduler"></a>4.1 楼梯调度算法staircase scheduler</h3><hr><p>楼梯算法(SD)在思路上和O(1)算法有很大不同，它抛弃了动态优先级的概念。而采用了一种完全公平的思路。前任算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。楼梯算法思路简单，但是实验证明它对应交互式进程的响应比其前任更好，而且极大地简化了代码。</p><p>和O(1)算法一样，楼梯算法也同样为每一个优先级维护一个进程列表，并将这些列表组织在active数组中。当选取下一个被调度进程时，SD算法也同样从active数组中直接读取。与O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到expire数组中。而是被加入active数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就象一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为1，当它到达最后一级台阶140后，再次用完时间片时将回到优先级为2的任务队列中，即第二级台阶。不过此时分配给该任务的time_slice将变成原来的2倍。比如原来该任务的时间片time_slice为10ms，则现在变成了20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为P，当它从第N级台阶开始下楼梯并到达底部后，将回到第N+1级台阶。并且赋予该任务N+1倍的时间片。</p><p>以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即FIFO或者Round Robin。</p><p>楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。</p><p>楼梯算法的优点：从实现角度看，SD基本上还是沿用了O(1)的整体框架，只是删除了O(1)调度器中动态修改优先级的复杂代码；还淘汰了expire数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。</p><h3 id="4-2-RSLD-Rotating-Staircase-Deadline-Scheduler"><a href="#4-2-RSLD-Rotating-Staircase-Deadline-Scheduler" class="headerlink" title="4.2 RSLD(Rotating Staircase Deadline Scheduler)"></a>4.2 RSLD(Rotating Staircase Deadline Scheduler)</h3><hr><p>RSDL也是由Con Kolivas开发的，它是对SD算法的改进。核心的思想还是”完全公平”。没有复杂的动态优先级调整策略。RSDL重新引入了expire数组。它为每一个优先级都分配了一个 “组时间配额”，记为Tg；同一优先级的每个进程都拥有同样的”优先级时间配额”，用Tp表示。当进程用完了自身的Tp时，就下降到下一优先级进程组中。这个过程和SD相同，在RSDL中这个过程叫做minor rotation（次轮询）。请注意Tp不等于进程的时间片，而是小于进程的时间片。下图表示了minor rotation。进程从priority1的队列中一步一步下到priority140之后回到priority2的队列中，这个过程如下图左边所示，然后从priority 2开始再次一步一步下楼，到底后再次反弹到priority3队列中，如下图所示。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/RSLD.png?raw=true" width="50%" height="50%"></div><p>在SD算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得CPU。因此低优先级进程的等待时间无法确定。RSDL中，当高优先级进程组用完了它们的Tg(即组时间配额)时，无论该组中是否还有进程Tp尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是RSDL中Deadline代表的含义。<br>进程用完了自己的时间片time_slice时（下图中T2），将放入expire数组指向的对应初始优先级队列中(priority 1)。</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/3.png?raw=true" width="50%" height="50%"></div><p>当active数组为空，或者所有的进程都降低到最低优先级时就会触发主轮询major rotation。Major rotation交换active数组和expire数组，所有进程都恢复到初始状态，再一次从新开始minor rotation的过程。<br>RSDL对交互式进程的支持：和SD同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为minor rotation而降到了低优先级进程队列中。当它重新进入RUNNING状态时，就获得了相对较高的优先级，从而能被迅速响应。</p><h3 id="4-3-安全公平的调度器CFS"><a href="#4-3-安全公平的调度器CFS" class="headerlink" title="4.3 安全公平的调度器CFS"></a>4.3 安全公平的调度器CFS</h3><hr><p>CFS是最终被内核采纳的调度器。它从RSDL/SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS的算法和实现都相当简单，众多的测试表明其性能也非常优越。<br>按照作者Ingo Molnar的说法（参考Documentation/scheduler/sched-design-CFS.txt），</p><p>CFS百分之八十的工作可以用一句话概括：CFS在真实的硬件上模拟了完全理想的多任务处理器。在真空的硬件上，同一时刻我们只能运行单个进程，因此当一个进程占用CPU时，其它进程就必须等待，这就产生了不公平。但是在“完全理想的多任务处理器 “下，每个进程都能同时获得CPU的执行时间，即并行地每个进程占1/nr_running的时间。例如当系统中有两个进程时，CPU的计算时间被分成两份，每个进程获得50%。假设runqueue中有n个进程，当前进程运行了10ms。在“完全理想的多任务处理器”中，10ms应该平分给n个进程(不考虑各个进程的nice值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了10ms。所以CFS将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。</p><p>与之前的Linux调度器不同，CFS没有将任务维护在链表式的运行队列中，它抛弃了active/expire数组，而是对每个CPU维护一个以时间为顺序的红黑树。 </p><p>该树方法能够良好运行的原因在于：</p><ul><li>红黑树可以始终保持平衡，这意味着树上没有路径比任何其他路径长两倍以上。</li><li>由于红黑树是二叉树，查找操作的时间复杂度为O(log n)。但是除了最左侧查找以外，很难执行其他查找，并且最左侧的节点指针始终被缓存。</li><li>对于大多数操作（插入、删除、查找等），红黑树的执行时间为O(log n)，而以前的调度程序通过具有固定优先级的优先级数组使用 O(1)。O(log n) 行为具有可测量的延迟，但是对于较大的任务数无关紧要。Molnar在尝试这种树方法时，首先对这一点进行了测试。</li><li>红黑树可通过内部存储实现，即不需要使用外部分配即可对数据结构进行维护。</li></ul><p>要实现平衡，CFS使用”虚拟运行时”表示某个任务的时间量。任务的虚拟运行时越小，意味着任务被允许访问服务器的时间越短，其对处理器的需求越高。CFS还包含睡眠公平概念以便确保那些目前没有运行的任务（例如，等待 I/O）在其最终需要时获得相当份额的处理器。</p><h4 id="4-3-1-CFS如何实现pick-next"><a href="#4-3-1-CFS如何实现pick-next" class="headerlink" title="4.3.1 CFS如何实现pick next"></a>4.3.1 CFS如何实现pick next</h4><hr><p>下图是一个红黑树的例子</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/linux/virtual_running_time.png?raw=true" width="50%" height="50%"></div><p>所有可运行的任务通过不断地插入操作最终都存储在以时间为顺序的红黑树中（由 sched_entity 对象表示），对处理器需求最多的任务（最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧。 为了公平，CFS调度器会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。这样，树左侧的进程就被给予时间运行了。</p><h4 id="4-3-2-tick中断"><a href="#4-3-2-tick中断" class="headerlink" title="4.3.2 tick中断"></a>4.3.2 tick中断</h4><hr><p>在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。从这里可以看到 CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有调度器都在tick中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。</p><h4 id="4-3-3-红黑树键值计算"><a href="#4-3-3-红黑树键值计算" class="headerlink" title="4.3.3 红黑树键值计算"></a>4.3.3 红黑树键值计算</h4><hr><p>理解CFS的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的CPU时间；二是当前进程的nice值；三是当前的cpu负载。进程已经占用的CPU时间对键值的影响最大，其实很大程度上我们在理解CFS时可以简单地认为键值就等于进程已占用的 CPU时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外CFS规定，nice值为1的进程比nice值为0的进程多获得10%的 CPU时间。在计算键值时也考虑到这个因素，因此nice值越大，键值也越大。</p><p>CFS为每个进程都维护两个重要变量：fair_clock和wait_runtime。这里我们将为每个进程维护的变量称为进程级变量，为每个CPU维护的称作CPU级变量，为每个runqueue维护的称为runqueue级变量。进程插入红黑树的键值即为fair_clock – wait_runtime。其中fair_clock从其字面含义上讲就是一个进程应获得的CPU时间，即等于进程已占用的CPU时间除以当前 runqueue中的进程总数；wait_runtime是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。对于交互式任务，wait_runtime长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。</p><p>红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是O(LogN)</p><h4 id="4-3-4-调度器管理器"><a href="#4-3-4-调度器管理器" class="headerlink" title="4.3.4 调度器管理器"></a>4.3.4 调度器管理器</h4><hr><p>为了支持实时进程，CFS提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23中，CFS实现了两个调度算法，CFS算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用CFS算法。CFS 调度模块（在 kernel/sched_fair.c 中实现）用于以下调度策略：SCHED_NORMAL、SCHED_BATCH 和 SCHED_IDLE。对于 SCHED_RR 和 SCHED_FIFO 策略，将使用实时调度模块（该模块在 kernel/sched_rt.c 中实现）。</p><h4 id="4-3-5-CFS组调度"><a href="#4-3-5-CFS组调度" class="headerlink" title="4.3.5 CFS组调度"></a>4.3.5 CFS组调度</h4><hr><p>CFS组调度（在 2.6.24 内核中引入）是另一种为调度带来公平性的方式，尤其是在处理产生很多其他任务的任务时。 假设一个产生了很多任务的服务器要并行化进入的连接（HTTP 服务器的典型架构）。不是所有任务都会被统一公平对待， CFS 引入了组来处理这种行为。产生任务的服务器进程在整个组中（在一个层次结构中）共享它们的虚拟运行时，而单个任务维持其自己独立的虚拟运行时。这样单个任务会收到与组大致相同的调度时间。您会发现 /proc 接口用于管理进程层次结构，让您对组的形成方式有完全的控制。使用此配置，您可以跨用户、跨进程或其变体分配公平性。</p><p>考虑一个两用户示例，用户 A 和用户 B 在一台机器上运行作业。用户 A 只有两个作业正在运行，而用户 B 正在运行 48 个作业。组调度使 CFS 能够对用户 A 和用户 B 进行公平调度，而不是对系统中运行的 50 个作业进行公平调度。每个用户各拥有 50% 的 CPU 使用。用户 B 使用自己 50% 的 CPU 分配运行他的 48 个作业，而不会占用属于用户 A 的另外 50% 的 CPU 分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载至 &lt;a href=&quot;https://blog.csdn.net/gatieme/article/details/51701149&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/gatieme/article
      
    
    </summary>
    
    
  </entry>
  
</feed>
