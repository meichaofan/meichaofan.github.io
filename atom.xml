<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>huany</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meichaofan.github.io/"/>
  <updated>2019-04-03T15:52:34.577Z</updated>
  <id>https://meichaofan.github.io/</id>
  
  <author>
    <name>meichaofan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码从哪里读起?</title>
    <link href="https://meichaofan.github.io/2019/04/03/Redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/"/>
    <id>https://meichaofan.github.io/2019/04/03/Redis源码从哪里读起/</id>
    <published>2019-04-03T15:52:12.000Z</published>
    <updated>2019-04-03T15:52:34.577Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Redis" scheme="https://meichaofan.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御</title>
    <link href="https://meichaofan.github.io/2019/04/02/CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>https://meichaofan.github.io/2019/04/02/CSRF攻击与防御/</id>
    <published>2019-04-01T16:15:59.000Z</published>
    <updated>2019-04-01T17:04:37.076Z</updated>
    
    <content type="html"><![CDATA[<p>转载至 <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p><hr><h2 id="一、CSRF是什么？"><a href="#一、CSRF是什么？" class="headerlink" title="一、CSRF是什么？"></a>一、CSRF是什么？</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><h2 id="二、CSRF可以做什么？"><a href="#二、CSRF可以做什么？" class="headerlink" title="二、CSRF可以做什么？"></a>二、CSRF可以做什么？</h2><p>你这可以这么理解CSRF攻击：<strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong>。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><h2 id="三、CSRF漏洞现状"><a href="#三、CSRF漏洞现状" class="headerlink" title="三、CSRF漏洞现状"></a>三、CSRF漏洞现状</h2><p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p><h2 id="四、CSRF的原理"><a href="#四、CSRF的原理" class="headerlink" title="四、CSRF的原理"></a>四、CSRF的原理</h2><p>下图简单阐述了CSRF攻击的思想：</p><div align="center"><img src="https://github.com/meichaofan/static-file/blob/master/web%E5%AE%89%E5%85%A8/2009040916453171.jpg?raw=true" width="50%" height="50%"></div><br><div align="center">图1：CSRF攻击原理</div><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1.<strong>登录受信任网站A，并在本地生成Cookie。</strong></p><p>　　2.<strong>在不登出A的情况下，访问危险网站B。</strong></p><p>　　看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p><p>　　1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p><p>　　2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</p><p>　　3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p><p>　　上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></p><p>危险网站B，它里面有一段HTML的代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure></p><p>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</p><p>为什么会这样呢？<strong>原因是银行网站A违反了HTTP规范，使用GET请求更新资源</strong>。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<img>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源”<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&quot;，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作....." target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&quot;，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作.....</a>.</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p><p>银行网站A的WEB表单如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"Transfer.php"</span> method=<span class="string">"POST"</span>&gt;</span><br><span class="line">　　&lt;p&gt;ToBankId: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"toBankId"</span> /&gt;&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;Money: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"money"</span> /&gt;&lt;/p&gt;</span><br><span class="line">　　&lt;p&gt;&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"Transfer"</span> /&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后台处理页面Transfer.php如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (isset(<span class="variable">$_REQUEST</span>[<span class="string">'toBankId'</span>] &amp;&amp;　isset(<span class="variable">$_REQUEST</span>[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_REQUEST</span>[<span class="string">'toBankId'</span>],　<span class="variable">$_REQUEST</span>[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>危险网站B，仍然只是包含那句HTML代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><p>　经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　session_start();</span><br><span class="line">　　　　<span class="keyword">if</span> (isset(<span class="variable">$_POST</span>[<span class="string">'toBankId'</span>] &amp;&amp;　isset(<span class="variable">$_POST</span>[<span class="string">'money'</span>]))</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　    buy_stocks(<span class="variable">$_POST</span>[<span class="string">'toBankId'</span>],　<span class="variable">$_POST</span>[<span class="string">'money'</span>]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>然而，危险网站B与时俱进，它改了一下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">　　　　　　<span class="keyword">function</span> steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames[<span class="string">"steal"</span>];</span><br><span class="line">　　     　　      iframe.document.Submit(<span class="string">"transfer"</span>);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;body onload=<span class="string">"steal()"</span>&gt;</span><br><span class="line">　　　　&lt;iframe name=<span class="string">"steal"</span> display=<span class="string">"none"</span>&gt;</span><br><span class="line">　　　　　　&lt;form method=<span class="string">"POST"</span> name=<span class="string">"transfer"</span>　action=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span><br><span class="line">　　　　　　　　&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"toBankId"</span> value=<span class="string">"11"</span>&gt;</span><br><span class="line">　　　　　　　　&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"money"</span> value=<span class="string">"1000"</span>&gt;</span><br><span class="line">　　　　　　&lt;/form&gt;</span><br><span class="line">　　　　&lt;/iframe&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行!</p><p>总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个<img>就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p><p>理解上面的3种攻击模式，其实可以看出，<strong>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</strong></p><h2 id="五-CSRF的防御"><a href="#五-CSRF的防御" class="headerlink" title="五.CSRF的防御"></a>五.CSRF的防御</h2><p>我总结了一下看到的资料，CSRF的防御可以从<strong>服务端</strong>和<strong>客户端</strong>两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p><h3 id="1-服务器端进行CSRF防御"><a href="#1-服务器端进行CSRF防御" class="headerlink" title="1.服务器端进行CSRF防御"></a>1.服务器端进行CSRF防御</h3><p>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p><h4 id="1-Cookie-Hashing-所有表单都包含同一个伪随机值-："><a href="#1-Cookie-Hashing-所有表单都包含同一个伪随机值-：" class="headerlink" title="1).Cookie Hashing(所有表单都包含同一个伪随机值)："></a>1).Cookie Hashing(所有表单都包含同一个伪随机值)：</h4><p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　//构造加密的Cookie信息</span><br><span class="line">　　　　<span class="variable">$value</span> = “DefenseSCRF”;</span><br><span class="line">　　　　setcookie(”cookie”, <span class="variable">$value</span>, time()+3600);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">　　　　<span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">'cookie'</span>]);</span><br><span class="line">?&gt;</span><br><span class="line">　　&lt;form method=”POST” action=”transfer.php”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”text” name=”toBankId”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”text” name=”money”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”hidden” name=”<span class="built_in">hash</span>” value=”&lt;?=<span class="variable">$hash</span>;?&gt;”&gt;</span><br><span class="line">　　　　&lt;input <span class="built_in">type</span>=”submit” name=”submit” value=”Submit”&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后再服务器端进行Hash值验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isset(<span class="variable">$_POST</span>[<span class="string">'check'</span>])) &#123;</span><br><span class="line">        <span class="variable">$hash</span> = md5(<span class="variable">$_COOKIE</span>[<span class="string">'cookie'</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">'check'</span>] == <span class="variable">$hash</span>) &#123;</span><br><span class="line">        　　 doJob();</span><br><span class="line">　　     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　 　　//...</span><br><span class="line">         </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　       &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。</p><h4 id="2-验证码"><a href="#2-验证码" class="headerlink" title="2).验证码"></a>2).验证码</h4><p>这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p><h4 id="3-One-Time-Tokens-不同的表单包含一个不同的伪随机值"><a href="#3-One-Time-Tokens-不同的表单包含一个不同的伪随机值" class="headerlink" title="3).One-Time Tokens(不同的表单包含一个不同的伪随机值)"></a>3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</h4><p>在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。</p><h4 id="4-slim框架CSRF实现"><a href="#4-slim框架CSRF实现" class="headerlink" title="4)slim框架CSRF实现"></a>4)slim框架CSRF实现</h4><p><a href="https://github.com/slimphp/Slim-Csrf" target="_blank" rel="noopener">slim框架的csrf预防源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载至 &lt;a href=&quot;http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/hyddd/ar
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://meichaofan.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="CSRF" scheme="https://meichaofan.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>源码文件</title>
    <link href="https://meichaofan.github.io/2019/03/29/%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    <id>https://meichaofan.github.io/2019/03/29/源码文件/</id>
    <published>2019-03-29T07:23:08.000Z</published>
    <updated>2019-03-29T08:54:52.225Z</updated>
    
    <content type="html"><![CDATA[<p>go文件主要分为下面3类:</p><p><img src alt="go文件分类"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go文件主要分为下面3类:&lt;/p&gt;
&lt;p&gt;&lt;img src alt=&quot;go文件分类&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>工作区和GOPATH</title>
    <link href="https://meichaofan.github.io/2019/03/29/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH/"/>
    <id>https://meichaofan.github.io/2019/03/29/工作区和GOPATH/</id>
    <published>2019-03-29T05:56:32.000Z</published>
    <updated>2019-03-29T07:18:28.665Z</updated>
    
    <content type="html"><![CDATA[<p>我们学习Go语言时，第一件要做的是，就是根据自己电脑的操作系统和计算架构，从<a href="https://golang.google.cn" target="_blank" rel="noopener">Go语言官网</a>下载对应的二进制包，也就是拿来即用的安装包。</p><p>随后，<strong>解压安装包</strong>、<strong>放置到某个目录</strong>、<strong>配置环境变量</strong>，并在命令行输入 <code>go version</code> 来验证是否安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[root@www package]# ls go1.12.1.linux-amd64.tar.gz </span><br><span class="line">go1.12.1.linux-amd64.tar.gz</span><br><span class="line">[root@www package]# tar zxvf go1.12.1.linux-amd64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置GOROOT、GOPATH、GOBIN环境变量</span></span><br><span class="line">[root@www ~]# vim .bash_profile</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin:/usr/local/php/bin:/usr/local/go/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/root/peek-a-bow</span><br><span class="line">export GOBIN=/root/peek-a-bow/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建工作目录</span></span><br><span class="line">mkdir -p /root/peek-a-bow/&#123;src,bin,pkg&#125;</span><br></pre></td></tr></table></figure><p>在整个安装过程中，需要配置3个环境变量，简单介绍一下:</p><ul><li>GOROOT: Go语言的安装目录</li><li>GOPATH: 自定义的工作目录</li><li>GOBIN: Go语言生成的可执行文件的目录</li></ul><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区（workspace）。</p><p>我们需要利于这些工作区，去放置 Go 语言的源码文件（source file）,以及安装(install)后的归档文件（archive file）和可执行文件（executable file）。</p><p>事实上，由于Go语言项目在其生命周期内的所有操作（编码依赖管理、构建、测试、安装等）基本上都是围绕着GOPATH和工作区进行的。它的背后有3个知识点需要注意:</p><ul><li>1.Go语言源码的组织是怎样的；</li><li>2.你是否了解源码安装后的结果；</li><li>3.你是否理解构建和安装Go程序的过程。</li></ul><h3 id="1-Go语言源码组织方式"><a href="#1-Go语言源码组织方式" class="headerlink" title="1.Go语言源码组织方式"></a>1.Go语言源码组织方式</h3><p>Go语言是以代码包为基本组织单位的。所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录和代码包为主线的。</p><h3 id="2-了解源码安装后的结果"><a href="#2-了解源码安装后的结果" class="headerlink" title="2.了解源码安装后的结果"></a>2.了解源码安装后的结果</h3><p>源码文件在安装过程中，如果产生了归档文件，就会放进该工作区的pkg子目录；如果产生了可执行文件，就会放进该工作区的bin子目录。</p><h3 id="3-理解构建和安装Go程序的过程"><a href="#3-理解构建和安装Go程序的过程" class="headerlink" title="3.理解构建和安装Go程序的过程"></a>3.理解构建和安装Go程序的过程</h3><p>构建使用 <code>go build</code>,安装使用命令 <code>go install</code>。构建和安装代码包的时候都会执行编译、打包等操作。并且，这些操作产生的任何文件都会先被保存到某个临时的目录中。</p><p>如果构建的是<strong>库源码</strong>文件,那么操作结果只会保存在临时目录中，安装<strong>库源码</strong>文件，那么它的结果会被搬运到它所在工作区的pkg目录下的某个子目录中。</p><p>如果构建的是<strong>命令源码</strong>文件，那么它的操作结果文件会被搬运到源码文件所在的目录中。如果安装的是<strong>命令源码</strong>文件，那么结果文件会被搬运到它所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们学习Go语言时，第一件要做的是，就是根据自己电脑的操作系统和计算架构，从&lt;a href=&quot;https://golang.google.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go语言官网&lt;/a&gt;下载对应的二进制包，也就是拿来即用的安装包。&lt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://meichaofan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go string 实现原理剖析</title>
    <link href="https://meichaofan.github.io/2019/03/28/Go-string-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>https://meichaofan.github.io/2019/03/28/Go-string-实现原理剖析/</id>
    <published>2019-03-27T16:18:04.000Z</published>
    <updated>2019-03-27T16:18:04.145Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>倒排索引原理</title>
    <link href="https://meichaofan.github.io/2019/03/27/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>https://meichaofan.github.io/2019/03/27/倒排索引原理/</id>
    <published>2019-03-26T18:39:09.000Z</published>
    <updated>2019-03-26T18:40:07.690Z</updated>
    
    <content type="html"><![CDATA[<p>关于<a href="https://www.elastic.co/" target="_blank" rel="noopener">ElasticSearch</a>为什么搜索这么快，大家应该有所了解，主要是利用倒排索引数据结构，下面简单介绍一下倒排索引。</p><h2 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h2><p>任何事物都是相对的，有倒排索引(inverted index)，当然也会有正向索引(forward index)。</p><h3 id="正向索引结构"><a href="#正向索引结构" class="headerlink" title="正向索引结构"></a>正向索引结构</h3><p>在搜索引擎中，每个文件(document)对应一个文件id(document id)，文件内容可以看作是一些列关键词的集合(实际上，在搜索引擎库中，关键词也转化为关键词id)。例如“文档1”经过分词，提取了20个关键词，每个关键词都会记录它在文档中的出现次数和出现位置。</p><p>得到正向索引结构如下：</p><p>“文档1”的ID &gt; 关键词1：出现次数，出现位置列表；关键词2：出现次数，出现位置列表；……</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/forward_index.png" width="50%" height="50%"></div><br><div align="center">图1：正向索引结构</div><p><strong>通过文档，去找关键词</strong>。</p><h3 id="正向索引查找过程"><a href="#正向索引查找过程" class="headerlink" title="正向索引查找过程"></a>正向索引查找过程</h3><p>当用户在主页上搜索关键词“<strong>华为手机</strong>”时，假设只存在正向索引(forward index)，那么就需要<strong>扫描索引库中的所有文档</strong>，找出所有包含关键词“<strong>华为手机</strong>”的文档，再根据<strong>打分模型</strong>进行打分，排出名次后呈现给用户。因为互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="倒排索引结构"><a href="#倒排索引结构" class="headerlink" title="倒排索引结构"></a>倒排索引结构</h3><p>由于正向索引无法满足实时返回排名结果的要求，所以，搜索引擎会将正向索引重新构建为倒排索引，即把<strong>文件id对应到关键词的映射</strong>转化为<strong>关键词到文件id的映射</strong>，每个关键词对应着一些列文件，这些文件中都出现这个关键词。</p><p>得到倒排索引的结构如下：</p><p>“关键词1” ：“文档1”的id ， “文档2”的id ，……。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/reverted-index.png" width="50%" height="50%" alt="倒排索引"></div><br><div align="center">图2：倒排索引结构</div><p><strong>通过关键词，去找文档</strong>。</p><h3 id="单词-文档矩阵"><a href="#单词-文档矩阵" class="headerlink" title="单词-文档矩阵"></a>单词-文档矩阵</h3><p>单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%8D%95%E8%AF%8D%E6%96%87%E6%A1%A3%E7%9F%A9%E9%98%B5.png" width="50%" height="50%" alt="单词文档矩阵"></div><br><div align="center">图3：单词-文档矩阵</div><p>从纵向看（即从文档这个维度看），每列代表文档包含了哪些单词，比如文档1包含了词汇1和词汇4，而不包含其它单词。</p><p>从横向看（即从单词这个维度看），每行代表了哪些文档包含了这个单词。比如词汇1来说，文档1和文档4中出现过单词1，而其它文档不包含词汇1。</p><p>搜索引擎，其实就是实现了 “<strong>单词-文档矩阵</strong>”的具体<strong>数据结构</strong>，可以有不同的方式来实现上述概念模型，比如“<strong>倒排索引</strong>”、“<strong>签名文件</strong>”、“<strong>后缀树</strong>”等方式。目前ElasticSearch中是使用“倒排索引”实现单词到文档映射关系。</p><h3 id="倒排索引基本概念"><a href="#倒排索引基本概念" class="headerlink" title="倒排索引基本概念"></a>倒排索引基本概念</h3><p>文档(document):一般搜索引擎的处理对象是互联网网页，而文档这个概念要更宽泛些，代表以文本形式存在的存储对象，相比网页来说，涵盖更多种形式，比如Word，PDF，html，XML等不同格式的文件都可以称之为文档。再比如一封邮件，一条短信，一条微博也可以称之为文档。在本书后续内容，很多情况下会使用文档来表征文本信息。</p><p>文档集合(Document Collection)：由若干文档构成的集合称之为文档集合。比如海量的互联网网页或者说大量的电子邮件都是文档集合的具体例子。</p><p>文档编号(Document ID):在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。</p><p>单词编号(Word ID):与文档编号类似，搜索引擎内部以唯一的编号来表征某个单词，单词编号可以作为某个单词的唯一表征。</p><p>倒排索引(Inverted Index):倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p><p>单词字典(Lexicon)：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</p><p>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</p><p>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</p><p>关于这些概念之间的关系，通过图4可以比较清晰的看出来。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8%E6%A6%82%E5%BF%B5%E5%9B%BE.png" width="50%" height="50%" alt="倒排列表模型"></div><br><div align="center">图4：倒排列表模型</div><h3 id="倒排索引简单实例"><a href="#倒排索引简单实例" class="headerlink" title="倒排索引简单实例"></a>倒排索引简单实例</h3><p>倒排索引从逻辑结构和基本思路上来讲非常简单。下面我们通过具体实例来进行说明，使得读者能够对倒排索引有一个宏观而直接的感受。</p><p> 假设文档集合包含五个文档，每个文档内容如图3所示，在图中最左端一栏是每个文档对应的文档编号。我们的任务就是对这个文档集合建立倒排索引。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E6%96%87%E6%A1%A3%E9%9B%86%E5%90%88.png" width="50%" height="50%" alt="文档集合"></div><br> <div align="center">图5：文档集合</div><p> 中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引（参考图6）。在图6中，“单词ID”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" width="50%" height="50%" alt="最简单的倒排索引"></div><br> <div align="center">图6：最简单的倒排索引</div><p> 之所以说图6所示倒排索引是最简单的，是因为这个索引系统只记载了哪些文档包含某个单词，而事实上，索引系统还可以记录除此之外的更多信息。图7是一个相对复杂些的倒排索引，与图6的基本索引系统比，在单词对应的倒排列表中不仅记录了文档编号，还记载了单词频率信息（TF），即这个单词在某个文档中的出现次数，之所以要记录这个信息，是因为词频信息在搜索结果排序时，计算查询和文档相似度是很重要的一个计算因子，所以将其记录在倒排列表中，以方便后续排序时进行分值计算。在图7的例子里，单词“创始人”的单词编号为7，对应的倒排列表内容为：（3:1），其中的3代表文档编号为3的文档包含这个单词，数字1代表词频信息，即这个单词在3号文档中只出现过1次，其它单词对应的倒排列表所代表含义与此相同。</p> <div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%B8%A6%E6%9C%89%E8%AF%8D%E9%A2%91%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" width="50%" height="50%" alt="带有单词频率信息的倒排索引"></div><br> <div align="center">图7：带有单词频率信息的倒排索引</div><p> 实用的倒排索引还可以记载更多的信息，图8所示索引系统除了记录文档编号和单词频率信息外，额外记载了两类信息，即每个单词对应的“文档频率信息”（对应图8的第三栏）以及在倒排列表中记录单词在某个文档出现的位置信息。</p><p> “文档频率信息”代表了在文档集合中有多少个文档包含某个单词，之所以要记录这个信息，其原因与单词频率信息一样，这个信息在搜索结果排序计算中是非常重要的一个因子。而单词在某个文档中出现的位置信息并非索引系统一定要记录的，在实际的索引系统里可以包含，也可以选择不包含这个信息，之所以如此，因为这个信息对于搜索系统来说并非必需的，位置信息只有在支持“短语查询”的时候才能够派上用场。</p><p> 以单词“拉斯”为例，其单词编号为8，文档频率为2，代表整个文档集合中有两个文档包含这个单词，对应的倒排列表为：{(3;1;<4>)，(5;1;<4>)},其含义为在文档3和文档5出现过这个单词，单词频率都为1，单词“拉斯”在两个文档中的出现位置都是4，即文档中第四个单词是“拉斯”。</4></4></p><p> 图7所示倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此，区别无非是采取哪些具体的数据结构来实现上述逻辑结构。</p><p> 有了这个索引系统，搜索引擎可以很方便地响应用户的查询，比如用户输入查询词“Facebook”，搜索系统查找倒排索引，从中可以读出包含这个单词的文档，这些文档就是提供给用户的搜索结果，而利用单词频率信息、文档频率信息即可以对这些候选搜索结果进行排序，计算文档和查询的相似性，按照相似性得分由高到低排序输出，此即为搜索系统的部分内部流程。</p><h2 id="单词词典"><a href="#单词词典" class="headerlink" title="单词词典"></a>单词词典</h2><p>单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。</p><p>对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词，这直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找，常用的数据结构包括<strong>哈希加链表结构</strong>和<strong>树形词典结构</strong>。</p><h3 id="哈希加链表"><a href="#哈希加链表" class="headerlink" title="哈希加链表"></a>哈希加链表</h3><p>图8是这种词典结构的示意图。这种词典结构主要由两个部分构成：</p><p>主体部分是哈希表，每个哈希表项保存一个指针，指针指向冲突链表，在冲突链表里，相同哈希值的单词形成链表结构。之所以会有冲突链表，是因为两个不同单词获得相同的哈希值，如果是这样，在哈希方法里被称做是一次冲突，可以将相同哈希值的单词存储在链表里，以供后续查找。</p><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/%E5%93%88%E5%B8%8C%E5%8A%A0%E9%93%BE%E8%A1%A8.png" width="50%" height="50%" alt="哈希加链表"></div><br><div align="center">图8：哈希加链表结构</div><p>在建立索引的过程中，词典结构也会相应地被构建出来。比如在解析一个新文档的时候，对于某个在文档中出现的单词T，首先利用哈希函数获得其哈希值，之后根据哈希值对应的哈希表项读取其中保存的指针，就找到了对应的冲突链表。如果冲突链表里已经存在这个单词，说明单词在之前解析的文档里已经出现过。如果在冲突链表里没有发现这个单词，说明该单词是首次碰到，则将其加入冲突链表里。通过这种方式，当文档集合内所有文档解析完毕时，相应的词典结构也就建立起来了。</p><p>在响应用户查询请求时，其过程与建立词典类似，不同点在于即使词典里没出现过某个单词，也不会添加到词典内。以图8为例，假设用户输入的查询请求为单词3，对这个单词进行哈希，定位到哈希表内的2号槽，从其保留的指针可以获得冲突链表，依次将单词3和冲突链表内的单词比较，发现单词3在冲突链表内，于是找到这个单词，之后可以读出这个单词对应的倒排列表来进行后续的工作，如果没有找到这个单词，说明文档集合内没有任何文档包含单词，则搜索结果为空。</p><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p> B树（或者B+树）是另外一种高效查找结构。B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式则无须数据满足此项要求。</p><p> B树形成了层级查找结构，中间节点用于指出一定顺序范围的词典项目存储在哪个子树中，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/content.png" width="50%" height="50%" alt="内容"></div><br><div align="center">图9：文档集合</div><div align="center"><img src="https://raw.githubusercontent.com/meichaofan/static-file/master/content2.png" width="50%" height="50%" alt="倒排索引结构"></div><br><div align="center">图10：倒排索引结构</div><ul><li>单词ID：记录每个单词的单词编号；</li><li>单词：对应的单词；</li><li>文档频率：代表文档集合中有多少个文档包含某个单词</li><li>倒排列表：包含单词ID及其他必要信息</li><li>DocId：单词出现的文档id</li><li>TF：单词在某个文档中出现的次数</li><li>POS：单词在文档中出现的位置</li></ul><p>以单词“加盟”为例，其单词编号为6，文档频率为3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为{(2;1;<4>),(3;1;<7>),(5;1;<5>)}，含义是在文档2，3，5出现过这个单词，在每个文档的出现过1次，单词“加盟”在第一个文档的POS是4，即文档的第四个单词是“加盟”，其他的类似。</5></7></4></p><p>这个倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于&lt;a href=&quot;https://www.elastic.co/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ElasticSearch&lt;/a&gt;为什么搜索这么快，大家应该有所了解，主要是利用倒排索引数据结构，下面简单介绍一下倒排索引。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="倒排索引" scheme="https://meichaofan.github.io/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>
